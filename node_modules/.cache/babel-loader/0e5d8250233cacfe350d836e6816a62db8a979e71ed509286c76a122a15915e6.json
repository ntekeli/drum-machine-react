{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport var OfflineContext = /*#__PURE__*/function (_Context) {\n  _inherits(OfflineContext, _Context);\n  var _super = _createSuper(OfflineContext);\n  function OfflineContext() {\n    var _this;\n    _classCallCheck(this, OfflineContext);\n    _this = _super.call(this, {\n      clockSource: \"offline\",\n      context: isOfflineAudioContext(arguments[0]) ? arguments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n      lookAhead: 0,\n      updateInterval: isOfflineAudioContext(arguments[0]) ? 128 / arguments[0].sampleRate : 128 / arguments[2]\n    });\n    _this.name = \"OfflineContext\";\n    /**\n     * An artificial clock source\n     */\n    _this._currentTime = 0;\n    _this.isOffline = true;\n    _this._duration = isOfflineAudioContext(arguments[0]) ? arguments[0].length / arguments[0].sampleRate : arguments[1];\n    return _this;\n  }\n  /**\n   * Override the now method to point to the internal clock time\n   */\n  _createClass(OfflineContext, [{\n    key: \"now\",\n    value: function now() {\n      return this._currentTime;\n    }\n    /**\n     * Same as this.now()\n     */\n  }, {\n    key: \"currentTime\",\n    get: function get() {\n      return this._currentTime;\n    }\n    /**\n     * Render just the clock portion of the audio context.\n     */\n  }, {\n    key: \"_renderClock\",\n    value: function _renderClock(asynchronous) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var index, yieldEvery;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              index = 0;\n            case 1:\n              if (!(this._duration - this._currentTime >= 0)) {\n                _context.next = 11;\n                break;\n              }\n              // invoke all the callbacks on that time\n              this.emit(\"tick\");\n              // increment the clock in block-sized chunks\n              this._currentTime += 128 / this.sampleRate;\n              // yield once a second of audio\n              index++;\n              yieldEvery = Math.floor(this.sampleRate / 128);\n              if (!(asynchronous && index % yieldEvery === 0)) {\n                _context.next = 9;\n                break;\n              }\n              _context.next = 9;\n              return new Promise(function (done) {\n                return setTimeout(done, 1);\n              });\n            case 9:\n              _context.next = 1;\n              break;\n            case 11:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Render the output of the OfflineContext\n     * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n     */\n  }, {\n    key: \"render\",\n    value: function render() {\n      var asynchronous = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : true;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return this.workletsAreReady();\n            case 2:\n              _context2.next = 4;\n              return this._renderClock(asynchronous);\n            case 4:\n              _context2.next = 6;\n              return this._context.startRendering();\n            case 6:\n              buffer = _context2.sent;\n              return _context2.abrupt(\"return\", new ToneAudioBuffer(buffer));\n            case 8:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2, this);\n      }));\n    }\n    /**\n     * Close the context\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      return Promise.resolve();\n    }\n  }]);\n  return OfflineContext;\n}(Context);","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,yBAAyB,QAAQ,yBAAyB;AACnE,SAASC,OAAO,QAAQ,oBAAoB;AAE5C,SAASC,qBAAqB,QAAQ,2BAA2B;AACjE,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;AAWA,WAAaC,cAAe;EAAA;EAAA;EAgC3B;IAAA;IAAA;IAEC,0BAAM;MACLC,WAAW,EAAE,SAAS;MACtBC,OAAO,EAAEJ,qBAAqB,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC,GAC3CA,SAAS,CAAC,CAAC,CAAC,GAAGP,yBAAyB,CAACO,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,GAAGA,SAAS,CAAC,CAAC,CAAC,EAAEA,SAAS,CAAC,CAAC,CAAC,CAAC;MAClGC,SAAS,EAAE,CAAC;MACZC,cAAc,EAAEP,qBAAqB,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC,GAClD,GAAG,GAAGA,SAAS,CAAC,CAAC,CAAC,CAACG,UAAU,GAAG,GAAG,GAAGH,SAAS,CAAC,CAAC;KAClD;IAvCO,UAAI,GAAW,gBAAgB;IAOxC;;;IAGQ,kBAAY,GAAY,CAAC;IAOxB,eAAS,GAAY,IAAI;IAwBjC,MAAKI,SAAS,GAAGT,qBAAqB,CAACK,SAAS,CAAC,CAAC,CAAC,CAAC,GACnDA,SAAS,CAAC,CAAC,CAAC,CAACK,MAAM,GAAGL,SAAS,CAAC,CAAC,CAAC,CAACG,UAAU,GAAGH,SAAS,CAAC,CAAC,CAAC;IAAC;EAC/D;EAEA;;;EAAA;IAAA;IAAA,OAGA,eAAG;MACF,OAAO,IAAI,CAACM,YAAY;IACzB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAe;MACd,OAAO,IAAI,CAACA,YAAY;IACzB;IAEA;;;EAAA;IAAA;IAAA,OAGc,sBAAaC,YAAqB;;;;;;cAC3CC,KAAK,GAAG,CAAC;YAAA;cAAA,MACN,IAAI,CAACJ,SAAS,GAAG,IAAI,CAACE,YAAY,IAAI,CAAC;gBAAA;gBAAA;cAAA;cAE7C;cACA,IAAI,CAACG,IAAI,CAAC,MAAM,CAAC;cAEjB;cACA,IAAI,CAACH,YAAY,IAAI,GAAG,GAAG,IAAI,CAACH,UAAU;cAE1C;cACAK,KAAK,EAAE;cACDE,UAAU,GAAGC,IAAI,CAACC,KAAK,CAAC,IAAI,CAACT,UAAU,GAAG,GAAG,CAAC;cAAA,MAChDI,YAAY,IAAIC,KAAK,GAAGE,UAAU,KAAK,CAAC;gBAAA;gBAAA;cAAA;cAAA;cAC3C,OAAM,IAAIG,OAAO,CAAC,cAAI;gBAAA,OAAIC,UAAU,CAACC,IAAI,EAAE,CAAC,CAAC;cAAA,EAAC;YAAA;cAAA;cAAA;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAGhD;;IAED;;;;EAAA;IAAA;IAAA,OAIM,kBAA0B;MAAA,IAAnBR,YAAY,uEAAG,IAAI;;;;;;;cAC/B,OAAM,IAAI,CAACS,gBAAgB,EAAE;YAAA;cAAA;cAC7B,OAAM,IAAI,CAACC,YAAY,CAACV,YAAY,CAAC;YAAA;cAAA;cACtB,OAAM,IAAI,CAACW,QAAQ,CAACC,cAAc,EAAE;YAAA;cAA7CC,MAAM;cAAA,kCACL,IAAIxB,eAAe,CAACwB,MAAM,CAAC;YAAA;YAAA;cAAA;UAAA;QAAA;MAAA,CAClC;;IAED;;;EAAA;IAAA;IAAA,OAGA,iBAAK;MACJ,OAAOP,OAAO,CAACQ,OAAO,EAAE;IACzB;EAAC;EAAA;AAAA,EAnGkC3B,OAAO","names":["createOfflineAudioContext","Context","isOfflineAudioContext","ToneAudioBuffer","OfflineContext","clockSource","context","arguments","lookAhead","updateInterval","sampleRate","_duration","length","_currentTime","asynchronous","index","emit","yieldEvery","Math","floor","Promise","setTimeout","done","workletsAreReady","_renderClock","_context","startRendering","buffer","resolve"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\context\\OfflineContext.ts"],"sourcesContent":["import { createOfflineAudioContext } from \"../context/AudioContext\";\nimport { Context } from \"../context/Context\";\nimport { Seconds } from \"../type/Units\";\nimport { isOfflineAudioContext } from \"../util/AdvancedTypeCheck\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Wrapper around the OfflineAudioContext\n * @category Core\n * @example\n * // generate a single channel, 0.5 second buffer\n * const context = new Tone.OfflineContext(1, 0.5, 44100);\n * const osc = new Tone.Oscillator({ context });\n * context.render().then(buffer => {\n * \tconsole.log(buffer.numberOfChannels, buffer.duration);\n * });\n */\nexport class OfflineContext extends Context {\n\n\treadonly name: string = \"OfflineContext\";\n\n\t/**\n\t * A private reference to the duration\n\t */\n\tprivate readonly _duration: Seconds;\n\n\t/**\n\t * An artificial clock source\n\t */\n\tprivate _currentTime: Seconds = 0;\n\n\t/**\n\t * Private reference to the OfflineAudioContext.\n\t */\n\tprotected _context!: OfflineAudioContext;\n\n\treadonly isOffline: boolean = true;\n\n\t/**\n\t * @param  channels  The number of channels to render\n\t * @param  duration  The duration to render in seconds\n\t * @param sampleRate the sample rate to render at\n\t */\n\tconstructor(\n\t\tchannels: number,\n\t\tduration: Seconds, \n\t\tsampleRate: number,\n\t);\n\tconstructor(context: OfflineAudioContext);\n\tconstructor() {\n\n\t\tsuper({\n\t\t\tclockSource: \"offline\",\n\t\t\tcontext: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\targuments[0] : createOfflineAudioContext(arguments[0], arguments[1] * arguments[2], arguments[2]),\n\t\t\tlookAhead: 0,\n\t\t\tupdateInterval: isOfflineAudioContext(arguments[0]) ?\n\t\t\t\t128 / arguments[0].sampleRate : 128 / arguments[2],\n\t\t});\n\n\t\tthis._duration = isOfflineAudioContext(arguments[0]) ?\n\t\t\targuments[0].length / arguments[0].sampleRate : arguments[1];\n\t}\n\n\t/**\n\t * Override the now method to point to the internal clock time\n\t */\n\tnow(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Same as this.now()\n\t */\n\tget currentTime(): Seconds {\n\t\treturn this._currentTime;\n\t}\n\n\t/**\n\t * Render just the clock portion of the audio context.\n\t */\n\tprivate async _renderClock(asynchronous: boolean): Promise<void> {\n\t\tlet index = 0;\n\t\twhile (this._duration - this._currentTime >= 0) {\n\n\t\t\t// invoke all the callbacks on that time\n\t\t\tthis.emit(\"tick\");\n\n\t\t\t// increment the clock in block-sized chunks\n\t\t\tthis._currentTime += 128 / this.sampleRate;\n\n\t\t\t// yield once a second of audio\n\t\t\tindex++;\n\t\t\tconst yieldEvery = Math.floor(this.sampleRate / 128);\n\t\t\tif (asynchronous && index % yieldEvery === 0) {\n\t\t\t\tawait new Promise(done => setTimeout(done, 1));\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Render the output of the OfflineContext\n\t * @param asynchronous If the clock should be rendered asynchronously, which will not block the main thread, but be slightly slower.\n\t */\n\tasync render(asynchronous = true): Promise<ToneAudioBuffer> {\n\t\tawait this.workletsAreReady();\n\t\tawait this._renderClock(asynchronous);\n\t\tconst buffer = await this._context.startRendering();\n\t\treturn new ToneAudioBuffer(buffer);\n\t}\n\n\t/**\n\t * Close the context\n\t */\n\tclose(): Promise<void> {\n\t\treturn Promise.resolve();\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
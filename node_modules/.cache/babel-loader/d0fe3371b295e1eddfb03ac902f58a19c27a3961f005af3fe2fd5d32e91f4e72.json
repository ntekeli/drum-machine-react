{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport var Clock = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Clock, _ToneWithContext);\n  var _super = _createSuper(Clock);\n  function Clock() {\n    var _this;\n    _classCallCheck(this, Clock);\n    _this = _super.call(this, optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n    _this.name = \"Clock\";\n    /**\n     * The callback function to invoke at the scheduled tick.\n     */\n    _this.callback = noOp;\n    /**\n     * The last time the loop callback was invoked\n     */\n    _this._lastUpdate = 0;\n    /**\n     * Keep track of the playback state\n     */\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * Context bound reference to the _loop method\n     * This is necessary to remove the event in the end.\n     */\n    _this._boundLoop = _this._loop.bind(_assertThisInitialized(_this));\n    var options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n    _this.callback = options.callback;\n    _this._tickSource = new TickSource({\n      context: _this.context,\n      frequency: options.frequency,\n      units: options.units\n    });\n    _this._lastUpdate = 0;\n    _this.frequency = _this._tickSource.frequency;\n    readOnly(_assertThisInitialized(_this), \"frequency\");\n    // add an initial state\n    _this._state.setStateAtTime(\"stopped\", 0);\n    // bind a callback to the worker thread\n    _this.context.on(\"tick\", _this._boundLoop);\n    return _this;\n  }\n  _createClass(Clock, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this._state.getValueAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset  Where the tick counter starts counting from.\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      // make sure the context is running\n      assertContextRunning(this.context);\n      // start the loop\n      var computedTime = this.toSeconds(time);\n      this.log(\"start\", computedTime);\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n        this._tickSource.start(computedTime, offset);\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"start\", computedTime, offset);\n        }\n      }\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     * @example\n     * const clock = new Tone.Clock(time => {\n     * \tconsole.log(time);\n     * }, 1);\n     * clock.start();\n     * // stop the clock after 10 seconds\n     * clock.stop(\"+10\");\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time);\n      this.log(\"stop\", computedTime);\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"stopped\", computedTime);\n      this._tickSource.stop(computedTime);\n      if (computedTime < this._lastUpdate) {\n        this.emit(\"stop\", computedTime);\n      }\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n        this._tickSource.pause(computedTime);\n        if (computedTime < this._lastUpdate) {\n          this.emit(\"pause\", computedTime);\n        }\n      }\n      return this;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked.\n     */\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return Math.ceil(this.getTicksAtTime(this.now()));\n    },\n    set: function set(t) {\n      this._tickSource.ticks = t;\n    }\n    /**\n     * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n     */\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._tickSource.seconds;\n    },\n    set: function set(s) {\n      this._tickSource.seconds = s;\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      return this._tickSource.getSecondsAtTime(time);\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      this._tickSource.setTicksAtTime(ticks, time);\n      return this;\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n      return this._tickSource.getTimeOfTick(tick, before);\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return this._tickSource.getTicksAtTime(time);\n    }\n    /**\n     * Get the time of the next tick\n     * @param  offset The tick number.\n     */\n  }, {\n    key: \"nextTickTime\",\n    value: function nextTickTime(offset, when) {\n      var computedTime = this.toSeconds(when);\n      var currentTick = this.getTicksAtTime(computedTime);\n      return this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n    }\n    /**\n     * The scheduling loop.\n     */\n  }, {\n    key: \"_loop\",\n    value: function _loop() {\n      var _this2 = this;\n      var startTime = this._lastUpdate;\n      var endTime = this.now();\n      this._lastUpdate = endTime;\n      this.log(\"loop\", startTime, endTime);\n      if (startTime !== endTime) {\n        // the state change events\n        this._state.forEachBetween(startTime, endTime, function (e) {\n          switch (e.state) {\n            case \"started\":\n              var offset = _this2._tickSource.getTicksAtTime(e.time);\n              _this2.emit(\"start\", e.time, offset);\n              break;\n            case \"stopped\":\n              if (e.time !== 0) {\n                _this2.emit(\"stop\", e.time);\n              }\n              break;\n            case \"paused\":\n              _this2.emit(\"pause\", e.time);\n              break;\n          }\n        });\n        // the tick callbacks\n        this._tickSource.forEachTickBetween(startTime, endTime, function (time, ticks) {\n          _this2.callback(time, ticks);\n        });\n      }\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     * @return  The name of the state input in setStateAtTime.\n     * @example\n     * const clock = new Tone.Clock();\n     * clock.start(\"+0.1\");\n     * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n     */\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      var computedTime = this.toSeconds(time);\n      return this._state.getValueAtTime(computedTime);\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Clock.prototype), \"dispose\", this).call(this);\n      this.context.off(\"tick\", this._boundLoop);\n      this._tickSource.dispose();\n      this._state.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        callback: noOp,\n        frequency: 1,\n        units: \"hertz\"\n      });\n    }\n  }]);\n  return Clock;\n}(ToneWithContext);\nEmitter.mixin(Clock);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","Emitter","noOp","readOnly","StateTimeline","TickSource","assertContextRunning","Clock","getDefaults","arguments","_loop","bind","options","callback","_tickSource","context","frequency","units","_lastUpdate","_state","setStateAtTime","on","_boundLoop","getValueAtTime","now","time","offset","computedTime","toSeconds","log","start","emit","cancel","stop","pause","Math","ceil","getTicksAtTime","t","ticks","seconds","s","getSecondsAtTime","setTicksAtTime","tick","before","getTimeOfTick","when","currentTick","startTime","endTime","forEachBetween","e","state","forEachTickBetween","off","dispose","Object","assign","mixin"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\Clock.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Frequency, Hertz, Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { noOp, readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline } from \"../util/StateTimeline\";\nimport { TickSignal } from \"./TickSignal\";\nimport { TickSource } from \"./TickSource\";\nimport { assertContextRunning } from \"../util/Debug\";\n\ntype ClockCallback = (time: Seconds, ticks?: Ticks) => void;\n\ninterface ClockOptions extends ToneWithContextOptions {\n\tfrequency: Hertz;\n\tcallback: ClockCallback;\n\tunits: \"hertz\" | \"bpm\";\n}\n\ntype ClockEvent = \"start\" | \"stop\" | \"pause\";\n\n/**\n * A sample accurate clock which provides a callback at the given rate.\n * While the callback is not sample-accurate (it is still susceptible to\n * loose JS timing), the time passed in as the argument to the callback\n * is precise. For most applications, it is better to use Tone.Transport\n * instead of the Clock by itself since you can synchronize multiple callbacks.\n * @example\n * // the callback will be invoked approximately once a second\n * // and will print the time exactly once a second apart.\n * const clock = new Tone.Clock(time => {\n * \tconsole.log(time);\n * }, 1);\n * clock.start();\n * @category Core\n */\nexport class Clock<TypeName extends \"bpm\" | \"hertz\" = \"hertz\">\n\textends ToneWithContext<ClockOptions> implements Emitter<ClockEvent> {\n\n\treadonly name: string = \"Clock\";\n\n\t/**\n\t * The callback function to invoke at the scheduled tick.\n\t */\n\tcallback: ClockCallback = noOp;\n\n\t/**\n\t * The tick counter\n\t */\n\tprivate _tickSource: TickSource<TypeName>;\n\n\t/**\n\t * The last time the loop callback was invoked\n\t */\n\tprivate _lastUpdate = 0;\n\n\t/**\n\t * Keep track of the playback state\n\t */\n\tprivate _state: StateTimeline = new StateTimeline(\"stopped\");\n\n\t/**\n\t * Context bound reference to the _loop method\n\t * This is necessary to remove the event in the end.\n\t */\n\tprivate _boundLoop: () => void = this._loop.bind(this);\n\n\t/**\n\t * The rate the callback function should be invoked.\n\t */\n\tfrequency: TickSignal<TypeName>;\n\n\t/**\n\t * @param callback The callback to be invoked with the time of the audio event\n\t * @param frequency The rate of the callback\n\t */\n\tconstructor(callback?: ClockCallback, frequency?: Frequency);\n\tconstructor(options: Partial<ClockOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]));\n\t\tconst options = optionsFromArguments(Clock.getDefaults(), arguments, [\"callback\", \"frequency\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._tickSource = new TickSource({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tunits: options.units,\n\t\t});\n\t\tthis._lastUpdate = 0;\n\t\tthis.frequency = this._tickSource.frequency;\n\t\treadOnly(this, \"frequency\");\n\n\t\t// add an initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\n\t\t// bind a callback to the worker thread\n\t\tthis.context.on(\"tick\", this._boundLoop);\n\t}\n\n\tstatic getDefaults(): ClockOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tcallback: noOp as ClockCallback,\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\",\n\t\t}) as ClockOptions;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._state.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset  Where the tick counter starts counting from.\n\t */\n\tstart(time?: Time, offset?: Ticks): this {\n\t\t// make sure the context is running\n\t\tassertContextRunning(this.context);\n\t\t// start the loop\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"start\", computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis._tickSource.start(computedTime, offset);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"start\", computedTime, offset);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t * @example\n\t * const clock = new Tone.Clock(time => {\n\t * \tconsole.log(time);\n\t * }, 1);\n\t * clock.start();\n\t * // stop the clock after 10 seconds\n\t * clock.stop(\"+10\");\n\t */\n\tstop(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"stop\", computedTime);\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis._tickSource.stop(computedTime);\n\t\tif (computedTime < this._lastUpdate) {\n\t\t\tthis.emit(\"stop\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t\tthis._tickSource.pause(computedTime);\n\t\t\tif (computedTime < this._lastUpdate) {\n\t\t\t\tthis.emit(\"pause\", computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked.\n\t */\n\tget ticks(): Ticks {\n\t\treturn Math.ceil(this.getTicksAtTime(this.now()));\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis._tickSource.ticks = t;\n\t}\n\n\t/**\n\t * The time since ticks=0 that the Clock has been running. Accounts for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._tickSource.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tthis._tickSource.seconds = s;\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._tickSource.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\tthis._tickSource.setTicksAtTime(ticks, time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\treturn this._tickSource.getTimeOfTick(tick, before);\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn this._tickSource.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the next tick\n\t * @param  offset The tick number.\n\t */\n\tnextTickTime(offset: Ticks, when: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst currentTick = this.getTicksAtTime(computedTime);\n\t\treturn this._tickSource.getTimeOfTick(currentTick + offset, computedTime);\n\t}\n\n\t/**\n\t * The scheduling loop.\n\t */\n\tprivate _loop(): void {\n\n\t\tconst startTime = this._lastUpdate;\n\t\tconst endTime = this.now();\n\t\tthis._lastUpdate = endTime;\n\t\tthis.log(\"loop\", startTime, endTime);\n\n\t\tif (startTime !== endTime) {\n\t\t\t// the state change events\n\t\t\tthis._state.forEachBetween(startTime, endTime, e => {\n\t\t\t\tswitch (e.state) {\n\t\t\t\t\tcase \"started\":\n\t\t\t\t\t\tconst offset = this._tickSource.getTicksAtTime(e.time);\n\t\t\t\t\t\tthis.emit(\"start\", e.time, offset);\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"stopped\":\n\t\t\t\t\t\tif (e.time !== 0) {\n\t\t\t\t\t\t\tthis.emit(\"stop\", e.time);\n\t\t\t\t\t\t}\n\t\t\t\t\t\tbreak;\n\t\t\t\t\tcase \"paused\":\n\t\t\t\t\t\tthis.emit(\"pause\", e.time);\n\t\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t});\n\t\t\t// the tick callbacks\n\t\t\tthis._tickSource.forEachTickBetween(startTime, endTime, (time, ticks) => {\n\t\t\t\tthis.callback(time, ticks);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t * @example\n\t * const clock = new Tone.Clock();\n\t * clock.start(\"+0.1\");\n\t * clock.getStateAtTime(\"+0.1\"); // returns \"started\"\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\tconst computedTime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(computedTime);\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.off(\"tick\", this._boundLoop);\n\t\tthis._tickSource.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\tonce!: (event: ClockEvent, callback: (...args: any[]) => void) => this;\n\toff!: (event: ClockEvent, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Clock);\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
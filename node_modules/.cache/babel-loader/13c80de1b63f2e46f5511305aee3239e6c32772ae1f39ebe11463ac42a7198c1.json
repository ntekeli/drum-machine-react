{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Signal } from \"./Signal\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport var SyncedSignal = /*#__PURE__*/function (_Signal) {\n  _inherits(SyncedSignal, _Signal);\n  var _super = _createSuper(SyncedSignal);\n  function SyncedSignal() {\n    var _this;\n    _classCallCheck(this, SyncedSignal);\n    _this = _super.call(this, optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n    _this.name = \"SyncedSignal\";\n    /**\n     * Don't override when something is connected to the input\n     */\n    _this.override = false;\n    var options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]);\n    _this._lastVal = options.value;\n    _this._synced = _this.context.transport.scheduleRepeat(_this._onTick.bind(_assertThisInitialized(_this)), \"1i\");\n    _this._syncedCallback = _this._anchorValue.bind(_assertThisInitialized(_this));\n    _this.context.transport.on(\"start\", _this._syncedCallback);\n    _this.context.transport.on(\"pause\", _this._syncedCallback);\n    _this.context.transport.on(\"stop\", _this._syncedCallback);\n    // disconnect the constant source from the output and replace it with another one\n    _this._constantSource.disconnect();\n    _this._constantSource.stop(0);\n    // create a new one\n    _this._constantSource = _this.output = new ToneConstantSource({\n      context: _this.context,\n      offset: options.value,\n      units: options.units\n    }).start(0);\n    _this.setValueAtTime(options.value, 0);\n    return _this;\n  }\n  /**\n   * Callback which is invoked every tick.\n   */\n  _createClass(SyncedSignal, [{\n    key: \"_onTick\",\n    value: function _onTick(time) {\n      var val = _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, this.context.transport.seconds);\n      // approximate ramp curves with linear ramps\n      if (this._lastVal !== val) {\n        this._lastVal = val;\n        this._constantSource.offset.setValueAtTime(val, time);\n      }\n    }\n    /**\n     * Anchor the value at the start and stop of the Transport\n     */\n  }, {\n    key: \"_anchorValue\",\n    value: function _anchorValue(time) {\n      var val = _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, this.context.transport.seconds);\n      this._lastVal = val;\n      this._constantSource.offset.cancelAndHoldAtTime(time);\n      this._constantSource.offset.setValueAtTime(val, time);\n    }\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      return _get(_getPrototypeOf(SyncedSignal.prototype), \"getValueAtTime\", this).call(this, computedTime);\n    }\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setValueAtTime\", this).call(this, value, computedTime);\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"linearRampToValueAtTime\", this).call(this, value, computedTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"exponentialRampToValueAtTime\", this).call(this, value, computedTime);\n      return this;\n    }\n  }, {\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, startTime, timeConstant) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setTargetAtTime\", this).call(this, value, computedTime, timeConstant);\n      return this;\n    }\n  }, {\n    key: \"cancelScheduledValues\",\n    value: function cancelScheduledValues(startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"cancelScheduledValues\", this).call(this, computedTime);\n      return this;\n    }\n  }, {\n    key: \"setValueCurveAtTime\",\n    value: function setValueCurveAtTime(values, startTime, duration, scaling) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      duration = this.toSeconds(duration);\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setValueCurveAtTime\", this).call(this, values, computedTime, duration, scaling);\n      return this;\n    }\n  }, {\n    key: \"cancelAndHoldAtTime\",\n    value: function cancelAndHoldAtTime(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"cancelAndHoldAtTime\", this).call(this, computedTime);\n      return this;\n    }\n  }, {\n    key: \"setRampPoint\",\n    value: function setRampPoint(time) {\n      var computedTime = new TransportTimeClass(this.context, time).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"setRampPoint\", this).call(this, computedTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampTo\",\n    value: function exponentialRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"exponentialRampTo\", this).call(this, value, rampTime, computedTime);\n      return this;\n    }\n  }, {\n    key: \"linearRampTo\",\n    value: function linearRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"linearRampTo\", this).call(this, value, rampTime, computedTime);\n      return this;\n    }\n  }, {\n    key: \"targetRampTo\",\n    value: function targetRampTo(value, rampTime, startTime) {\n      var computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"targetRampTo\", this).call(this, value, rampTime, computedTime);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(SyncedSignal.prototype), \"dispose\", this).call(this);\n      this.context.transport.clear(this._synced);\n      this.context.transport.off(\"start\", this._syncedCallback);\n      this.context.transport.off(\"pause\", this._syncedCallback);\n      this.context.transport.off(\"stop\", this._syncedCallback);\n      this._constantSource.dispose();\n      return this;\n    }\n  }]);\n  return SyncedSignal;\n}(Signal);","map":{"version":3,"mappings":"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","names":["Signal","optionsFromArguments","TransportTimeClass","ToneConstantSource","SyncedSignal","getDefaults","arguments","options","_lastVal","value","_synced","context","transport","scheduleRepeat","_onTick","bind","_syncedCallback","_anchorValue","on","_constantSource","disconnect","stop","output","offset","units","start","setValueAtTime","time","val","seconds","cancelAndHoldAtTime","computedTime","toSeconds","startTime","timeConstant","values","duration","scaling","rampTime","clear","off","dispose"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\signal\\SyncedSignal.ts"],"sourcesContent":["import { Signal, SignalOptions } from \"./Signal\";\nimport { NormalRange, Seconds, Time, TransportTime, UnitMap, UnitName } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { ToneConstantSource } from \"./ToneConstantSource\";\nimport { OutputNode } from \"../core/context/ToneAudioNode\";\n\n/**\n * Adds the ability to synchronize the signal to the [[Transport]]\n */\nexport class SyncedSignal<TypeName extends UnitName = \"number\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"SyncedSignal\";\n\t\n\t/**\n\t * Don't override when something is connected to the input\n\t */\n\treadonly override = false;\n\n\treadonly output: OutputNode;\n\n\t/**\n\t * Keep track of the last value as an optimization.\n\t */\n\tprivate _lastVal: UnitMap[TypeName];\n\n\t/**\n\t * The ID returned from scheduleRepeat\n\t */\n\tprivate _synced: number;\n\n\t/**\n\t * Remember the callback value\n\t */\n\tprivate _syncedCallback: () => void;\n\n\t/**\n\t * @param value Initial value of the signal\n\t * @param units The unit name, e.g. \"frequency\"\n\t */\n\tconstructor(value?: UnitMap[TypeName], units?: TypeName);\n\tconstructor(options?: Partial<SignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]));\n\t\tconst options = optionsFromArguments(Signal.getDefaults(), arguments, [\"value\", \"units\"]) as SignalOptions<TypeName>;\n\n\t\tthis._lastVal = options.value;\n\t\tthis._synced = this.context.transport.scheduleRepeat(this._onTick.bind(this), \"1i\");\n\n\t\tthis._syncedCallback = this._anchorValue.bind(this);\n\t\tthis.context.transport.on(\"start\", this._syncedCallback);\n\t\tthis.context.transport.on(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.on(\"stop\", this._syncedCallback);\n\n\t\t// disconnect the constant source from the output and replace it with another one\n\t\tthis._constantSource.disconnect();\n\t\tthis._constantSource.stop(0);\n\n\t\t// create a new one\n\t\tthis._constantSource = this.output = new ToneConstantSource<TypeName>({ \n\t\t\tcontext: this.context,\n\t\t\toffset: options.value,\n\t\t\tunits: options.units,\n\t\t}).start(0);\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\t/**\n\t * Callback which is invoked every tick.\n\t */\n\tprivate _onTick(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\t// approximate ramp curves with linear ramps\n\t\tif (this._lastVal !== val) {\n\t\t\tthis._lastVal = val;\n\t\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t\t}\n\t}\n\n\t/**\n\t * Anchor the value at the start and stop of the Transport\n\t */\n\tprivate _anchorValue(time: Seconds): void {\n\t\tconst val = super.getValueAtTime(this.context.transport.seconds);\n\t\tthis._lastVal = val;\n\t\tthis._constantSource.offset.cancelAndHoldAtTime(time);\n\t\tthis._constantSource.offset.setValueAtTime(val, time);\n\t}\n\n\tgetValueAtTime(time: TransportTime): UnitMap[TypeName] {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\treturn super.getValueAtTime(computedTime);\n\t}\n\t\n\tsetValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.linearRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: TransportTime) {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.exponentialRampToValueAtTime(value, computedTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value, startTime: TransportTime, timeConstant: number): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.setTargetAtTime(value, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(startTime: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.cancelScheduledValues(computedTime);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: TransportTime, duration: Time, scaling: NormalRange): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tduration = this.toSeconds(duration);\n\t\tsuper.setValueCurveAtTime(values, computedTime, duration, scaling);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.cancelAndHoldAtTime(computedTime);\n\t\treturn this;\n\t}\n\t\n\tsetRampPoint(time: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, time).toSeconds();\n\t\tsuper.setRampPoint(computedTime);\n\t\treturn this;\n\t}\n\t\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.exponentialRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\t\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.linearRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: TransportTime): this {\n\t\tconst computedTime = new TransportTimeClass(this.context, startTime).toSeconds();\n\t\tsuper.targetRampTo(value, rampTime, computedTime);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.context.transport.clear(this._synced);\n\t\tthis.context.transport.off(\"start\", this._syncedCallback);\n\t\tthis.context.transport.off(\"pause\", this._syncedCallback);\n\t\tthis.context.transport.off(\"stop\", this._syncedCallback);\n\t\tthis._constantSource.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
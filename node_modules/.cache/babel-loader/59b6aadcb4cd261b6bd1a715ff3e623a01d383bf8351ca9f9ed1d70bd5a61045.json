{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nvar _marked = /*#__PURE__*/_regeneratorRuntime().mark(upPatternGen),\n  _marked2 = /*#__PURE__*/_regeneratorRuntime().mark(downPatternGen),\n  _marked3 = /*#__PURE__*/_regeneratorRuntime().mark(infiniteGen),\n  _marked4 = /*#__PURE__*/_regeneratorRuntime().mark(alternatingGenerator),\n  _marked5 = /*#__PURE__*/_regeneratorRuntime().mark(jumpUp),\n  _marked6 = /*#__PURE__*/_regeneratorRuntime().mark(jumpDown),\n  _marked7 = /*#__PURE__*/_regeneratorRuntime().mark(randomGen),\n  _marked8 = /*#__PURE__*/_regeneratorRuntime().mark(randomOnce),\n  _marked9 = /*#__PURE__*/_regeneratorRuntime().mark(randomWalk);\nimport { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n/**\n * Start at the first value and go up to the last\n */\nfunction upPatternGen(values) {\n  var index;\n  return _regeneratorRuntime().wrap(function upPatternGen$(_context) {\n    while (1) switch (_context.prev = _context.next) {\n      case 0:\n        index = 0;\n      case 1:\n        if (!(index < values.length)) {\n          _context.next = 8;\n          break;\n        }\n        index = clampToArraySize(index, values);\n        _context.next = 5;\n        return values[index];\n      case 5:\n        index++;\n        _context.next = 1;\n        break;\n      case 8:\n      case \"end\":\n        return _context.stop();\n    }\n  }, _marked);\n}\n/**\n * Start at the last value and go down to 0\n */\nfunction downPatternGen(values) {\n  var index;\n  return _regeneratorRuntime().wrap(function downPatternGen$(_context2) {\n    while (1) switch (_context2.prev = _context2.next) {\n      case 0:\n        index = values.length - 1;\n      case 1:\n        if (!(index >= 0)) {\n          _context2.next = 8;\n          break;\n        }\n        index = clampToArraySize(index, values);\n        _context2.next = 5;\n        return values[index];\n      case 5:\n        index--;\n        _context2.next = 1;\n        break;\n      case 8:\n      case \"end\":\n        return _context2.stop();\n    }\n  }, _marked2);\n}\n/**\n * Infinitely yield the generator\n */\nfunction infiniteGen(values, gen) {\n  return _regeneratorRuntime().wrap(function infiniteGen$(_context3) {\n    while (1) switch (_context3.prev = _context3.next) {\n      case 0:\n        if (!true) {\n          _context3.next = 4;\n          break;\n        }\n        return _context3.delegateYield(gen(values), \"t0\", 2);\n      case 2:\n        _context3.next = 0;\n        break;\n      case 4:\n      case \"end\":\n        return _context3.stop();\n    }\n  }, _marked3);\n}\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index, values) {\n  return clamp(index, 0, values.length - 1);\n}\n/**\n * Alternate between two generators\n */\nfunction alternatingGenerator(values, directionUp) {\n  var index;\n  return _regeneratorRuntime().wrap(function alternatingGenerator$(_context4) {\n    while (1) switch (_context4.prev = _context4.next) {\n      case 0:\n        index = directionUp ? 0 : values.length - 1;\n      case 1:\n        if (!true) {\n          _context4.next = 8;\n          break;\n        }\n        index = clampToArraySize(index, values);\n        _context4.next = 5;\n        return values[index];\n      case 5:\n        if (directionUp) {\n          index++;\n          if (index >= values.length - 1) {\n            directionUp = false;\n          }\n        } else {\n          index--;\n          if (index <= 0) {\n            directionUp = true;\n          }\n        }\n        _context4.next = 1;\n        break;\n      case 8:\n      case \"end\":\n        return _context4.stop();\n    }\n  }, _marked4);\n}\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction jumpUp(values) {\n  var index, stepIndex;\n  return _regeneratorRuntime().wrap(function jumpUp$(_context5) {\n    while (1) switch (_context5.prev = _context5.next) {\n      case 0:\n        index = 0;\n        stepIndex = 0;\n      case 2:\n        if (!(index < values.length)) {\n          _context5.next = 10;\n          break;\n        }\n        index = clampToArraySize(index, values);\n        _context5.next = 6;\n        return values[index];\n      case 6:\n        stepIndex++;\n        index += stepIndex % 2 ? 2 : -1;\n        _context5.next = 2;\n        break;\n      case 10:\n      case \"end\":\n        return _context5.stop();\n    }\n  }, _marked5);\n}\n/**\n * Starting from the top move down 2, up 1\n */\nfunction jumpDown(values) {\n  var index, stepIndex;\n  return _regeneratorRuntime().wrap(function jumpDown$(_context6) {\n    while (1) switch (_context6.prev = _context6.next) {\n      case 0:\n        index = values.length - 1;\n        stepIndex = 0;\n      case 2:\n        if (!(index >= 0)) {\n          _context6.next = 10;\n          break;\n        }\n        index = clampToArraySize(index, values);\n        _context6.next = 6;\n        return values[index];\n      case 6:\n        stepIndex++;\n        index += stepIndex % 2 ? -2 : 1;\n        _context6.next = 2;\n        break;\n      case 10:\n      case \"end\":\n        return _context6.stop();\n    }\n  }, _marked6);\n}\n/**\n * Choose a random index each time\n */\nfunction randomGen(values) {\n  var randomIndex;\n  return _regeneratorRuntime().wrap(function randomGen$(_context7) {\n    while (1) switch (_context7.prev = _context7.next) {\n      case 0:\n        if (!true) {\n          _context7.next = 6;\n          break;\n        }\n        randomIndex = Math.floor(Math.random() * values.length);\n        _context7.next = 4;\n        return values[randomIndex];\n      case 4:\n        _context7.next = 0;\n        break;\n      case 6:\n      case \"end\":\n        return _context7.stop();\n    }\n  }, _marked7);\n}\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction randomOnce(values) {\n  var copy, i, randVal, index;\n  return _regeneratorRuntime().wrap(function randomOnce$(_context8) {\n    while (1) switch (_context8.prev = _context8.next) {\n      case 0:\n        // create an array of indices\n        copy = [];\n        for (i = 0; i < values.length; i++) {\n          copy.push(i);\n        }\n      case 2:\n        if (!(copy.length > 0)) {\n          _context8.next = 9;\n          break;\n        }\n        // random choose an index, and then remove it so it's not chosen again\n        randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n        index = clampToArraySize(randVal[0], values);\n        _context8.next = 7;\n        return values[index];\n      case 7:\n        _context8.next = 2;\n        break;\n      case 9:\n      case \"end\":\n        return _context8.stop();\n    }\n  }, _marked8);\n}\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction randomWalk(values) {\n  var index;\n  return _regeneratorRuntime().wrap(function randomWalk$(_context9) {\n    while (1) switch (_context9.prev = _context9.next) {\n      case 0:\n        // randomly choose a starting index in the values array\n        index = Math.floor(Math.random() * values.length);\n      case 1:\n        if (!true) {\n          _context9.next = 7;\n          break;\n        }\n        if (index === 0) {\n          index++; // at bottom of array, so force upward step\n        } else if (index === values.length - 1) {\n          index--; // at top of array, so force downward step\n        } else if (Math.random() < 0.5) {\n          // else choose random downward or upward step\n          index--;\n        } else {\n          index++;\n        }\n        _context9.next = 5;\n        return values[index];\n      case 5:\n        _context9.next = 1;\n        break;\n      case 7:\n      case \"end\":\n        return _context9.stop();\n    }\n  }, _marked9);\n}\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function PatternGenerator(values) {\n  var pattern = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"up\";\n  var index = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n  return /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    return _regeneratorRuntime().wrap(function _callee$(_context10) {\n      while (1) switch (_context10.prev = _context10.next) {\n        case 0:\n          // safeguards\n          assert(values.length > 0, \"The array must have more than one value in it\");\n          _context10.t0 = pattern;\n          _context10.next = _context10.t0 === \"up\" ? 4 : _context10.t0 === \"down\" ? 5 : _context10.t0 === \"upDown\" ? 6 : _context10.t0 === \"downUp\" ? 7 : _context10.t0 === \"alternateUp\" ? 8 : _context10.t0 === \"alternateDown\" ? 9 : _context10.t0 === \"random\" ? 10 : _context10.t0 === \"randomOnce\" ? 11 : _context10.t0 === \"randomWalk\" ? 12 : 13;\n          break;\n        case 4:\n          return _context10.delegateYield(infiniteGen(values, upPatternGen), \"t1\", 5);\n        case 5:\n          return _context10.delegateYield(infiniteGen(values, downPatternGen), \"t2\", 6);\n        case 6:\n          return _context10.delegateYield(alternatingGenerator(values, true), \"t3\", 7);\n        case 7:\n          return _context10.delegateYield(alternatingGenerator(values, false), \"t4\", 8);\n        case 8:\n          return _context10.delegateYield(infiniteGen(values, jumpUp), \"t5\", 9);\n        case 9:\n          return _context10.delegateYield(infiniteGen(values, jumpDown), \"t6\", 10);\n        case 10:\n          return _context10.delegateYield(randomGen(values), \"t7\", 11);\n        case 11:\n          return _context10.delegateYield(infiniteGen(values, randomOnce), \"t8\", 12);\n        case 12:\n          return _context10.delegateYield(randomWalk(values), \"t9\", 13);\n        case 13:\n        case \"end\":\n          return _context10.stop();\n      }\n    }, _callee);\n  })();\n}","map":{"version":3,"mappings":"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","names":["upPatternGen","downPatternGen","infiniteGen","alternatingGenerator","jumpUp","jumpDown","randomGen","randomOnce","randomWalk","assert","clamp","values","index","length","clampToArraySize","gen","directionUp","stepIndex","randomIndex","Math","floor","random","copy","i","push","randVal","splice","PatternGenerator","pattern"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\event\\PatternGenerator.ts"],"sourcesContent":["import { assert } from \"../core/util/Debug\";\nimport { clamp } from \"../core/util/Math\";\n\n/**\n * The name of the patterns\n */\nexport type PatternName = \"up\" | \"down\" | \"upDown\" | \"downUp\" | \"alternateUp\" | \"alternateDown\" | \"random\" | \"randomOnce\" | \"randomWalk\";\n\n/**\n * Start at the first value and go up to the last\n */\nfunction* upPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex++;\n\t}\n}\n\n/**\n * Start at the last value and go down to 0\n */\nfunction* downPatternGen<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tindex--;\n\t}\n}\n\n/**\n * Infinitely yield the generator\n */\nfunction* infiniteGen<T>(values: T[], gen: typeof upPatternGen): IterableIterator<T> {\n\twhile (true) {\n\t\tyield* gen(values);\n\t}\n}\n\n/**\n * Make sure that the index is in the given range\n */\nfunction clampToArraySize(index: number, values: any[]): number {\n\treturn clamp(index, 0, values.length - 1);\n}\n\n/**\n * Alternate between two generators\n */\nfunction* alternatingGenerator<T>(values: T[], directionUp: boolean): IterableIterator<T> {\n\tlet index = directionUp ? 0 : values.length - 1;\n\twhile (true) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tif (directionUp) {\n\t\t\tindex++;\n\t\t\tif (index >= values.length - 1) {\n\t\t\t\tdirectionUp = false;\n\t\t\t}\n\t\t} else {\n\t\t\tindex--;\n\t\t\tif (index <= 0) {\n\t\t\t\tdirectionUp = true;\n\t\t\t}\n\t\t}\n\t}\n}\n\n/**\n * Starting from the bottom move up 2, down 1\n */\nfunction* jumpUp<T>(values: T[]): IterableIterator<T> {\n\tlet index = 0;\n\tlet stepIndex = 0;\n\twhile (index < values.length) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? 2 : -1);\n\t}\n}\n\n/**\n * Starting from the top move down 2, up 1\n */\nfunction* jumpDown<T>(values: T[]): IterableIterator<T> {\n\tlet index = values.length - 1;\n\tlet stepIndex = 0;\n\twhile (index >= 0) {\n\t\tindex = clampToArraySize(index, values);\n\t\tyield values[index];\n\t\tstepIndex++;\n\t\tindex += (stepIndex % 2 ? -2 : 1);\n\t}\n}\n\n/**\n * Choose a random index each time\n */\nfunction* randomGen<T>(values: T[]): IterableIterator<T> {\n\twhile (true) {\n\t\tconst randomIndex = Math.floor(Math.random() * values.length);\n\t\tyield values[randomIndex];\n\t}\n}\n\n/**\n * Randomly go through all of the values once before choosing a new random order\n */\nfunction* randomOnce<T>(values: T[]): IterableIterator<T> {\n\t// create an array of indices\n\tconst copy: number[] = [];\n\tfor (let i = 0; i < values.length; i++) {\n\t\tcopy.push(i);\n\t}\n\twhile (copy.length > 0) {\n\t\t// random choose an index, and then remove it so it's not chosen again\n\t\tconst randVal = copy.splice(Math.floor(copy.length * Math.random()), 1);\n\t\tconst index = clampToArraySize(randVal[0], values);\n\t\tyield values[index];\n\t}\n}\n\n/**\n * Randomly choose to walk up or down 1 index in the values array\n */\nfunction* randomWalk<T>(values: T[]): IterableIterator<T> {\n\t// randomly choose a starting index in the values array\n\tlet index = Math.floor(Math.random() * values.length);\n\twhile (true) {\n\t\tif (index === 0) {\n\t\t\tindex++; // at bottom of array, so force upward step\n\t\t} else if (index === values.length - 1) {\n\t\t\tindex--; // at top of array, so force downward step\n\t\t} else if (Math.random() < 0.5) { // else choose random downward or upward step\n\t\t\tindex--;\n\t\t} else {\n\t\t\tindex++;\n\t\t}\n\t\tyield values[index];\n\t}\n}\n\n/**\n * PatternGenerator returns a generator which will iterate over the given array\n * of values and yield the items according to the passed in pattern\n * @param values An array of values to iterate over\n * @param pattern The name of the pattern use when iterating over\n * @param index Where to start in the offset of the values array\n */\nexport function* PatternGenerator<T>(values: T[], pattern: PatternName = \"up\", index = 0): Iterator<T> {\n\t// safeguards\n\tassert(values.length > 0, \"The array must have more than one value in it\");\n\tswitch (pattern) {\n\t\tcase \"up\" :\n\t\t\tyield* infiniteGen(values, upPatternGen);\n\t\tcase \"down\" :\n\t\t\tyield* infiniteGen(values, downPatternGen);\n\t\tcase \"upDown\" :\n\t\t\tyield* alternatingGenerator(values, true);\n\t\tcase \"downUp\" :\n\t\t\tyield* alternatingGenerator(values, false);\n\t\tcase \"alternateUp\":\n\t\t\tyield* infiniteGen(values, jumpUp);\n\t\tcase \"alternateDown\":\n\t\t\tyield* infiniteGen(values, jumpDown);\n\t\tcase \"random\":\n\t\t\tyield* randomGen(values);\n\t\tcase \"randomOnce\":\n\t\t\tyield* infiniteGen(values, randomOnce);\n\t\tcase \"randomWalk\":\n\t\t\tyield* randomWalk(values);\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
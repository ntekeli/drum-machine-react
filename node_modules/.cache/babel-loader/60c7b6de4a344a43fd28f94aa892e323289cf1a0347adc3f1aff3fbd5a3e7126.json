{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport var Emitter = /*#__PURE__*/function (_Tone) {\n  _inherits(Emitter, _Tone);\n  var _super = _createSuper(Emitter);\n  function Emitter() {\n    var _this;\n    _classCallCheck(this, Emitter);\n    _this = _super.apply(this, arguments);\n    _this.name = \"Emitter\";\n    return _this;\n  }\n  /**\n   * Bind a callback to a specific event.\n   * @param  event     The name of the event to listen for.\n   * @param  callback  The callback to invoke when the event is emitted\n   */\n  _createClass(Emitter, [{\n    key: \"on\",\n    value: function on(event, callback) {\n      var _this2 = this;\n      // split the event\n      var events = event.split(/\\W+/);\n      events.forEach(function (eventName) {\n        if (isUndef(_this2._events)) {\n          _this2._events = {};\n        }\n        if (!_this2._events.hasOwnProperty(eventName)) {\n          _this2._events[eventName] = [];\n        }\n        _this2._events[eventName].push(callback);\n      });\n      return this;\n    }\n    /**\n     * Bind a callback which is only invoked once\n     * @param  event     The name of the event to listen for.\n     * @param  callback  The callback to invoke when the event is emitted\n     */\n  }, {\n    key: \"once\",\n    value: function once(event, callback) {\n      var _this3 = this;\n      var boundCallback = function boundCallback() {\n        // invoke the callback\n        callback.apply(void 0, arguments);\n        // remove the event\n        _this3.off(event, boundCallback);\n      };\n      this.on(event, boundCallback);\n      return this;\n    }\n    /**\n     * Remove the event listener.\n     * @param  event     The event to stop listening to.\n     * @param  callback  The callback which was bound to the event with Emitter.on.\n     *                   If no callback is given, all callbacks events are removed.\n     */\n  }, {\n    key: \"off\",\n    value: function off(event, callback) {\n      var _this4 = this;\n      var events = event.split(/\\W+/);\n      events.forEach(function (eventName) {\n        if (isUndef(_this4._events)) {\n          _this4._events = {};\n        }\n        if (_this4._events.hasOwnProperty(event)) {\n          if (isUndef(callback)) {\n            _this4._events[event] = [];\n          } else {\n            var eventList = _this4._events[event];\n            for (var i = eventList.length - 1; i >= 0; i--) {\n              if (eventList[i] === callback) {\n                eventList.splice(i, 1);\n              }\n            }\n          }\n        }\n      });\n      return this;\n    }\n    /**\n     * Invoke all of the callbacks bound to the event\n     * with any arguments passed in.\n     * @param  event  The name of the event.\n     * @param args The arguments to pass to the functions listening.\n     */\n  }, {\n    key: \"emit\",\n    value: function emit(event) {\n      if (this._events) {\n        if (this._events.hasOwnProperty(event)) {\n          var eventList = this._events[event].slice(0);\n          for (var _len = arguments.length, args = new Array(_len > 1 ? _len - 1 : 0), _key = 1; _key < _len; _key++) {\n            args[_key - 1] = arguments[_key];\n          }\n          for (var i = 0, len = eventList.length; i < len; i++) {\n            eventList[i].apply(this, args);\n          }\n        }\n      }\n      return this;\n    }\n    /**\n     * Add Emitter functions (on/off/emit) to the object\n     */\n  }, {\n    key: \"dispose\",\n    value:\n    /**\n     * Clean up\n     */\n    function dispose() {\n      _get(_getPrototypeOf(Emitter.prototype), \"dispose\", this).call(this);\n      this._events = undefined;\n      return this;\n    }\n  }], [{\n    key: \"mixin\",\n    value: function mixin(constr) {\n      // instance._events = {};\n      [\"on\", \"once\", \"off\", \"emit\"].forEach(function (name) {\n        var property = Object.getOwnPropertyDescriptor(Emitter.prototype, name);\n        Object.defineProperty(constr.prototype, name, property);\n      });\n    }\n  }]);\n  return Emitter;\n}(Tone);","map":{"version":3,"mappings":"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","names":["Tone","isUndef","Emitter","event","callback","events","split","forEach","_events","hasOwnProperty","eventName","push","boundCallback","off","on","eventList","i","length","splice","slice","args","len","apply","undefined","constr","property","Object","getOwnPropertyDescriptor","prototype","name","defineProperty"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\util\\Emitter.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { isUndef } from \"./TypeCheck\";\n\nexport interface EmitterEventObject {\n\t[event: string]: Array<(...args: any[]) => void>;\n}\n\n/**\n * Emitter gives classes which extend it\n * the ability to listen for and emit events.\n * Inspiration and reference from Jerome Etienne's [MicroEvent](https://github.com/jeromeetienne/microevent.js).\n * MIT (c) 2011 Jerome Etienne.\n * @category Core\n */\nexport class Emitter<EventType extends string = string> extends Tone {\n\n\treadonly name: string = \"Emitter\";\n\n\t/**\n\t * Private container for the events\n\t */\n\tprivate _events?: EmitterEventObject;\n\n\t/**\n\t * Bind a callback to a specific event.\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\ton(event: EventType, callback: (...args: any[]) => void): this {\n\t\t// split the event\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (!this._events.hasOwnProperty(eventName)) {\n\t\t\t\tthis._events[eventName] = [];\n\t\t\t}\n\t\t\tthis._events[eventName].push(callback);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Bind a callback which is only invoked once\n\t * @param  event     The name of the event to listen for.\n\t * @param  callback  The callback to invoke when the event is emitted\n\t */\n\tonce(event: EventType, callback: (...args: any[]) => void): this {\n\t\tconst boundCallback = (...args: any[]) => {\n\t\t\t// invoke the callback\n\t\t\tcallback(...args);\n\t\t\t// remove the event\n\t\t\tthis.off(event, boundCallback);\n\t\t};\n\t\tthis.on(event, boundCallback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove the event listener.\n\t * @param  event     The event to stop listening to.\n\t * @param  callback  The callback which was bound to the event with Emitter.on.\n\t *                   If no callback is given, all callbacks events are removed.\n\t */\n\toff(event: EventType, callback?: (...args: any[]) => void): this {\n\t\tconst events = event.split(/\\W+/);\n\t\tevents.forEach(eventName => {\n\t\t\tif (isUndef(this._events)) {\n\t\t\t\tthis._events = {};\n\t\t\t}\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tif (isUndef(callback)) {\n\t\t\t\t\tthis._events[event] = [];\n\t\t\t\t} else {\n\t\t\t\t\tconst eventList = this._events[event];\n\t\t\t\t\tfor (let i = eventList.length - 1; i >= 0; i--) {\n\t\t\t\t\t\tif (eventList[i] === callback) {\n\t\t\t\t\t\t\teventList.splice(i, 1);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke all of the callbacks bound to the event\n\t * with any arguments passed in.\n\t * @param  event  The name of the event.\n\t * @param args The arguments to pass to the functions listening.\n\t */\n\temit(event, ...args: any[]): this {\n\t\tif (this._events) {\n\t\t\tif (this._events.hasOwnProperty(event)) {\n\t\t\t\tconst eventList = this._events[event].slice(0);\n\t\t\t\tfor (let i = 0, len = eventList.length; i < len; i++) {\n\t\t\t\t\teventList[i].apply(this, args);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add Emitter functions (on/off/emit) to the object\n\t */\n\tstatic mixin(constr: any): void {\n\t\t// instance._events = {};\n\t\t[\"on\", \"once\", \"off\", \"emit\"].forEach(name => {\n\t\t\tconst property = Object.getOwnPropertyDescriptor(Emitter.prototype, name) as PropertyDescriptor;\n\t\t\tObject.defineProperty(constr.prototype, name, property);\n\t\t});\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events = undefined;\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
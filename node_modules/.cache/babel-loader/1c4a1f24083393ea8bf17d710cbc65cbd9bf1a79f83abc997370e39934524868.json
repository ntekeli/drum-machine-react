{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __decorate } from \"tslib\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { ToneBufferSource } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport var Sampler = /*#__PURE__*/function (_Instrument) {\n  _inherits(Sampler, _Instrument);\n  var _super = _createSuper(Sampler);\n  function Sampler() {\n    var _this;\n    _classCallCheck(this, Sampler);\n    _this = _super.call(this, optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n    _this.name = \"Sampler\";\n    /**\n     * The object of all currently playing BufferSources\n     */\n    _this._activeSources = new Map();\n    var options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n    var urlMap = {};\n    Object.keys(options.urls).forEach(function (note) {\n      var noteNumber = parseInt(note, 10);\n      assert(isNote(note) || isNumber(noteNumber) && isFinite(noteNumber), \"url key is neither a note or midi pitch: \".concat(note));\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        var mid = new FrequencyClass(_this.context, note).toMidi();\n        urlMap[mid] = options.urls[note];\n      } else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n        // otherwise if it's numbers assume it's midi\n        urlMap[noteNumber] = options.urls[noteNumber];\n      }\n    });\n    _this._buffers = new ToneAudioBuffers({\n      urls: urlMap,\n      onload: options.onload,\n      baseUrl: options.baseUrl,\n      onerror: options.onerror\n    });\n    _this.attack = options.attack;\n    _this.release = options.release;\n    _this.curve = options.curve;\n    // invoke the callback if it's already loaded\n    if (_this._buffers.loaded) {\n      // invoke onload deferred\n      Promise.resolve().then(options.onload);\n    }\n    return _this;\n  }\n  _createClass(Sampler, [{\n    key: \"_findClosest\",\n    value:\n    /**\n     * Returns the difference in steps between the given midi note at the closets sample.\n     */\n    function _findClosest(midi) {\n      // searches within 8 octaves of the given midi note\n      var MAX_INTERVAL = 96;\n      var interval = 0;\n      while (interval < MAX_INTERVAL) {\n        // check above and below\n        if (this._buffers.has(midi + interval)) {\n          return -interval;\n        } else if (this._buffers.has(midi - interval)) {\n          return interval;\n        }\n        interval++;\n      }\n      throw new Error(\"No available buffers for note: \".concat(midi));\n    }\n    /**\n     * @param  notes\tThe note to play, or an array of notes.\n     * @param  time     When to play the note\n     * @param  velocity The velocity to play the sample back.\n     */\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(notes, time) {\n      var _this2 = this;\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      this.log(\"triggerAttack\", notes, time, velocity);\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n      notes.forEach(function (note) {\n        var midiFloat = ftomf(new FrequencyClass(_this2.context, note).toFrequency());\n        var midi = Math.round(midiFloat);\n        var remainder = midiFloat - midi;\n        // find the closest note pitch\n        var difference = _this2._findClosest(midi);\n        var closestNote = midi - difference;\n        var buffer = _this2._buffers.get(closestNote);\n        var playbackRate = intervalToFrequencyRatio(difference + remainder);\n        // play that note\n        var source = new ToneBufferSource({\n          url: buffer,\n          context: _this2.context,\n          curve: _this2.curve,\n          fadeIn: _this2.attack,\n          fadeOut: _this2.release,\n          playbackRate: playbackRate\n        }).connect(_this2.output);\n        source.start(time, 0, buffer.duration / playbackRate, velocity);\n        // add it to the active sources\n        if (!isArray(_this2._activeSources.get(midi))) {\n          _this2._activeSources.set(midi, []);\n        }\n        _this2._activeSources.get(midi).push(source);\n        // remove it when it's done\n        source.onended = function () {\n          if (_this2._activeSources && _this2._activeSources.has(midi)) {\n            var sources = _this2._activeSources.get(midi);\n            var index = sources.indexOf(source);\n            if (index !== -1) {\n              sources.splice(index, 1);\n            }\n          }\n        };\n      });\n      return this;\n    }\n    /**\n     * @param  notes\tThe note to release, or an array of notes.\n     * @param  time     \tWhen to release the note.\n     */\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(notes, time) {\n      var _this3 = this;\n      this.log(\"triggerRelease\", notes, time);\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n      notes.forEach(function (note) {\n        var midi = new FrequencyClass(_this3.context, note).toMidi();\n        // find the note\n        if (_this3._activeSources.has(midi) && _this3._activeSources.get(midi).length) {\n          var sources = _this3._activeSources.get(midi);\n          time = _this3.toSeconds(time);\n          sources.forEach(function (source) {\n            source.stop(time);\n          });\n          _this3._activeSources.set(midi, []);\n        }\n      });\n      return this;\n    }\n    /**\n     * Release all currently active notes.\n     * @param  time     \tWhen to release the notes.\n     */\n  }, {\n    key: \"releaseAll\",\n    value: function releaseAll(time) {\n      var computedTime = this.toSeconds(time);\n      this._activeSources.forEach(function (sources) {\n        while (sources.length) {\n          var source = sources.shift();\n          source.stop(computedTime);\n        }\n      });\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n      }\n      return this;\n    }\n    /**\n     * Invoke the attack phase, then after the duration, invoke the release.\n     * @param  notes\tThe note to play and release, or an array of notes.\n     * @param  duration The time the note should be held\n     * @param  time     When to start the attack\n     * @param  velocity The velocity of the attack\n     */\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(notes, duration, time) {\n      var _this4 = this;\n      var velocity = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      var computedTime = this.toSeconds(time);\n      this.triggerAttack(notes, computedTime, velocity);\n      if (isArray(duration)) {\n        assert(isArray(notes), \"notes must be an array when duration is array\");\n        notes.forEach(function (note, index) {\n          var d = duration[Math.min(index, duration.length - 1)];\n          _this4.triggerRelease(note, computedTime + _this4.toSeconds(d));\n        });\n      } else {\n        this.triggerRelease(notes, computedTime + this.toSeconds(duration));\n      }\n      return this;\n    }\n    /**\n     * Add a note to the sampler.\n     * @param  note      The buffer's pitch.\n     * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n     * @param  callback  The callback to invoke when the url is loaded.\n     */\n  }, {\n    key: \"add\",\n    value: function add(note, url, callback) {\n      assert(isNote(note) || isFinite(note), \"note must be a pitch or midi: \".concat(note));\n      if (isNote(note)) {\n        // convert the note name to MIDI\n        var mid = new FrequencyClass(this.context, note).toMidi();\n        this._buffers.add(mid, url, callback);\n      } else {\n        // otherwise if it's numbers assume it's midi\n        this._buffers.add(note, url, callback);\n      }\n      return this;\n    }\n    /**\n     * If the buffers are loaded or not\n     */\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this._buffers.loaded;\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Sampler.prototype), \"dispose\", this).call(this);\n      this._buffers.dispose();\n      this._activeSources.forEach(function (sources) {\n        sources.forEach(function (source) {\n          return source.dispose();\n        });\n      });\n      this._activeSources.clear();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        attack: 0,\n        baseUrl: \"\",\n        curve: \"exponential\",\n        onload: noOp,\n        onerror: noOp,\n        release: 0.1,\n        urls: {}\n      });\n    }\n  }]);\n  return Sampler;\n}(Instrument);\n__decorate([timeRange(0)], Sampler.prototype, \"attack\", void 0);\n__decorate([timeRange(0)], Sampler.prototype, \"release\", void 0);","map":{"version":3,"mappings":"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","names":["ToneAudioBuffers","ftomf","intervalToFrequencyRatio","FrequencyClass","optionsFromArguments","noOp","isArray","isNote","isNumber","Instrument","ToneBufferSource","timeRange","assert","Sampler","getDefaults","arguments","Map","options","urlMap","Object","keys","urls","forEach","note","noteNumber","parseInt","isFinite","mid","context","toMidi","_buffers","onload","baseUrl","onerror","attack","release","curve","loaded","Promise","resolve","then","midi","MAX_INTERVAL","interval","has","Error","notes","time","velocity","log","Array","midiFloat","toFrequency","Math","round","remainder","difference","_findClosest","closestNote","buffer","get","playbackRate","source","url","fadeIn","fadeOut","connect","output","start","duration","_activeSources","set","push","onended","sources","index","indexOf","splice","length","toSeconds","stop","computedTime","shift","_syncState","_syncMethod","triggerAttack","d","min","triggerRelease","callback","add","dispose","clear","assign","__decorate"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\instrument\\Sampler.ts"],"sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { ToneAudioBuffers } from \"../core/context/ToneAudioBuffers\";\nimport { ftomf, intervalToFrequencyRatio } from \"../core/type/Conversions\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { Frequency, Interval, MidiNote, NormalRange, Note, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { isArray, isNote, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { ToneBufferSource, ToneBufferSourceCurve } from \"../source/buffer/ToneBufferSource\";\nimport { timeRange } from \"../core/util/Decorator\";\nimport { assert } from \"../core/util/Debug\";\n\ninterface SamplesMap {\n\t[note: string]: ToneAudioBuffer | AudioBuffer | string;\n\t[midi: number]: ToneAudioBuffer | AudioBuffer | string;\n}\n\nexport interface SamplerOptions extends InstrumentOptions {\n\tattack: Time;\n\trelease: Time;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n\tbaseUrl: string;\n\tcurve: ToneBufferSourceCurve;\n\turls: SamplesMap;\n}\n\n/**\n * Pass in an object which maps the note's pitch or midi value to the url,\n * then you can trigger the attack and release of that note like other instruments.\n * By automatically repitching the samples, it is possible to play pitches which\n * were not explicitly included which can save loading time.\n *\n * For sample or buffer playback where repitching is not necessary,\n * use [[Player]].\n * @example\n * const sampler = new Tone.Sampler({\n * \turls: {\n * \t\tA1: \"A1.mp3\",\n * \t\tA2: \"A2.mp3\",\n * \t},\n * \tbaseUrl: \"https://tonejs.github.io/audio/casio/\",\n * \tonload: () => {\n * \t\tsampler.triggerAttackRelease([\"C1\", \"E1\", \"G1\", \"B1\"], 0.5);\n * \t}\n * }).toDestination();\n * @category Instrument\n */\nexport class Sampler extends Instrument<SamplerOptions> {\n\n\treadonly name: string = \"Sampler\";\n\n\t/**\n\t * The stored and loaded buffers\n\t */\n\tprivate _buffers: ToneAudioBuffers;\n\n\t/**\n\t * The object of all currently playing BufferSources\n\t */\n\tprivate _activeSources: Map<MidiNote, ToneBufferSource[]> = new Map();\n\n\t/**\n\t * The envelope applied to the beginning of the sample.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * The envelope applied to the end of the envelope.\n\t * @min 0\n\t * @max 1\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The shape of the attack/release curve.\n\t * Either \"linear\" or \"exponential\"\n\t */\n\tcurve: ToneBufferSourceCurve;\n\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param onload The callback to invoke when all of the samples are loaded.\n\t * @param baseUrl The root URL of all of the samples, which is prepended to all the URLs.\n\t */\n\tconstructor(samples?: SamplesMap, onload?: () => void, baseUrl?: string);\n\t/**\n\t * @param samples An object of samples mapping either Midi Note Numbers or\n\t * \t\t\tScientific Pitch Notation to the url of that sample.\n\t * @param options The remaining options associated with the sampler\n\t */\n\tconstructor(samples?: SamplesMap, options?: Partial<Omit<SamplerOptions, \"urls\">>);\n\tconstructor(options?: Partial<SamplerOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\"));\n\t\tconst options = optionsFromArguments(Sampler.getDefaults(), arguments, [\"urls\", \"onload\", \"baseUrl\"], \"urls\");\n\n\t\tconst urlMap = {};\n\t\tObject.keys(options.urls).forEach((note) => {\n\t\t\tconst noteNumber = parseInt(note, 10);\n\t\t\tassert(isNote(note)\n\t\t\t\t|| (isNumber(noteNumber) && isFinite(noteNumber)), `url key is neither a note or midi pitch: ${note}`);\n\t\t\tif (isNote(note)) {\n\t\t\t\t// convert the note name to MIDI\n\t\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\t\turlMap[mid] = options.urls[note];\n\t\t\t} else if (isNumber(noteNumber) && isFinite(noteNumber)) {\n\t\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\t\turlMap[noteNumber] = options.urls[noteNumber];\n\t\t\t}\n\t\t});\n\n\t\tthis._buffers = new ToneAudioBuffers({\n\t\t\turls: urlMap,\n\t\t\tonload: options.onload,\n\t\t\tbaseUrl: options.baseUrl,\n\t\t\tonerror: options.onerror,\n\t\t});\n\t\tthis.attack = options.attack;\n\t\tthis.release = options.release;\n\t\tthis.curve = options.curve;\n\n\t\t// invoke the callback if it's already loaded\n\t\tif (this._buffers.loaded) {\n\t\t\t// invoke onload deferred\n\t\t\tPromise.resolve().then(options.onload);\n\t\t}\n\t}\n\n\tstatic getDefaults(): SamplerOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tattack: 0,\n\t\t\tbaseUrl: \"\",\n\t\t\tcurve: \"exponential\" as \"exponential\",\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\trelease: 0.1,\n\t\t\turls: {},\n\t\t});\n\t}\n\n\t/**\n\t * Returns the difference in steps between the given midi note at the closets sample.\n\t */\n\tprivate _findClosest(midi: MidiNote): Interval {\n\t\t// searches within 8 octaves of the given midi note\n\t\tconst MAX_INTERVAL = 96;\n\t\tlet interval = 0;\n\t\twhile (interval < MAX_INTERVAL) {\n\t\t\t// check above and below\n\t\t\tif (this._buffers.has(midi + interval)) {\n\t\t\t\treturn -interval;\n\t\t\t} else if (this._buffers.has(midi - interval)) {\n\t\t\t\treturn interval;\n\t\t\t}\n\t\t\tinterval++;\n\t\t}\n\t\tthrow new Error(`No available buffers for note: ${midi}`);\n\t}\n\n\t/**\n\t * @param  notes\tThe note to play, or an array of notes.\n\t * @param  time     When to play the note\n\t * @param  velocity The velocity to play the sample back.\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", notes, time, velocity);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midiFloat = ftomf(new FrequencyClass(this.context, note).toFrequency());\n\t\t\tconst midi = Math.round(midiFloat) as MidiNote;\n\t\t\tconst remainder = midiFloat - midi;\n\t\t\t// find the closest note pitch\n\t\t\tconst difference = this._findClosest(midi);\n\t\t\tconst closestNote = midi - difference;\n\t\t\tconst buffer = this._buffers.get(closestNote);\n\t\t\tconst playbackRate = intervalToFrequencyRatio(difference + remainder);\n\t\t\t// play that note\n\t\t\tconst source = new ToneBufferSource({\n\t\t\t\turl: buffer,\n\t\t\t\tcontext: this.context,\n\t\t\t\tcurve: this.curve,\n\t\t\t\tfadeIn: this.attack,\n\t\t\t\tfadeOut: this.release,\n\t\t\t\tplaybackRate,\n\t\t\t}).connect(this.output);\n\t\t\tsource.start(time, 0, buffer.duration / playbackRate, velocity);\n\t\t\t// add it to the active sources\n\t\t\tif (!isArray(this._activeSources.get(midi))) {\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t\t(this._activeSources.get(midi) as ToneBufferSource[]).push(source);\n\n\t\t\t// remove it when it's done\n\t\t\tsource.onended = () => {\n\t\t\t\tif (this._activeSources && this._activeSources.has(midi)) {\n\t\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\t\tconst index = sources.indexOf(source);\n\t\t\t\t\tif (index !== -1) {\n\t\t\t\t\t\tsources.splice(index, 1);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * @param  notes\tThe note to release, or an array of notes.\n\t * @param  time     \tWhen to release the note.\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tthis.log(\"triggerRelease\", notes, time);\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tnotes.forEach(note => {\n\t\t\tconst midi = new FrequencyClass(this.context, note).toMidi();\n\t\t\t// find the note\n\t\t\tif (this._activeSources.has(midi) && (this._activeSources.get(midi) as ToneBufferSource[]).length) {\n\t\t\t\tconst sources = this._activeSources.get(midi) as ToneBufferSource[];\n\t\t\t\ttime = this.toSeconds(time);\n\t\t\t\tsources.forEach(source => {\n\t\t\t\t\tsource.stop(time);\n\t\t\t\t});\n\t\t\t\tthis._activeSources.set(midi, []);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Release all currently active notes.\n\t * @param  time     \tWhen to release the notes.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeSources.forEach(sources => {\n\t\t\twhile (sources.length) {\n\t\t\t\tconst source = sources.shift() as ToneBufferSource;\n\t\t\t\tsource.stop(computedTime);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Invoke the attack phase, then after the duration, invoke the release.\n\t * @param  notes\tThe note to play and release, or an array of notes.\n\t * @param  duration The time the note should be held\n\t * @param  time     When to start the attack\n\t * @param  velocity The velocity of the attack\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency[] | Frequency,\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity: NormalRange = 1,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"notes must be an array when duration is array\");\n\t\t\t(notes as Frequency[]).forEach((note, index) => {\n\t\t\t\tconst d = duration[Math.min(index, duration.length - 1)];\n\t\t\t\tthis.triggerRelease(note, computedTime + this.toSeconds(d));\n\t\t\t});\n\t\t} else {\n\t\t\tthis.triggerRelease(notes, computedTime + this.toSeconds(duration));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add a note to the sampler.\n\t * @param  note      The buffer's pitch.\n\t * @param  url  Either the url of the buffer, or a buffer which will be added with the given name.\n\t * @param  callback  The callback to invoke when the url is loaded.\n\t */\n\tadd(note: Note | MidiNote, url: string | ToneAudioBuffer | AudioBuffer, callback?: () => void): this {\n\t\tassert(isNote(note) || isFinite(note), `note must be a pitch or midi: ${note}`);\n\t\tif (isNote(note)) {\n\t\t\t// convert the note name to MIDI\n\t\t\tconst mid = new FrequencyClass(this.context, note).toMidi();\n\t\t\tthis._buffers.add(mid, url, callback);\n\t\t} else {\n\t\t\t// otherwise if it's numbers assume it's midi\n\t\t\tthis._buffers.add(note, url, callback);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffers are loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this._buffers.loaded;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffers.dispose();\n\t\tthis._activeSources.forEach(sources => {\n\t\t\tsources.forEach(source => source.dispose());\n\t\t});\n\t\tthis._activeSources.clear();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
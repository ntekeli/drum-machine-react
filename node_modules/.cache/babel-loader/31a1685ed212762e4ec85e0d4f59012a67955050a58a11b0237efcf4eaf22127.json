{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport var ToneBufferSource = /*#__PURE__*/function (_OneShotSource) {\n  _inherits(ToneBufferSource, _OneShotSource);\n  var _super = _createSuper(ToneBufferSource);\n  function ToneBufferSource() {\n    var _this;\n    _classCallCheck(this, ToneBufferSource);\n    _this = _super.call(this, optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n    _this.name = \"ToneBufferSource\";\n    /**\n     * The oscillator\n     */\n    _this._source = _this.context.createBufferSource();\n    _this._internalChannels = [_this._source];\n    /**\n     * indicators if the source has started/stopped\n     */\n    _this._sourceStarted = false;\n    _this._sourceStopped = false;\n    var options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n    connect(_this._source, _this._gainNode);\n    _this._source.onended = function () {\n      return _this._stopSource();\n    };\n    /**\n     * The playbackRate of the buffer\n     */\n    _this.playbackRate = new Param({\n      context: _this.context,\n      param: _this._source.playbackRate,\n      units: \"positive\",\n      value: options.playbackRate\n    });\n    // set some values initially\n    _this.loop = options.loop;\n    _this.loopStart = options.loopStart;\n    _this.loopEnd = options.loopEnd;\n    _this._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n    _this._internalChannels.push(_this._source);\n    return _this;\n  }\n  _createClass(ToneBufferSource, [{\n    key: \"fadeIn\",\n    get:\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n    function get() {\n      return this._fadeIn;\n    },\n    set: function set(t) {\n      this._fadeIn = t;\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n  }, {\n    key: \"fadeOut\",\n    get: function get() {\n      return this._fadeOut;\n    },\n    set: function set(t) {\n      this._fadeOut = t;\n    }\n    /**\n     * The curve applied to the fades, either \"linear\" or \"exponential\"\n     */\n  }, {\n    key: \"curve\",\n    get: function get() {\n      return this._curve;\n    },\n    set: function set(t) {\n      this._curve = t;\n    }\n    /**\n     * Start the buffer\n     * @param  time When the player should start.\n     * @param  offset The offset from the beginning of the sample to start at.\n     * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n     * @param  gain  The gain to play the buffer back at.\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset, duration) {\n      var gain = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      assert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n      var computedTime = this.toSeconds(time);\n      // apply the gain envelope\n      this._startGain(computedTime, gain);\n      // if it's a loop the default offset is the loopstart point\n      if (this.loop) {\n        offset = defaultArg(offset, this.loopStart);\n      } else {\n        // otherwise the default offset is 0\n        offset = defaultArg(offset, 0);\n      }\n      // make sure the offset is not less than 0\n      var computedOffset = Math.max(this.toSeconds(offset), 0);\n      // start the buffer source\n      if (this.loop) {\n        // modify the offset if it's greater than the loop time\n        var loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n        var loopStart = this.toSeconds(this.loopStart);\n        var loopDuration = loopEnd - loopStart;\n        // move the offset back\n        if (GTE(computedOffset, loopEnd)) {\n          computedOffset = (computedOffset - loopStart) % loopDuration + loopStart;\n        }\n        // when the offset is very close to the duration, set it to 0\n        if (EQ(computedOffset, this.buffer.duration)) {\n          computedOffset = 0;\n        }\n      }\n      // this.buffer.loaded would have return false if the AudioBuffer was undefined\n      this._source.buffer = this.buffer.get();\n      this._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n      if (LT(computedOffset, this.buffer.duration)) {\n        this._sourceStarted = true;\n        this._source.start(computedTime, computedOffset);\n      }\n      // if a duration is given, schedule a stop\n      if (isDefined(duration)) {\n        var computedDur = this.toSeconds(duration);\n        // make sure it's never negative\n        computedDur = Math.max(computedDur, 0);\n        this.stop(computedTime + computedDur);\n      }\n      return this;\n    }\n  }, {\n    key: \"_stopSource\",\n    value: function _stopSource(time) {\n      if (!this._sourceStopped && this._sourceStarted) {\n        this._sourceStopped = true;\n        this._source.stop(this.toSeconds(time));\n        this._onended();\n      }\n    }\n    /**\n     * If loop is true, the loop will start at this position.\n     */\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return this._source.loopStart;\n    },\n    set: function set(loopStart) {\n      this._source.loopStart = this.toSeconds(loopStart);\n    }\n    /**\n     * If loop is true, the loop will end at this position.\n     */\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return this._source.loopEnd;\n    },\n    set: function set(loopEnd) {\n      this._source.loopEnd = this.toSeconds(loopEnd);\n    }\n    /**\n     * The audio buffer belonging to the player.\n     */\n  }, {\n    key: \"buffer\",\n    get: function get() {\n      return this._buffer;\n    },\n    set: function set(buffer) {\n      this._buffer.set(buffer);\n    }\n    /**\n     * If the buffer should loop once it's over.\n     */\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._source.loop;\n    },\n    set: function set(loop) {\n      this._source.loop = loop;\n      if (this._sourceStarted) {\n        this.cancelStop();\n      }\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneBufferSource.prototype), \"dispose\", this).call(this);\n      this._source.onended = null;\n      this._source.disconnect();\n      this._buffer.dispose();\n      this.playbackRate.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(OneShotSource.getDefaults(), {\n        url: new ToneAudioBuffer(),\n        loop: false,\n        loopEnd: 0,\n        loopStart: 0,\n        onload: noOp,\n        onerror: noOp,\n        playbackRate: 1\n      });\n    }\n  }]);\n  return ToneBufferSource;\n}(OneShotSource);","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,OAAO,QAAQ,kCAAkC;AAC1D,SAASC,KAAK,QAAQ,0BAA0B;AAChD,SAASC,eAAe,QAAQ,oCAAoC;AAEpE,SAASC,UAAU,EAAEC,oBAAoB,QAAQ,0BAA0B;AAC3E,SAASC,IAAI,QAAQ,2BAA2B;AAChD,SAASC,SAAS,QAAQ,2BAA2B;AACrD,SAASC,MAAM,QAAQ,uBAAuB;AAC9C,SAASC,aAAa,QAAkD,kBAAkB;AAC1F,SAASC,EAAE,EAAEC,GAAG,EAAEC,EAAE,QAAQ,sBAAsB;AAiBlD;;;;AAIA,WAAaC,gBAAiB;EAAA;EAAA;EAgC7B;IAAA;IAAA;IAEC,0BAAMR,oBAAoB,CAACQ,gBAAgB,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAhChF,UAAI,GAAW,kBAAkB;IAE1C;;;IAGQ,aAAO,GAAG,MAAKC,OAAO,CAACC,kBAAkB,EAAE;IACzC,uBAAiB,GAAG,CAAC,MAAKC,OAAO,CAAC;IAY5C;;;IAGQ,oBAAc,GAAG,KAAK;IACtB,oBAAc,GAAG,KAAK;IAW7B,IAAMC,OAAO,GAAGd,oBAAoB,CAACQ,gBAAgB,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,KAAK,EAAE,QAAQ,CAAC,CAAC;IAElGd,OAAO,CAAC,MAAKiB,OAAO,EAAE,MAAKE,SAAS,CAAC;IACrC,MAAKF,OAAO,CAACG,OAAO,GAAG;MAAA,OAAM,MAAKC,WAAW,EAAE;IAAA;IAE/C;;;IAGA,MAAKC,YAAY,GAAG,IAAIrB,KAAK,CAAC;MAC7Bc,OAAO,EAAE,MAAKA,OAAO;MACrBQ,KAAK,EAAE,MAAKN,OAAO,CAACK,YAAY;MAChCE,KAAK,EAAE,UAAU;MACjBC,KAAK,EAAEP,OAAO,CAACI;KACf,CAAC;IAEF;IACA,MAAKI,IAAI,GAAGR,OAAO,CAACQ,IAAI;IACxB,MAAKC,SAAS,GAAGT,OAAO,CAACS,SAAS;IAClC,MAAKC,OAAO,GAAGV,OAAO,CAACU,OAAO;IAC9B,MAAKC,OAAO,GAAG,IAAI3B,eAAe,CAACgB,OAAO,CAACY,GAAG,EAAEZ,OAAO,CAACa,MAAM,EAAEb,OAAO,CAACc,OAAO,CAAC;IAEhF,MAAKC,iBAAiB,CAACC,IAAI,CAAC,MAAKjB,OAAO,CAAC;IAAC;EAC3C;EAAC;IAAA;IAAA;IAcD;;;IAGA,eAAU;MACT,OAAO,IAAI,CAACkB,OAAO;IACpB,CAAC;IAAA,KACD,aAAWC,CAAO;MACjB,IAAI,CAACD,OAAO,GAAGC,CAAC;IACjB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAW;MACV,OAAO,IAAI,CAACC,QAAQ;IACrB,CAAC;IAAA,KACD,aAAYD,CAAO;MAClB,IAAI,CAACC,QAAQ,GAAGD,CAAC;IAClB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAS;MACR,OAAO,IAAI,CAACE,MAAM;IACnB,CAAC;IAAA,KACD,aAAUF,CAAC;MACV,IAAI,CAACE,MAAM,GAAGF,CAAC;IAChB;IAEA;;;;;;;EAAA;IAAA;IAAA,OAOA,eAAMG,IAAW,EAAEC,MAAa,EAAEC,QAAe,EAAsB;MAAA,IAApBC,2EAAmB,CAAC;MACtEnC,MAAM,CAAC,IAAI,CAACoC,MAAM,CAACC,MAAM,EAAE,wCAAwC,CAAC;MACpE,IAAMC,YAAY,GAAG,IAAI,CAACC,SAAS,CAACP,IAAI,CAAC;MAEzC;MACA,IAAI,CAACQ,UAAU,CAACF,YAAY,EAAEH,IAAI,CAAC;MAEnC;MACA,IAAI,IAAI,CAAChB,IAAI,EAAE;QACdc,MAAM,GAAGrC,UAAU,CAACqC,MAAM,EAAE,IAAI,CAACb,SAAS,CAAC;OAC3C,MAAM;QACN;QACAa,MAAM,GAAGrC,UAAU,CAACqC,MAAM,EAAE,CAAC,CAAC;;MAE/B;MACA,IAAIQ,cAAc,GAAGC,IAAI,CAACC,GAAG,CAAC,IAAI,CAACJ,SAAS,CAACN,MAAM,CAAC,EAAE,CAAC,CAAC;MAExD;MACA,IAAI,IAAI,CAACd,IAAI,EAAE;QACd;QACA,IAAME,OAAO,GAAG,IAAI,CAACkB,SAAS,CAAC,IAAI,CAAClB,OAAO,CAAC,IAAI,IAAI,CAACe,MAAM,CAACF,QAAQ;QACpE,IAAMd,SAAS,GAAG,IAAI,CAACmB,SAAS,CAAC,IAAI,CAACnB,SAAS,CAAC;QAChD,IAAMwB,YAAY,GAAGvB,OAAO,GAAGD,SAAS;QACxC;QACA,IAAIjB,GAAG,CAACsC,cAAc,EAAEpB,OAAO,CAAC,EAAE;UACjCoB,cAAc,GAAI,CAACA,cAAc,GAAGrB,SAAS,IAAIwB,YAAY,GAAIxB,SAAS;;QAE3E;QACA,IAAIlB,EAAE,CAACuC,cAAc,EAAE,IAAI,CAACL,MAAM,CAACF,QAAQ,CAAC,EAAE;UAC7CO,cAAc,GAAG,CAAC;;;MAIpB;MACA,IAAI,CAAC/B,OAAO,CAAC0B,MAAM,GAAG,IAAI,CAACA,MAAM,CAACS,GAAG,EAAiB;MACtD,IAAI,CAACnC,OAAO,CAACW,OAAO,GAAG,IAAI,CAACkB,SAAS,CAAC,IAAI,CAAClB,OAAO,CAAC,IAAI,IAAI,CAACe,MAAM,CAACF,QAAQ;MAC3E,IAAI9B,EAAE,CAACqC,cAAc,EAAE,IAAI,CAACL,MAAM,CAACF,QAAQ,CAAC,EAAE;QAC7C,IAAI,CAACY,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACpC,OAAO,CAACqC,KAAK,CAACT,YAAY,EAAEG,cAAc,CAAC;;MAGjD;MACA,IAAI1C,SAAS,CAACmC,QAAQ,CAAC,EAAE;QACxB,IAAIc,WAAW,GAAG,IAAI,CAACT,SAAS,CAACL,QAAQ,CAAC;QAC1C;QACAc,WAAW,GAAGN,IAAI,CAACC,GAAG,CAACK,WAAW,EAAE,CAAC,CAAC;QACtC,IAAI,CAACC,IAAI,CAACX,YAAY,GAAGU,WAAW,CAAC;;MAGtC,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAES,qBAAYhB,IAAc;MACnC,IAAI,CAAC,IAAI,CAACkB,cAAc,IAAI,IAAI,CAACJ,cAAc,EAAE;QAChD,IAAI,CAACI,cAAc,GAAG,IAAI;QAC1B,IAAI,CAACxC,OAAO,CAACuC,IAAI,CAAC,IAAI,CAACV,SAAS,CAACP,IAAI,CAAC,CAAC;QACvC,IAAI,CAACmB,QAAQ,EAAE;;IAEjB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAa;MACZ,OAAO,IAAI,CAACzC,OAAO,CAACU,SAAS;IAC9B,CAAC;IAAA,KACD,aAAcA,SAAe;MAC5B,IAAI,CAACV,OAAO,CAACU,SAAS,GAAG,IAAI,CAACmB,SAAS,CAACnB,SAAS,CAAC;IACnD;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAW;MACV,OAAO,IAAI,CAACV,OAAO,CAACW,OAAO;IAC5B,CAAC;IAAA,KACD,aAAYA,OAAa;MACxB,IAAI,CAACX,OAAO,CAACW,OAAO,GAAG,IAAI,CAACkB,SAAS,CAAClB,OAAO,CAAC;IAC/C;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAU;MACT,OAAO,IAAI,CAACC,OAAO;IACpB,CAAC;IAAA,KACD,aAAWc,MAAuB;MACjC,IAAI,CAACd,OAAO,CAAC8B,GAAG,CAAChB,MAAM,CAAC;IACzB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAQ;MACP,OAAO,IAAI,CAAC1B,OAAO,CAACS,IAAI;IACzB,CAAC;IAAA,KACD,aAASA,IAAa;MACrB,IAAI,CAACT,OAAO,CAACS,IAAI,GAAGA,IAAI;MACxB,IAAI,IAAI,CAAC2B,cAAc,EAAE;QACxB,IAAI,CAACO,UAAU,EAAE;;IAEnB;IAEA;;;EAAA;IAAA;IAAA,OAGA,mBAAO;MACN;MACA,IAAI,CAAC3C,OAAO,CAACG,OAAO,GAAG,IAAI;MAC3B,IAAI,CAACH,OAAO,CAAC4C,UAAU,EAAE;MACzB,IAAI,CAAChC,OAAO,CAACiC,OAAO,EAAE;MACtB,IAAI,CAACxC,YAAY,CAACwC,OAAO,EAAE;MAC3B,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAlKD,uBAAkB;MACjB,OAAOC,MAAM,CAACC,MAAM,CAACxD,aAAa,CAACK,WAAW,EAAE,EAAE;QACjDiB,GAAG,EAAE,IAAI5B,eAAe,EAAE;QAC1BwB,IAAI,EAAE,KAAK;QACXE,OAAO,EAAE,CAAC;QACVD,SAAS,EAAE,CAAC;QACZI,MAAM,EAAE1B,IAAI;QACZ2B,OAAO,EAAE3B,IAAI;QACbiB,YAAY,EAAE;OACd,CAAC;IACH;EAAC;EAAA;AAAA,EArEoCd,aAAsC","names":["connect","Param","ToneAudioBuffer","defaultArg","optionsFromArguments","noOp","isDefined","assert","OneShotSource","EQ","GTE","LT","ToneBufferSource","getDefaults","arguments","context","createBufferSource","_source","options","_gainNode","onended","_stopSource","playbackRate","param","units","value","loop","loopStart","loopEnd","_buffer","url","onload","onerror","_internalChannels","push","_fadeIn","t","_fadeOut","_curve","time","offset","duration","gain","buffer","loaded","computedTime","toSeconds","_startGain","computedOffset","Math","max","loopDuration","get","_sourceStarted","start","computedDur","stop","_sourceStopped","_onended","set","cancelStop","disconnect","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\buffer\\ToneBufferSource.ts"],"sourcesContent":["import { connect } from \"../../core/context/ToneAudioNode\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioBuffer } from \"../../core/context/ToneAudioBuffer\";\nimport { GainFactor, Positive, Seconds, Time } from \"../../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { assert } from \"../../core/util/Debug\";\nimport { OneShotSource, OneShotSourceCurve, OneShotSourceOptions } from \"../OneShotSource\";\nimport { EQ, GTE, LT } from \"../../core/util/Math\";\n\nexport type ToneBufferSourceCurve = OneShotSourceCurve;\n\nexport interface ToneBufferSourceOptions extends OneShotSourceOptions {\n\turl: string | AudioBuffer | ToneAudioBuffer;\n\tcurve: ToneBufferSourceCurve;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tloop: boolean;\n\tonload: () => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * Wrapper around the native BufferSourceNode.\n * @category Source\n */\nexport class ToneBufferSource extends OneShotSource<ToneBufferSourceOptions> {\n\n\treadonly name: string = \"ToneBufferSource\";\n\n\t/**\n\t * The oscillator\n\t */\n\tprivate _source = this.context.createBufferSource();\n\tprotected _internalChannels = [this._source];\n\n\t/**\n\t * The frequency of the oscillator\n\t */\n\treadonly playbackRate: Param<\"positive\">;\n\n\t/**\n\t * The private instance of the buffer object\n\t */\n\tprivate _buffer: ToneAudioBuffer;\n\n\t/**\n\t * indicators if the source has started/stopped\n\t */\n\tprivate _sourceStarted = false;\n\tprivate _sourceStopped = false;\n\n\t/**\n\t * @param url The buffer to play or url to load\n\t * @param onload The callback to invoke when the buffer is done playing.\n\t */\n\tconstructor(url?: ToneAudioBuffer | AudioBuffer | string, onload?: () => void);\n\tconstructor(options?: Partial<ToneBufferSourceOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]));\n\t\tconst options = optionsFromArguments(ToneBufferSource.getDefaults(), arguments, [\"url\", \"onload\"]);\n\n\t\tconnect(this._source, this._gainNode);\n\t\tthis._source.onended = () => this._stopSource();\n\n\t\t/**\n\t\t * The playbackRate of the buffer\n\t\t */\n\t\tthis.playbackRate = new Param({\n\t\t\tcontext: this.context,\n\t\t\tparam: this._source.playbackRate,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.playbackRate,\n\t\t});\n\n\t\t// set some values initially\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis._buffer = new ToneAudioBuffer(options.url, options.onload, options.onerror);\n\n\t\tthis._internalChannels.push(this._source);\n\t}\n\n\tstatic getDefaults(): ToneBufferSourceOptions {\n\t\treturn Object.assign(OneShotSource.getDefaults(), {\n\t\t\turl: new ToneAudioBuffer(),\n\t\t\tloop: false,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tonload: noOp,\n\t\t\tonerror: noOp,\n\t\t\tplaybackRate: 1,\n\t\t});\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(t: Time) {\n\t\tthis._fadeIn = t;\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(t: Time) {\n\t\tthis._fadeOut = t;\n\t}\n\n\t/**\n\t * The curve applied to the fades, either \"linear\" or \"exponential\"\n\t */\n\tget curve(): ToneBufferSourceCurve {\n\t\treturn this._curve;\n\t}\n\tset curve(t) {\n\t\tthis._curve = t;\n\t}\n\n\t/**\n\t * Start the buffer\n\t * @param  time When the player should start.\n\t * @param  offset The offset from the beginning of the sample to start at.\n\t * @param  duration How long the sample should play. If no duration is given, it will default to the full length of the sample (minus any offset)\n\t * @param  gain  The gain to play the buffer back at.\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time, gain: GainFactor = 1): this {\n\t\tassert(this.buffer.loaded, \"buffer is either not set or not loaded\");\n\t\tconst computedTime = this.toSeconds(time);\n\n\t\t// apply the gain envelope\n\t\tthis._startGain(computedTime, gain);\n\n\t\t// if it's a loop the default offset is the loopstart point\n\t\tif (this.loop) {\n\t\t\toffset = defaultArg(offset, this.loopStart);\n\t\t} else {\n\t\t\t// otherwise the default offset is 0\n\t\t\toffset = defaultArg(offset, 0);\n\t\t}\n\t\t// make sure the offset is not less than 0\n\t\tlet computedOffset = Math.max(this.toSeconds(offset), 0);\n\n\t\t// start the buffer source\n\t\tif (this.loop) {\n\t\t\t// modify the offset if it's greater than the loop time\n\t\t\tconst loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\t\tconst loopStart = this.toSeconds(this.loopStart);\n\t\t\tconst loopDuration = loopEnd - loopStart;\n\t\t\t// move the offset back\n\t\t\tif (GTE(computedOffset, loopEnd)) {\n\t\t\t\tcomputedOffset = ((computedOffset - loopStart) % loopDuration) + loopStart;\n\t\t\t}\n\t\t\t// when the offset is very close to the duration, set it to 0\n\t\t\tif (EQ(computedOffset, this.buffer.duration)) {\n\t\t\t\tcomputedOffset = 0;\n\t\t\t}\n\t\t}\n\t\t\n\t\t// this.buffer.loaded would have return false if the AudioBuffer was undefined\n\t\tthis._source.buffer = this.buffer.get() as AudioBuffer;\n\t\tthis._source.loopEnd = this.toSeconds(this.loopEnd) || this.buffer.duration;\n\t\tif (LT(computedOffset, this.buffer.duration)) {\n\t\t\tthis._sourceStarted = true;\n\t\t\tthis._source.start(computedTime, computedOffset);\n\t\t}\n\n\t\t// if a duration is given, schedule a stop\n\t\tif (isDefined(duration)) {\n\t\t\tlet computedDur = this.toSeconds(duration);\n\t\t\t// make sure it's never negative\n\t\t\tcomputedDur = Math.max(computedDur, 0);\n\t\t\tthis.stop(computedTime + computedDur);\n\t\t}\n\n\t\treturn this;\n\t}\n\n\tprotected _stopSource(time?: Seconds): void {\n\t\tif (!this._sourceStopped && this._sourceStarted) {\n\t\t\tthis._sourceStopped = true;\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._onended();\n\t\t}\n\t}\n\n\t/**\n\t * If loop is true, the loop will start at this position.\n\t */\n\tget loopStart(): Time {\n\t\treturn this._source.loopStart;\n\t}\n\tset loopStart(loopStart: Time) {\n\t\tthis._source.loopStart = this.toSeconds(loopStart);\n\t}\n\n\t/**\n\t * If loop is true, the loop will end at this position.\n\t */\n\tget loopEnd(): Time {\n\t\treturn this._source.loopEnd;\n\t}\n\tset loopEnd(loopEnd: Time) {\n\t\tthis._source.loopEnd = this.toSeconds(loopEnd);\n\t}\n\n\t/**\n\t * The audio buffer belonging to the player.\n\t */\n\tget buffer(): ToneAudioBuffer {\n\t\treturn this._buffer;\n\t}\n\tset buffer(buffer: ToneAudioBuffer) {\n\t\tthis._buffer.set(buffer);\n\t}\n\n\t/**\n\t * If the buffer should loop once it's over.\n\t */\n\tget loop(): boolean {\n\t\treturn this._source.loop;\n\t}\n\tset loop(loop: boolean) {\n\t\tthis._source.loop = loop;\n\t\tif (this._sourceStarted) {\n\t\t\tthis.cancelStop();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._source.onended = null;\n\t\tthis._source.disconnect();\n\t\tthis._buffer.dispose();\n\t\tthis.playbackRate.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
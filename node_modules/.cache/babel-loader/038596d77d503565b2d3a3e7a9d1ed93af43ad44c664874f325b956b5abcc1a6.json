{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport var Param = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Param, _ToneWithContext);\n  var _super = _createSuper(Param);\n  function Param() {\n    var _this;\n    _classCallCheck(this, Param);\n    _this = _super.call(this, optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n    _this.name = \"Param\";\n    _this.overridden = false;\n    /**\n     * The minimum output value\n     */\n    _this._minOutput = 1e-7;\n    var options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n    assert(isDefined(options.param) && (isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n    while (!isAudioParam(options.param)) {\n      options.param = options.param._param;\n    }\n    _this._swappable = isDefined(options.swappable) ? options.swappable : false;\n    if (_this._swappable) {\n      _this.input = _this.context.createGain();\n      // initialize\n      _this._param = options.param;\n      _this.input.connect(_this._param);\n    } else {\n      _this._param = _this.input = options.param;\n    }\n    _this._events = new Timeline(1000);\n    _this._initialValue = _this._param.defaultValue;\n    _this.units = options.units;\n    _this.convert = options.convert;\n    _this._minValue = options.minValue;\n    _this._maxValue = options.maxValue;\n    // if the value is defined, set it immediately\n    if (isDefined(options.value) && options.value !== _this._toType(_this._initialValue)) {\n      _this.setValueAtTime(options.value, 0);\n    }\n    return _this;\n  }\n  _createClass(Param, [{\n    key: \"value\",\n    get: function get() {\n      var now = this.now();\n      return this.getValueAtTime(now);\n    },\n    set: function set(value) {\n      this.cancelScheduledValues(this.now());\n      this.setValueAtTime(value, this.now());\n    }\n  }, {\n    key: \"minValue\",\n    get: function get() {\n      // if it's not the default minValue, return it\n      if (isDefined(this._minValue)) {\n        return this._minValue;\n      } else if (this.units === \"time\" || this.units === \"frequency\" || this.units === \"normalRange\" || this.units === \"positive\" || this.units === \"transportTime\" || this.units === \"ticks\" || this.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n        return 0;\n      } else if (this.units === \"audioRange\") {\n        return -1;\n      } else if (this.units === \"decibels\") {\n        return -Infinity;\n      } else {\n        return this._param.minValue;\n      }\n    }\n  }, {\n    key: \"maxValue\",\n    get: function get() {\n      if (isDefined(this._maxValue)) {\n        return this._maxValue;\n      } else if (this.units === \"normalRange\" || this.units === \"audioRange\") {\n        return 1;\n      } else {\n        return this._param.maxValue;\n      }\n    }\n    /**\n     * Type guard based on the unit name\n     */\n  }, {\n    key: \"_is\",\n    value: function _is(arg, type) {\n      return this.units === type;\n    }\n    /**\n     * Make sure the value is always in the defined range\n     */\n  }, {\n    key: \"_assertRange\",\n    value: function _assertRange(value) {\n      if (isDefined(this.maxValue) && isDefined(this.minValue)) {\n        assertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n      }\n      return value;\n    }\n    /**\n     * Convert the given value from the type specified by Param.units\n     * into the destination value (such as Gain or Frequency).\n     */\n  }, {\n    key: \"_fromType\",\n    value: function _fromType(val) {\n      if (this.convert && !this.overridden) {\n        if (this._is(val, \"time\")) {\n          return this.toSeconds(val);\n        } else if (this._is(val, \"decibels\")) {\n          return dbToGain(val);\n        } else if (this._is(val, \"frequency\")) {\n          return this.toFrequency(val);\n        } else {\n          return val;\n        }\n      } else if (this.overridden) {\n        // if it's overridden, should only schedule 0s\n        return 0;\n      } else {\n        return val;\n      }\n    }\n    /**\n     * Convert the parameters value into the units specified by Param.units.\n     */\n  }, {\n    key: \"_toType\",\n    value: function _toType(val) {\n      if (this.convert && this.units === \"decibels\") {\n        return gainToDb(val);\n      } else {\n        return val;\n      }\n    }\n    //-------------------------------------\n    // ABSTRACT PARAM INTERFACE\n    // all docs are generated from ParamInterface.ts\n    //-------------------------------------\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n      var numericValue = this._fromType(value);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(time)));\n      this._assertRange(numericValue);\n      this.log(this.units, \"setValueAtTime\", value, computedTime);\n      this._events.add({\n        time: computedTime,\n        type: \"setValueAtTime\",\n        value: numericValue\n      });\n      this._param.setValueAtTime(numericValue, computedTime);\n      return this;\n    }\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      var computedTime = Math.max(this.toSeconds(time), 0);\n      var after = this._events.getAfter(computedTime);\n      var before = this._events.get(computedTime);\n      var value = this._initialValue;\n      // if it was set by\n      if (before === null) {\n        value = this._initialValue;\n      } else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n        var previous = this._events.getBefore(before.time);\n        var previousVal;\n        if (previous === null) {\n          previousVal = this._initialValue;\n        } else {\n          previousVal = previous.value;\n        }\n        if (before.type === \"setTargetAtTime\") {\n          value = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n        }\n      } else if (after === null) {\n        value = before.value;\n      } else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n        var beforeValue = before.value;\n        if (before.type === \"setTargetAtTime\") {\n          var _previous = this._events.getBefore(before.time);\n          if (_previous === null) {\n            beforeValue = this._initialValue;\n          } else {\n            beforeValue = _previous.value;\n          }\n        }\n        if (after.type === \"linearRampToValueAtTime\") {\n          value = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n        } else {\n          value = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n        }\n      } else {\n        value = before.value;\n      }\n      return this._toType(value);\n    }\n  }, {\n    key: \"setRampPoint\",\n    value: function setRampPoint(time) {\n      time = this.toSeconds(time);\n      var currentVal = this.getValueAtTime(time);\n      this.cancelAndHoldAtTime(time);\n      if (this._fromType(currentVal) === 0) {\n        currentVal = this._toType(this._minOutput);\n      }\n      this.setValueAtTime(currentVal, time);\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, endTime) {\n      var numericValue = this._fromType(value);\n      var computedTime = this.toSeconds(endTime);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to linearRampToValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(endTime)));\n      this._assertRange(numericValue);\n      this._events.add({\n        time: computedTime,\n        type: \"linearRampToValueAtTime\",\n        value: numericValue\n      });\n      this.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n      this._param.linearRampToValueAtTime(numericValue, computedTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, endTime) {\n      var numericValue = this._fromType(value);\n      // the value can't be 0\n      numericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n      this._assertRange(numericValue);\n      var computedTime = this.toSeconds(endTime);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to exponentialRampToValueAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(endTime)));\n      // store the event\n      this._events.add({\n        time: computedTime,\n        type: \"exponentialRampToValueAtTime\",\n        value: numericValue\n      });\n      this.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n      this._param.exponentialRampToValueAtTime(numericValue, computedTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampTo\",\n    value: function exponentialRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n      return this;\n    }\n  }, {\n    key: \"linearRampTo\",\n    value: function linearRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n      return this;\n    }\n  }, {\n    key: \"targetRampTo\",\n    value: function targetRampTo(value, rampTime, startTime) {\n      startTime = this.toSeconds(startTime);\n      this.setRampPoint(startTime);\n      this.exponentialApproachValueAtTime(value, startTime, rampTime);\n      return this;\n    }\n  }, {\n    key: \"exponentialApproachValueAtTime\",\n    value: function exponentialApproachValueAtTime(value, time, rampTime) {\n      time = this.toSeconds(time);\n      rampTime = this.toSeconds(rampTime);\n      var timeConstant = Math.log(rampTime + 1) / Math.log(200);\n      this.setTargetAtTime(value, time, timeConstant);\n      // at 90% start a linear ramp to the final value\n      this.cancelAndHoldAtTime(time + rampTime * 0.9);\n      this.linearRampToValueAtTime(value, time + rampTime);\n      return this;\n    }\n  }, {\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, startTime, timeConstant) {\n      var numericValue = this._fromType(value);\n      // The value will never be able to approach without timeConstant > 0.\n      assert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n      var computedTime = this.toSeconds(startTime);\n      this._assertRange(numericValue);\n      assert(isFinite(numericValue) && isFinite(computedTime), \"Invalid argument(s) to setTargetAtTime: \".concat(JSON.stringify(value), \", \").concat(JSON.stringify(startTime)));\n      this._events.add({\n        constant: timeConstant,\n        time: computedTime,\n        type: \"setTargetAtTime\",\n        value: numericValue\n      });\n      this.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n      this._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n      return this;\n    }\n  }, {\n    key: \"setValueCurveAtTime\",\n    value: function setValueCurveAtTime(values, startTime, duration) {\n      var scaling = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : 1;\n      duration = this.toSeconds(duration);\n      startTime = this.toSeconds(startTime);\n      var startingValue = this._fromType(values[0]) * scaling;\n      this.setValueAtTime(this._toType(startingValue), startTime);\n      var segTime = duration / (values.length - 1);\n      for (var i = 1; i < values.length; i++) {\n        var numericValue = this._fromType(values[i]) * scaling;\n        this.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n      }\n      return this;\n    }\n  }, {\n    key: \"cancelScheduledValues\",\n    value: function cancelScheduledValues(time) {\n      var computedTime = this.toSeconds(time);\n      assert(isFinite(computedTime), \"Invalid argument to cancelScheduledValues: \".concat(JSON.stringify(time)));\n      this._events.cancel(computedTime);\n      this._param.cancelScheduledValues(computedTime);\n      this.log(this.units, \"cancelScheduledValues\", computedTime);\n      return this;\n    }\n  }, {\n    key: \"cancelAndHoldAtTime\",\n    value: function cancelAndHoldAtTime(time) {\n      var computedTime = this.toSeconds(time);\n      var valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n      // remove the schedule events\n      assert(isFinite(computedTime), \"Invalid argument to cancelAndHoldAtTime: \".concat(JSON.stringify(time)));\n      this.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n      // if there is an event at the given computedTime\n      // and that even is not a \"set\"\n      var before = this._events.get(computedTime);\n      var after = this._events.getAfter(computedTime);\n      if (before && EQ(before.time, computedTime)) {\n        // remove everything after\n        if (after) {\n          this._param.cancelScheduledValues(after.time);\n          this._events.cancel(after.time);\n        } else {\n          this._param.cancelAndHoldAtTime(computedTime);\n          this._events.cancel(computedTime + this.sampleTime);\n        }\n      } else if (after) {\n        this._param.cancelScheduledValues(after.time);\n        // cancel the next event(s)\n        this._events.cancel(after.time);\n        if (after.type === \"linearRampToValueAtTime\") {\n          this.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n        } else if (after.type === \"exponentialRampToValueAtTime\") {\n          this.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n        }\n      }\n      // set the value at the given time\n      this._events.add({\n        time: computedTime,\n        type: \"setValueAtTime\",\n        value: valueAtTime\n      });\n      this._param.setValueAtTime(valueAtTime, computedTime);\n      return this;\n    }\n  }, {\n    key: \"rampTo\",\n    value: function rampTo(value) {\n      var rampTime = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0.1;\n      var startTime = arguments.length > 2 ? arguments[2] : undefined;\n      if (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n        this.exponentialRampTo(value, rampTime, startTime);\n      } else {\n        this.linearRampTo(value, rampTime, startTime);\n      }\n      return this;\n    }\n    /**\n     * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n     * The applied values will start at the context's current time and schedule\n     * all of the events which are scheduled on this Param onto the passed in param.\n     */\n  }, {\n    key: \"apply\",\n    value: function apply(param) {\n      var now = this.context.currentTime;\n      // set the param's value at the current time and schedule everything else\n      param.setValueAtTime(this.getValueAtTime(now), now);\n      // if the previous event was a curve, then set the rest of it\n      var previousEvent = this._events.get(now);\n      if (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n        // approx it until the next event with linear ramps\n        var nextEvent = this._events.getAfter(previousEvent.time);\n        // or for 2 seconds if there is no event\n        var endTime = nextEvent ? nextEvent.time : now + 2;\n        var subdivisions = (endTime - now) / 10;\n        for (var i = now; i < endTime; i += subdivisions) {\n          param.linearRampToValueAtTime(this.getValueAtTime(i), i);\n        }\n      }\n      this._events.forEachAfter(this.context.currentTime, function (event) {\n        if (event.type === \"cancelScheduledValues\") {\n          param.cancelScheduledValues(event.time);\n        } else if (event.type === \"setTargetAtTime\") {\n          param.setTargetAtTime(event.value, event.time, event.constant);\n        } else {\n          param[event.type](event.value, event.time);\n        }\n      });\n      return this;\n    }\n    /**\n     * Replace the Param's internal AudioParam. Will apply scheduled curves\n     * onto the parameter and replace the connections.\n     */\n  }, {\n    key: \"setParam\",\n    value: function setParam(param) {\n      assert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n      var input = this.input;\n      input.disconnect(this._param);\n      this.apply(param);\n      this._param = param;\n      input.connect(this._param);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Param.prototype), \"dispose\", this).call(this);\n      this._events.dispose();\n      return this;\n    }\n  }, {\n    key: \"defaultValue\",\n    get: function get() {\n      return this._toType(this._param.defaultValue);\n    }\n    //-------------------------------------\n    // \tAUTOMATION CURVE CALCULATIONS\n    // \tMIT License, copyright (c) 2014 Jordan Santell\n    //-------------------------------------\n    // Calculates the the value along the curve produced by setTargetAtTime\n  }, {\n    key: \"_exponentialApproach\",\n    value: function _exponentialApproach(t0, v0, v1, timeConstant, t) {\n      return v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n    }\n    // Calculates the the value along the curve produced by linearRampToValueAtTime\n  }, {\n    key: \"_linearInterpolate\",\n    value: function _linearInterpolate(t0, v0, t1, v1, t) {\n      return v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n    }\n    // Calculates the the value along the curve produced by exponentialRampToValueAtTime\n  }, {\n    key: \"_exponentialInterpolate\",\n    value: function _exponentialInterpolate(t0, v0, t1, v1, t) {\n      return v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        convert: true,\n        units: \"number\"\n      });\n    }\n  }]);\n  return Param;\n}(ToneWithContext);","map":{"version":3,"mappings":";;;;;;AACA,SAASA,QAAQ,EAAEC,QAAQ,QAAQ,qBAAqB;AAExD,SAASC,YAAY,QAAQ,2BAA2B;AACxD,SAASC,oBAAoB,QAAQ,kBAAkB;AACvD,SAASC,QAAQ,QAAQ,kBAAkB;AAC3C,SAASC,SAAS,QAAQ,mBAAmB;AAC7C,SAASC,eAAe,QAAgC,mBAAmB;AAC3E,SAASC,EAAE,QAAQ,cAAc;AACjC,SAASC,MAAM,EAAEC,WAAW,QAAQ,eAAe;AAkCnD;;;;;;;AAOA,WAAaC,KACZ;EAAA;EAAA;EAkDA;IAAA;IAAA;IACC,0BAAMP,oBAAoB,CAACO,KAAK,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IAhDjF,UAAI,GAAW,OAAO;IAM/B,gBAAU,GAAG,KAAK;IAiBlB;;;IAGQ,gBAAU,GAAG,IAAI;IAwBxB,IAAMC,OAAO,GAAGV,oBAAoB,CAACO,KAAK,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,EAAE,OAAO,EAAE,SAAS,CAAC,CAAC;IAEnGJ,MAAM,CAACH,SAAS,CAACQ,OAAO,CAACC,KAAK,CAAC,KAC7BZ,YAAY,CAACW,OAAO,CAACC,KAAK,CAAC,IAAID,OAAO,CAACC,KAAK,YAAYJ,KAAK,CAAC,EAAE,6BAA6B,CAAC;IAEhG,OAAO,CAACR,YAAY,CAACW,OAAO,CAACC,KAAK,CAAC,EAAE;MACpCD,OAAO,CAACC,KAAK,GAAGD,OAAO,CAACC,KAAK,CAACC,MAAM;;IAGrC,MAAKC,UAAU,GAAGX,SAAS,CAACQ,OAAO,CAACI,SAAS,CAAC,GAAGJ,OAAO,CAACI,SAAS,GAAG,KAAK;IAC1E,IAAI,MAAKD,UAAU,EAAE;MACpB,MAAKE,KAAK,GAAG,MAAKC,OAAO,CAACC,UAAU,EAAE;MACtC;MACA,MAAKL,MAAM,GAAGF,OAAO,CAACC,KAAK;MAC3B,MAAKI,KAAK,CAACG,OAAO,CAAC,MAAKN,MAAM,CAAC;KAC/B,MAAM;MACN,MAAKA,MAAM,GAAG,MAAKG,KAAK,GAAGL,OAAO,CAACC,KAAK;;IAEzC,MAAKQ,OAAO,GAAG,IAAIlB,QAAQ,CAAkB,IAAI,CAAC;IAClD,MAAKmB,aAAa,GAAG,MAAKR,MAAM,CAACS,YAAY;IAC7C,MAAKC,KAAK,GAAGZ,OAAO,CAACY,KAAK;IAC1B,MAAKC,OAAO,GAAGb,OAAO,CAACa,OAAO;IAC9B,MAAKC,SAAS,GAAGd,OAAO,CAACe,QAAQ;IACjC,MAAKC,SAAS,GAAGhB,OAAO,CAACiB,QAAQ;IAEjC;IACA,IAAIzB,SAAS,CAACQ,OAAO,CAACkB,KAAK,CAAC,IAAIlB,OAAO,CAACkB,KAAK,KAAK,MAAKC,OAAO,CAAC,MAAKT,aAAa,CAAC,EAAE;MACnF,MAAKU,cAAc,CAACpB,OAAO,CAACkB,KAAK,EAAE,CAAC,CAAC;;IACrC;EACF;EAAC;IAAA;IAAA,KASD,eAAS;MACR,IAAMG,GAAG,GAAG,IAAI,CAACA,GAAG,EAAE;MACtB,OAAO,IAAI,CAACC,cAAc,CAACD,GAAG,CAAC;IAChC,CAAC;IAAA,KACD,aAAUH,KAAK;MACd,IAAI,CAACK,qBAAqB,CAAC,IAAI,CAACF,GAAG,EAAE,CAAC;MACtC,IAAI,CAACD,cAAc,CAACF,KAAK,EAAE,IAAI,CAACG,GAAG,EAAE,CAAC;IACvC;EAAC;IAAA;IAAA,KAED,eAAY;MACX;MACA,IAAI7B,SAAS,CAAC,IAAI,CAACsB,SAAS,CAAC,EAAE;QAC9B,OAAO,IAAI,CAACA,SAAS;OACrB,MAAM,IAAI,IAAI,CAACF,KAAK,KAAK,MAAM,IAAI,IAAI,CAACA,KAAK,KAAK,WAAW,IAC7D,IAAI,CAACA,KAAK,KAAK,aAAa,IAAI,IAAI,CAACA,KAAK,KAAK,UAAU,IACzD,IAAI,CAACA,KAAK,KAAK,eAAe,IAAI,IAAI,CAACA,KAAK,KAAK,OAAO,IACxD,IAAI,CAACA,KAAK,KAAK,KAAK,IAAI,IAAI,CAACA,KAAK,KAAK,OAAO,IAAI,IAAI,CAACA,KAAK,KAAK,SAAS,EAAE;QAC5E,OAAO,CAAC;OACR,MAAM,IAAI,IAAI,CAACA,KAAK,KAAK,YAAY,EAAE;QACvC,OAAO,CAAC,CAAC;OACT,MAAM,IAAI,IAAI,CAACA,KAAK,KAAK,UAAU,EAAE;QACrC,OAAO,CAACY,QAAQ;OAChB,MAAM;QACN,OAAO,IAAI,CAACtB,MAAM,CAACa,QAAQ;;IAE7B;EAAC;IAAA;IAAA,KAED,eAAY;MACX,IAAIvB,SAAS,CAAC,IAAI,CAACwB,SAAS,CAAC,EAAE;QAC9B,OAAO,IAAI,CAACA,SAAS;OACrB,MAAM,IAAI,IAAI,CAACJ,KAAK,KAAK,aAAa,IACtC,IAAI,CAACA,KAAK,KAAK,YAAY,EAAE;QAC7B,OAAO,CAAC;OACR,MAAM;QACN,OAAO,IAAI,CAACV,MAAM,CAACe,QAAQ;;IAE7B;IAEA;;;EAAA;IAAA;IAAA,OAGQ,aAAOQ,GAAQ,EAAEC,IAAc;MACtC,OAAO,IAAI,CAACd,KAAK,KAAKc,IAAI;IAC3B;IAEA;;;EAAA;IAAA;IAAA,OAGQ,sBAAaR,KAAa;MACjC,IAAI1B,SAAS,CAAC,IAAI,CAACyB,QAAQ,CAAC,IAAIzB,SAAS,CAAC,IAAI,CAACuB,QAAQ,CAAC,EAAE;QACzDnB,WAAW,CAACsB,KAAK,EAAE,IAAI,CAACS,SAAS,CAAC,IAAI,CAACZ,QAAQ,CAAC,EAAE,IAAI,CAACY,SAAS,CAAC,IAAI,CAACV,QAAQ,CAAC,CAAC;;MAEjF,OAAOC,KAAK;IACb;IAEA;;;;EAAA;IAAA;IAAA,OAIU,mBAAUU,GAAsB;MACzC,IAAI,IAAI,CAACf,OAAO,IAAI,CAAC,IAAI,CAACgB,UAAU,EAAE;QACrC,IAAI,IAAI,CAACC,GAAG,CAAOF,GAAG,EAAE,MAAM,CAAC,EAAE;UAChC,OAAO,IAAI,CAACG,SAAS,CAACH,GAAG,CAAC;SAC1B,MAAM,IAAI,IAAI,CAACE,GAAG,CAAWF,GAAG,EAAE,UAAU,CAAC,EAAE;UAC/C,OAAOzC,QAAQ,CAACyC,GAAG,CAAC;SACpB,MAAM,IAAI,IAAI,CAACE,GAAG,CAAYF,GAAG,EAAE,WAAW,CAAC,EAAE;UACjD,OAAO,IAAI,CAACI,WAAW,CAACJ,GAAG,CAAC;SAC5B,MAAM;UACN,OAAOA,GAAa;;OAErB,MAAM,IAAI,IAAI,CAACC,UAAU,EAAE;QAC3B;QACA,OAAO,CAAC;OACR,MAAM;QACN,OAAOD,GAAa;;IAEtB;IAEA;;;EAAA;IAAA;IAAA,OAGU,iBAAQA,GAAW;MAC5B,IAAI,IAAI,CAACf,OAAO,IAAI,IAAI,CAACD,KAAK,KAAK,UAAU,EAAE;QAC9C,OAAOxB,QAAQ,CAACwC,GAAG,CAAsB;OACzC,MAAM;QACN,OAAOA,GAAwB;;IAEjC;IAEA;IACA;IACA;IACA;EAAA;IAAA;IAAA,OAEA,wBAAeV,KAAwB,EAAEe,IAAU;MAClD,IAAMC,YAAY,GAAG,IAAI,CAACH,SAAS,CAACE,IAAI,CAAC;MACzC,IAAME,YAAY,GAAG,IAAI,CAACR,SAAS,CAACT,KAAK,CAAC;MAC1CvB,MAAM,CAACyC,QAAQ,CAACD,YAAY,CAAC,IAAIC,QAAQ,CAACF,YAAY,CAAC,mDACZG,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC,eAAKmB,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC,EAAG;MAC5F,IAAI,CAACM,YAAY,CAACJ,YAAY,CAAC;MAC/B,IAAI,CAACK,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,gBAAgB,EAAEM,KAAK,EAAEgB,YAAY,CAAC;MAC3D,IAAI,CAACzB,OAAO,CAACgC,GAAG,CAAC;QAChBR,IAAI,EAAEC,YAAY;QAClBR,IAAI,EAAE,gBAAgB;QACtBR,KAAK,EAAEiB;OACP,CAAC;MACF,IAAI,CAACjC,MAAM,CAACkB,cAAc,CAACe,YAAY,EAAED,YAAY,CAAC;MACtD,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,wBAAeD,IAAU;MACxB,IAAMC,YAAY,GAAGQ,IAAI,CAACC,GAAG,CAAC,IAAI,CAACZ,SAAS,CAACE,IAAI,CAAC,EAAE,CAAC,CAAC;MACtD,IAAMW,KAAK,GAAG,IAAI,CAACnC,OAAO,CAACoC,QAAQ,CAACX,YAAY,CAAC;MACjD,IAAMY,MAAM,GAAG,IAAI,CAACrC,OAAO,CAACsC,GAAG,CAACb,YAAY,CAAC;MAC7C,IAAIhB,KAAK,GAAG,IAAI,CAACR,aAAa;MAC9B;MACA,IAAIoC,MAAM,KAAK,IAAI,EAAE;QACpB5B,KAAK,GAAG,IAAI,CAACR,aAAa;OAC1B,MAAM,IAAIoC,MAAM,CAACpB,IAAI,KAAK,iBAAiB,KAAKkB,KAAK,KAAK,IAAI,IAAIA,KAAK,CAAClB,IAAI,KAAK,gBAAgB,CAAC,EAAE;QACpG,IAAMsB,QAAQ,GAAG,IAAI,CAACvC,OAAO,CAACwC,SAAS,CAACH,MAAM,CAACb,IAAI,CAAC;QACpD,IAAIiB,WAAW;QACf,IAAIF,QAAQ,KAAK,IAAI,EAAE;UACtBE,WAAW,GAAG,IAAI,CAACxC,aAAa;SAChC,MAAM;UACNwC,WAAW,GAAGF,QAAQ,CAAC9B,KAAK;;QAE7B,IAAI4B,MAAM,CAACpB,IAAI,KAAK,iBAAiB,EAAE;UACtCR,KAAK,GAAG,IAAI,CAACiC,oBAAoB,CAACL,MAAM,CAACb,IAAI,EAAEiB,WAAW,EAAEJ,MAAM,CAAC5B,KAAK,EAAE4B,MAAM,CAACM,QAAQ,EAAElB,YAAY,CAAC;;OAEzG,MAAM,IAAIU,KAAK,KAAK,IAAI,EAAE;QAC1B1B,KAAK,GAAG4B,MAAM,CAAC5B,KAAK;OACpB,MAAM,IAAI0B,KAAK,CAAClB,IAAI,KAAK,yBAAyB,IAAIkB,KAAK,CAAClB,IAAI,KAAK,8BAA8B,EAAE;QACrG,IAAI2B,WAAW,GAAGP,MAAM,CAAC5B,KAAK;QAC9B,IAAI4B,MAAM,CAACpB,IAAI,KAAK,iBAAiB,EAAE;UACtC,IAAMsB,SAAQ,GAAG,IAAI,CAACvC,OAAO,CAACwC,SAAS,CAACH,MAAM,CAACb,IAAI,CAAC;UACpD,IAAIe,SAAQ,KAAK,IAAI,EAAE;YACtBK,WAAW,GAAG,IAAI,CAAC3C,aAAa;WAChC,MAAM;YACN2C,WAAW,GAAGL,SAAQ,CAAC9B,KAAK;;;QAG9B,IAAI0B,KAAK,CAAClB,IAAI,KAAK,yBAAyB,EAAE;UAC7CR,KAAK,GAAG,IAAI,CAACoC,kBAAkB,CAACR,MAAM,CAACb,IAAI,EAAEoB,WAAW,EAAET,KAAK,CAACX,IAAI,EAAEW,KAAK,CAAC1B,KAAK,EAAEgB,YAAY,CAAC;SAChG,MAAM;UACNhB,KAAK,GAAG,IAAI,CAACqC,uBAAuB,CAACT,MAAM,CAACb,IAAI,EAAEoB,WAAW,EAAET,KAAK,CAACX,IAAI,EAAEW,KAAK,CAAC1B,KAAK,EAAEgB,YAAY,CAAC;;OAEtG,MAAM;QACNhB,KAAK,GAAG4B,MAAM,CAAC5B,KAAK;;MAErB,OAAO,IAAI,CAACC,OAAO,CAACD,KAAK,CAAC;IAC3B;EAAC;IAAA;IAAA,OAED,sBAAae,IAAU;MACtBA,IAAI,GAAG,IAAI,CAACF,SAAS,CAACE,IAAI,CAAC;MAC3B,IAAIuB,UAAU,GAAG,IAAI,CAAClC,cAAc,CAACW,IAAI,CAAC;MAC1C,IAAI,CAACwB,mBAAmB,CAACxB,IAAI,CAAC;MAC9B,IAAI,IAAI,CAACN,SAAS,CAAC6B,UAAU,CAAC,KAAK,CAAC,EAAE;QACrCA,UAAU,GAAG,IAAI,CAACrC,OAAO,CAAC,IAAI,CAACuC,UAAU,CAAC;;MAE3C,IAAI,CAACtC,cAAc,CAACoC,UAAU,EAAEvB,IAAI,CAAC;MACrC,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,iCAAwBf,KAAwB,EAAEyC,OAAa;MAC9D,IAAMxB,YAAY,GAAG,IAAI,CAACR,SAAS,CAACT,KAAK,CAAC;MAC1C,IAAMgB,YAAY,GAAG,IAAI,CAACH,SAAS,CAAC4B,OAAO,CAAC;MAC5ChE,MAAM,CAACyC,QAAQ,CAACD,YAAY,CAAC,IAAIC,QAAQ,CAACF,YAAY,CAAC,4DACHG,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC,eAAKmB,IAAI,CAACC,SAAS,CAACqB,OAAO,CAAC,EAAG;MACxG,IAAI,CAACpB,YAAY,CAACJ,YAAY,CAAC;MAC/B,IAAI,CAAC1B,OAAO,CAACgC,GAAG,CAAC;QAChBR,IAAI,EAAEC,YAAY;QAClBR,IAAI,EAAE,yBAAyB;QAC/BR,KAAK,EAAEiB;OACP,CAAC;MACF,IAAI,CAACK,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,yBAAyB,EAAEM,KAAK,EAAEgB,YAAY,CAAC;MACpE,IAAI,CAAChC,MAAM,CAAC0D,uBAAuB,CAACzB,YAAY,EAAED,YAAY,CAAC;MAC/D,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,sCAA6BhB,KAAwB,EAAEyC,OAAa;MACnE,IAAIxB,YAAY,GAAG,IAAI,CAACR,SAAS,CAACT,KAAK,CAAC;MACxC;MACAiB,YAAY,GAAGzC,EAAE,CAACyC,YAAY,EAAE,CAAC,CAAC,GAAG,IAAI,CAACuB,UAAU,GAAGvB,YAAY;MACnE,IAAI,CAACI,YAAY,CAACJ,YAAY,CAAC;MAC/B,IAAMD,YAAY,GAAG,IAAI,CAACH,SAAS,CAAC4B,OAAO,CAAC;MAC5ChE,MAAM,CAACyC,QAAQ,CAACD,YAAY,CAAC,IAAIC,QAAQ,CAACF,YAAY,CAAC,iEACEG,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC,eAAKmB,IAAI,CAACC,SAAS,CAACqB,OAAO,CAAC,EAAG;MAC7G;MACA,IAAI,CAAClD,OAAO,CAACgC,GAAG,CAAC;QAChBR,IAAI,EAAEC,YAAY;QAClBR,IAAI,EAAE,8BAA8B;QACpCR,KAAK,EAAEiB;OACP,CAAC;MACF,IAAI,CAACK,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,8BAA8B,EAAEM,KAAK,EAAEgB,YAAY,CAAC;MACzE,IAAI,CAAChC,MAAM,CAAC2D,4BAA4B,CAAC1B,YAAY,EAAED,YAAY,CAAC;MACpE,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,2BAAkBhB,KAAwB,EAAE4C,QAAc,EAAEC,SAAgB;MAC3EA,SAAS,GAAG,IAAI,CAAChC,SAAS,CAACgC,SAAS,CAAC;MACrC,IAAI,CAACC,YAAY,CAACD,SAAS,CAAC;MAC5B,IAAI,CAACF,4BAA4B,CAAC3C,KAAK,EAAE6C,SAAS,GAAG,IAAI,CAAChC,SAAS,CAAC+B,QAAQ,CAAC,CAAC;MAC9E,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,sBAAa5C,KAAwB,EAAE4C,QAAc,EAAEC,SAAgB;MACtEA,SAAS,GAAG,IAAI,CAAChC,SAAS,CAACgC,SAAS,CAAC;MACrC,IAAI,CAACC,YAAY,CAACD,SAAS,CAAC;MAC5B,IAAI,CAACH,uBAAuB,CAAC1C,KAAK,EAAE6C,SAAS,GAAG,IAAI,CAAChC,SAAS,CAAC+B,QAAQ,CAAC,CAAC;MACzE,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,sBAAa5C,KAAwB,EAAE4C,QAAc,EAAEC,SAAgB;MACtEA,SAAS,GAAG,IAAI,CAAChC,SAAS,CAACgC,SAAS,CAAC;MACrC,IAAI,CAACC,YAAY,CAACD,SAAS,CAAC;MAC5B,IAAI,CAACE,8BAA8B,CAAC/C,KAAK,EAAE6C,SAAS,EAAED,QAAQ,CAAC;MAC/D,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,wCAA+B5C,KAAwB,EAAEe,IAAU,EAAE6B,QAAc;MAClF7B,IAAI,GAAG,IAAI,CAACF,SAAS,CAACE,IAAI,CAAC;MAC3B6B,QAAQ,GAAG,IAAI,CAAC/B,SAAS,CAAC+B,QAAQ,CAAC;MACnC,IAAMI,YAAY,GAAGxB,IAAI,CAACF,GAAG,CAACsB,QAAQ,GAAG,CAAC,CAAC,GAAGpB,IAAI,CAACF,GAAG,CAAC,GAAG,CAAC;MAC3D,IAAI,CAAC2B,eAAe,CAACjD,KAAK,EAAEe,IAAI,EAAEiC,YAAY,CAAC;MAC/C;MACA,IAAI,CAACT,mBAAmB,CAACxB,IAAI,GAAG6B,QAAQ,GAAG,GAAG,CAAC;MAC/C,IAAI,CAACF,uBAAuB,CAAC1C,KAAK,EAAEe,IAAI,GAAG6B,QAAQ,CAAC;MACpD,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,yBAAgB5C,KAAwB,EAAE6C,SAAe,EAAEG,YAAsB;MAChF,IAAM/B,YAAY,GAAG,IAAI,CAACR,SAAS,CAACT,KAAK,CAAC;MAC1C;MACAvB,MAAM,CAACyC,QAAQ,CAAC8B,YAAY,CAAC,IAAIA,YAAY,GAAG,CAAC,EAAE,8CAA8C,CAAC;MAClG,IAAMhC,YAAY,GAAG,IAAI,CAACH,SAAS,CAACgC,SAAS,CAAC;MAC9C,IAAI,CAACxB,YAAY,CAACJ,YAAY,CAAC;MAC/BxC,MAAM,CAACyC,QAAQ,CAACD,YAAY,CAAC,IAAIC,QAAQ,CAACF,YAAY,CAAC,oDACXG,IAAI,CAACC,SAAS,CAACpB,KAAK,CAAC,eAAKmB,IAAI,CAACC,SAAS,CAACyB,SAAS,CAAC,EAAG;MAClG,IAAI,CAACtD,OAAO,CAACgC,GAAG,CAAC;QAChBW,QAAQ,EAAEc,YAAY;QACtBjC,IAAI,EAAEC,YAAY;QAClBR,IAAI,EAAE,iBAAiB;QACvBR,KAAK,EAAEiB;OACP,CAAC;MACF,IAAI,CAACK,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,iBAAiB,EAAEM,KAAK,EAAEgB,YAAY,EAAEgC,YAAY,CAAC;MAC1E,IAAI,CAAChE,MAAM,CAACiE,eAAe,CAAChC,YAAY,EAAED,YAAY,EAAEgC,YAAY,CAAC;MACrE,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,6BAAoBE,MAA2B,EAAEL,SAAe,EAAEM,QAAc,EAAa;MAAA,IAAXC,OAAO,uEAAG,CAAC;MAC5FD,QAAQ,GAAG,IAAI,CAACtC,SAAS,CAACsC,QAAQ,CAAC;MACnCN,SAAS,GAAG,IAAI,CAAChC,SAAS,CAACgC,SAAS,CAAC;MACrC,IAAMQ,aAAa,GAAG,IAAI,CAAC5C,SAAS,CAACyC,MAAM,CAAC,CAAC,CAAC,CAAC,GAAGE,OAAO;MACzD,IAAI,CAAClD,cAAc,CAAC,IAAI,CAACD,OAAO,CAACoD,aAAa,CAAC,EAAER,SAAS,CAAC;MAC3D,IAAMS,OAAO,GAAGH,QAAQ,IAAID,MAAM,CAACK,MAAM,GAAG,CAAC,CAAC;MAC9C,KAAK,IAAIC,CAAC,GAAG,CAAC,EAAEA,CAAC,GAAGN,MAAM,CAACK,MAAM,EAAEC,CAAC,EAAE,EAAE;QACvC,IAAMvC,YAAY,GAAG,IAAI,CAACR,SAAS,CAACyC,MAAM,CAACM,CAAC,CAAC,CAAC,GAAGJ,OAAO;QACxD,IAAI,CAACV,uBAAuB,CAAC,IAAI,CAACzC,OAAO,CAACgB,YAAY,CAAC,EAAE4B,SAAS,GAAGW,CAAC,GAAGF,OAAO,CAAC;;MAElF,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,+BAAsBvC,IAAU;MAC/B,IAAMC,YAAY,GAAG,IAAI,CAACH,SAAS,CAACE,IAAI,CAAC;MACzCtC,MAAM,CAACyC,QAAQ,CAACF,YAAY,CAAC,uDAAgDG,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC,EAAG;MACpG,IAAI,CAACxB,OAAO,CAACkE,MAAM,CAACzC,YAAY,CAAC;MACjC,IAAI,CAAChC,MAAM,CAACqB,qBAAqB,CAACW,YAAY,CAAC;MAC/C,IAAI,CAACM,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,uBAAuB,EAAEsB,YAAY,CAAC;MAC3D,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,6BAAoBD,IAAU;MAC7B,IAAMC,YAAY,GAAG,IAAI,CAACH,SAAS,CAACE,IAAI,CAAC;MACzC,IAAM2C,WAAW,GAAG,IAAI,CAACjD,SAAS,CAAC,IAAI,CAACL,cAAc,CAACY,YAAY,CAAC,CAAC;MACrE;MACAvC,MAAM,CAACyC,QAAQ,CAACF,YAAY,CAAC,qDAA8CG,IAAI,CAACC,SAAS,CAACL,IAAI,CAAC,EAAG;MAElG,IAAI,CAACO,GAAG,CAAC,IAAI,CAAC5B,KAAK,EAAE,qBAAqB,EAAEsB,YAAY,EAAE,QAAQ,GAAG0C,WAAW,CAAC;MAEjF;MACA;MACA,IAAM9B,MAAM,GAAG,IAAI,CAACrC,OAAO,CAACsC,GAAG,CAACb,YAAY,CAAC;MAC7C,IAAMU,KAAK,GAAG,IAAI,CAACnC,OAAO,CAACoC,QAAQ,CAACX,YAAY,CAAC;MACjD,IAAIY,MAAM,IAAIpD,EAAE,CAACoD,MAAM,CAACb,IAAI,EAAEC,YAAY,CAAC,EAAE;QAC5C;QACA,IAAIU,KAAK,EAAE;UACV,IAAI,CAAC1C,MAAM,CAACqB,qBAAqB,CAACqB,KAAK,CAACX,IAAI,CAAC;UAC7C,IAAI,CAACxB,OAAO,CAACkE,MAAM,CAAC/B,KAAK,CAACX,IAAI,CAAC;SAC/B,MAAM;UACN,IAAI,CAAC/B,MAAM,CAACuD,mBAAmB,CAACvB,YAAY,CAAC;UAC7C,IAAI,CAACzB,OAAO,CAACkE,MAAM,CAACzC,YAAY,GAAG,IAAI,CAAC2C,UAAU,CAAC;;OAEpD,MAAM,IAAIjC,KAAK,EAAE;QACjB,IAAI,CAAC1C,MAAM,CAACqB,qBAAqB,CAACqB,KAAK,CAACX,IAAI,CAAC;QAC7C;QACA,IAAI,CAACxB,OAAO,CAACkE,MAAM,CAAC/B,KAAK,CAACX,IAAI,CAAC;QAC/B,IAAIW,KAAK,CAAClB,IAAI,KAAK,yBAAyB,EAAE;UAC7C,IAAI,CAACkC,uBAAuB,CAAC,IAAI,CAACzC,OAAO,CAACyD,WAAW,CAAC,EAAE1C,YAAY,CAAC;SACrE,MAAM,IAAIU,KAAK,CAAClB,IAAI,KAAK,8BAA8B,EAAE;UACzD,IAAI,CAACmC,4BAA4B,CAAC,IAAI,CAAC1C,OAAO,CAACyD,WAAW,CAAC,EAAE1C,YAAY,CAAC;;;MAI5E;MACA,IAAI,CAACzB,OAAO,CAACgC,GAAG,CAAC;QAChBR,IAAI,EAAEC,YAAY;QAClBR,IAAI,EAAE,gBAAgB;QACtBR,KAAK,EAAE0D;OACP,CAAC;MACF,IAAI,CAAC1E,MAAM,CAACkB,cAAc,CAACwD,WAAW,EAAE1C,YAAY,CAAC;MACrD,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,gBAAOhB,KAAwB,EAAwC;MAAA,IAAtC4C,+EAAiB,GAAG;MAAA,IAAEC,SAAgB;MACtE,IAAI,IAAI,CAACnD,KAAK,KAAK,WAAW,IAAI,IAAI,CAACA,KAAK,KAAK,KAAK,IAAI,IAAI,CAACA,KAAK,KAAK,UAAU,EAAE;QACpF,IAAI,CAACkE,iBAAiB,CAAC5D,KAAK,EAAE4C,QAAQ,EAAEC,SAAS,CAAC;OAClD,MAAM;QACN,IAAI,CAACgB,YAAY,CAAC7D,KAAK,EAAE4C,QAAQ,EAAEC,SAAS,CAAC;;MAE9C,OAAO,IAAI;IACZ;IAEA;;;;;EAAA;IAAA;IAAA,OAKA,eAAM9D,KAAyB;MAC9B,IAAMoB,GAAG,GAAG,IAAI,CAACf,OAAO,CAAC0E,WAAW;MACpC;MACA/E,KAAK,CAACmB,cAAc,CAAC,IAAI,CAACE,cAAc,CAACD,GAAG,CAAW,EAAEA,GAAG,CAAC;MAC7D;MACA,IAAM4D,aAAa,GAAG,IAAI,CAACxE,OAAO,CAACsC,GAAG,CAAC1B,GAAG,CAAC;MAC3C,IAAI4D,aAAa,IAAIA,aAAa,CAACvD,IAAI,KAAK,iBAAiB,EAAE;QAC9D;QACA,IAAMwD,SAAS,GAAG,IAAI,CAACzE,OAAO,CAACoC,QAAQ,CAACoC,aAAa,CAAChD,IAAI,CAAC;QAC3D;QACA,IAAM0B,OAAO,GAAGuB,SAAS,GAAGA,SAAS,CAACjD,IAAI,GAAGZ,GAAG,GAAG,CAAC;QACpD,IAAM8D,YAAY,GAAG,CAACxB,OAAO,GAAGtC,GAAG,IAAI,EAAE;QACzC,KAAK,IAAIqD,CAAC,GAAGrD,GAAG,EAAEqD,CAAC,GAAGf,OAAO,EAAEe,CAAC,IAAIS,YAAY,EAAE;UACjDlF,KAAK,CAAC2D,uBAAuB,CAAC,IAAI,CAACtC,cAAc,CAACoD,CAAC,CAAW,EAAEA,CAAC,CAAC;;;MAGpE,IAAI,CAACjE,OAAO,CAAC2E,YAAY,CAAC,IAAI,CAAC9E,OAAO,CAAC0E,WAAW,EAAE,eAAK,EAAG;QAC3D,IAAIK,KAAK,CAAC3D,IAAI,KAAK,uBAAuB,EAAE;UAC3CzB,KAAK,CAACsB,qBAAqB,CAAC8D,KAAK,CAACpD,IAAI,CAAC;SACvC,MAAM,IAAIoD,KAAK,CAAC3D,IAAI,KAAK,iBAAiB,EAAE;UAC5CzB,KAAK,CAACkE,eAAe,CAACkB,KAAK,CAACnE,KAAK,EAAEmE,KAAK,CAACpD,IAAI,EAAEoD,KAAK,CAACjC,QAAQ,CAAC;SAC9D,MAAM;UACNnD,KAAK,CAACoF,KAAK,CAAC3D,IAAI,CAAC,CAAC2D,KAAK,CAACnE,KAAK,EAAEmE,KAAK,CAACpD,IAAI,CAAC;;MAE5C,CAAC,CAAC;MACF,OAAO,IAAI;IACZ;IAEA;;;;EAAA;IAAA;IAAA,OAIA,kBAAShC,KAAiB;MACzBN,MAAM,CAAC,IAAI,CAACQ,UAAU,EAAE,8DAA8D,CAAC;MACvF,IAAME,KAAK,GAAG,IAAI,CAACA,KAAiB;MACpCA,KAAK,CAACiF,UAAU,CAAC,IAAI,CAACpF,MAAM,CAAC;MAC7B,IAAI,CAACqF,KAAK,CAACtF,KAAK,CAAC;MACjB,IAAI,CAACC,MAAM,GAAGD,KAAK;MACnBI,KAAK,CAACG,OAAO,CAAC,IAAI,CAACN,MAAM,CAAC;MAC1B,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAED,mBAAO;MACN;MACA,IAAI,CAACO,OAAO,CAAC+E,OAAO,EAAE;MACtB,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,KAED,eAAgB;MACf,OAAO,IAAI,CAACrE,OAAO,CAAC,IAAI,CAACjB,MAAM,CAACS,YAAY,CAAC;IAC9C;IAEA;IACA;IACA;IACA;IAEA;EAAA;IAAA;IAAA,OACU,8BAAqB8E,EAAU,EAAEC,EAAU,EAAEC,EAAU,EAAEzB,YAAoB,EAAE0B,CAAS;MACjG,OAAOD,EAAE,GAAG,CAACD,EAAE,GAAGC,EAAE,IAAIjD,IAAI,CAACmD,GAAG,CAAC,EAAED,CAAC,GAAGH,EAAE,CAAC,GAAGvB,YAAY,CAAC;IAC3D;IAEA;EAAA;IAAA;IAAA,OACU,4BAAmBuB,EAAU,EAAEC,EAAU,EAAEI,EAAU,EAAEH,EAAU,EAAEC,CAAS;MACrF,OAAOF,EAAE,GAAG,CAACC,EAAE,GAAGD,EAAE,KAAK,CAACE,CAAC,GAAGH,EAAE,KAAKK,EAAE,GAAGL,EAAE,CAAC,CAAC;IAC/C;IAEA;EAAA;IAAA;IAAA,OACU,iCAAwBA,EAAU,EAAEC,EAAU,EAAEI,EAAU,EAAEH,EAAU,EAAEC,CAAS;MAC1F,OAAOF,EAAE,GAAGhD,IAAI,CAACqD,GAAG,CAACJ,EAAE,GAAGD,EAAE,EAAE,CAACE,CAAC,GAAGH,EAAE,KAAKK,EAAE,GAAGL,EAAE,CAAC,CAAC;IACpD;EAAC;IAAA;IAAA,OApZD,uBAAkB;MACjB,OAAOO,MAAM,CAACC,MAAM,CAACxG,eAAe,CAACK,WAAW,EAAE,EAAE;QACnDe,OAAO,EAAE,IAAI;QACbD,KAAK,EAAE;OACc,CAAC;IACxB;EAAC;EAAA;AAAA,EAzFOnB,eAAuC","names":["dbToGain","gainToDb","isAudioParam","optionsFromArguments","Timeline","isDefined","ToneWithContext","EQ","assert","assertRange","Param","getDefaults","arguments","options","param","_param","_swappable","swappable","input","context","createGain","connect","_events","_initialValue","defaultValue","units","convert","_minValue","minValue","_maxValue","maxValue","value","_toType","setValueAtTime","now","getValueAtTime","cancelScheduledValues","Infinity","arg","type","_fromType","val","overridden","_is","toSeconds","toFrequency","time","computedTime","numericValue","isFinite","JSON","stringify","_assertRange","log","add","Math","max","after","getAfter","before","get","previous","getBefore","previousVal","_exponentialApproach","constant","beforeValue","_linearInterpolate","_exponentialInterpolate","currentVal","cancelAndHoldAtTime","_minOutput","endTime","linearRampToValueAtTime","exponentialRampToValueAtTime","rampTime","startTime","setRampPoint","exponentialApproachValueAtTime","timeConstant","setTargetAtTime","values","duration","scaling","startingValue","segTime","length","i","cancel","valueAtTime","sampleTime","exponentialRampTo","linearRampTo","currentTime","previousEvent","nextEvent","subdivisions","forEachAfter","event","disconnect","apply","dispose","t0","v0","v1","t","exp","t1","pow","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\context\\Param.ts"],"sourcesContent":["import { AbstractParam } from \"../context/AbstractParam\";\nimport { dbToGain, gainToDb } from \"../type/Conversions\";\nimport { Decibels, Frequency, Positive, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { isAudioParam } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { ToneWithContext, ToneWithContextOptions } from \"./ToneWithContext\";\nimport { EQ } from \"../util/Math\";\nimport { assert, assertRange } from \"../util/Debug\";\n\nexport interface ParamOptions<TypeName extends UnitName> extends ToneWithContextOptions {\n\tunits: TypeName;\n\tvalue?: UnitMap[TypeName];\n\tparam: AudioParam | Param<TypeName>;\n\tconvert: boolean;\n\tminValue?: number;\n\tmaxValue?: number;\n\tswappable?: boolean;\n}\n\n/**\n * the possible automation types\n */\ntype AutomationType = \"linearRampToValueAtTime\" | \"exponentialRampToValueAtTime\" | \"setValueAtTime\" | \"setTargetAtTime\" | \"cancelScheduledValues\";\n\ninterface TargetAutomationEvent {\n\ttype: \"setTargetAtTime\";\n\ttime: number;\n\tvalue: number;\n\tconstant: number;\n}\n\ninterface NormalAutomationEvent {\n\ttype: Exclude<AutomationType, \"setTargetAtTime\">;\n\ttime: number;\n\tvalue: number;\n}\n/**\n * The events on the automation\n */\nexport type AutomationEvent = NormalAutomationEvent | TargetAutomationEvent;\n\n/**\n * Param wraps the native Web Audio's AudioParam to provide\n * additional unit conversion functionality. It also\n * serves as a base-class for classes which have a single,\n * automatable parameter.\n * @category Core\n */\nexport class Param<TypeName extends UnitName = \"number\">\n\textends ToneWithContext<ParamOptions<TypeName>>\n\timplements AbstractParam<TypeName> {\n\n\treadonly name: string = \"Param\";\n\n\treadonly input: GainNode | AudioParam;\n\n\treadonly units: UnitName;\n\tconvert: boolean;\n\toverridden = false;\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<AutomationEvent>;\n\n\t/**\n\t * The native parameter to control\n\t */\n\tprotected _param: AudioParam;\n\n\t/**\n\t * The default value before anything is assigned\n\t */\n\tprotected _initialValue: number;\n\n\t/**\n\t * The minimum output value\n\t */\n\tprivate _minOutput = 1e-7;\n\n\t/**\n\t * Private reference to the min and max values if passed into the constructor\n\t */\n\tprivate readonly _minValue?: number;\n\tprivate readonly _maxValue?: number;\n\n\t/**\n\t * If the underlying AudioParam can be swapped out\n\t * using the setParam method. \n\t */\n\tprotected readonly _swappable: boolean;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\tconstructor(param: AudioParam, units?: TypeName, convert?: boolean);\n\tconstructor(options: Partial<ParamOptions<TypeName>>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]));\n\n\t\tconst options = optionsFromArguments(Param.getDefaults(), arguments, [\"param\", \"units\", \"convert\"]);\n\n\t\tassert(isDefined(options.param) &&\n\t\t\t(isAudioParam(options.param) || options.param instanceof Param), \"param must be an AudioParam\");\n\n\t\twhile (!isAudioParam(options.param)) {\n\t\t\toptions.param = options.param._param;\n\t\t}\n\n\t\tthis._swappable = isDefined(options.swappable) ? options.swappable : false;\n\t\tif (this._swappable) {\n\t\t\tthis.input = this.context.createGain();\n\t\t\t// initialize\n\t\t\tthis._param = options.param;\n\t\t\tthis.input.connect(this._param);\n\t\t} else {\n\t\t\tthis._param = this.input = options.param;\n\t\t}\n\t\tthis._events = new Timeline<AutomationEvent>(1000);\n\t\tthis._initialValue = this._param.defaultValue;\n\t\tthis.units = options.units;\n\t\tthis.convert = options.convert;\n\t\tthis._minValue = options.minValue;\n\t\tthis._maxValue = options.maxValue;\n\n\t\t// if the value is defined, set it immediately\n\t\tif (isDefined(options.value) && options.value !== this._toType(this._initialValue)) {\n\t\t\tthis.setValueAtTime(options.value, 0);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ParamOptions<any> {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tconvert: true,\n\t\t\tunits: \"number\" as UnitName,\n\t\t} as ParamOptions<any>);\n\t}\n\n\tget value(): UnitMap[TypeName] {\n\t\tconst now = this.now();\n\t\treturn this.getValueAtTime(now);\n\t}\n\tset value(value) {\n\t\tthis.cancelScheduledValues(this.now());\n\t\tthis.setValueAtTime(value, this.now());\n\t}\n\n\tget minValue(): number {\n\t\t// if it's not the default minValue, return it\n\t\tif (isDefined(this._minValue)) {\n\t\t\treturn this._minValue;\n\t\t} else if (this.units === \"time\" || this.units === \"frequency\" ||\n\t\t\tthis.units === \"normalRange\" || this.units === \"positive\" ||\n\t\t\tthis.units === \"transportTime\" || this.units === \"ticks\" ||\n\t\t\tthis.units === \"bpm\" || this.units === \"hertz\" || this.units === \"samples\") {\n\t\t\treturn 0;\n\t\t} else if (this.units === \"audioRange\") {\n\t\t\treturn -1;\n\t\t} else if (this.units === \"decibels\") {\n\t\t\treturn -Infinity;\n\t\t} else {\n\t\t\treturn this._param.minValue;\n\t\t}\n\t}\n\n\tget maxValue(): number {\n\t\tif (isDefined(this._maxValue)) {\n\t\t\treturn this._maxValue;\n\t\t} else if (this.units === \"normalRange\" ||\n\t\t\tthis.units === \"audioRange\") {\n\t\t\treturn 1;\n\t\t} else {\n\t\t\treturn this._param.maxValue;\n\t\t}\n\t}\n\n\t/**\n\t * Type guard based on the unit name\n\t */\n\tprivate _is<T>(arg: any, type: UnitName): arg is T {\n\t\treturn this.units === type;\n\t}\n\n\t/**\n\t * Make sure the value is always in the defined range\n\t */\n\tprivate _assertRange(value: number): number {\n\t\tif (isDefined(this.maxValue) && isDefined(this.minValue)) {\n\t\t\tassertRange(value, this._fromType(this.minValue), this._fromType(this.maxValue));\n\t\t}\n\t\treturn value;\n\t}\n\n\t/**\n\t * Convert the given value from the type specified by Param.units\n\t * into the destination value (such as Gain or Frequency).\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.convert && !this.overridden) {\n\t\t\tif (this._is<Time>(val, \"time\")) {\n\t\t\t\treturn this.toSeconds(val);\n\t\t\t} else if (this._is<Decibels>(val, \"decibels\")) {\n\t\t\t\treturn dbToGain(val);\n\t\t\t} else if (this._is<Frequency>(val, \"frequency\")) {\n\t\t\t\treturn this.toFrequency(val);\n\t\t\t} else {\n\t\t\t\treturn val as number;\n\t\t\t}\n\t\t} else if (this.overridden) {\n\t\t\t// if it's overridden, should only schedule 0s\n\t\t\treturn 0;\n\t\t} else {\n\t\t\treturn val as number;\n\t\t}\n\t}\n\n\t/**\n\t * Convert the parameters value into the units specified by Param.units.\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.convert && this.units === \"decibels\") {\n\t\t\treturn gainToDb(val) as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn val as UnitMap[TypeName];\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// ABSTRACT PARAM INTERFACE\n\t// all docs are generated from ParamInterface.ts\n\t//-------------------------------------\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst numericValue = this._fromType(value);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(time)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis.log(this.units, \"setValueAtTime\", value, computedTime);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis._param.setValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\tgetValueAtTime(time: Time): UnitMap[TypeName] {\n\t\tconst computedTime = Math.max(this.toSeconds(time), 0);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tconst before = this._events.get(computedTime);\n\t\tlet value = this._initialValue;\n\t\t// if it was set by\n\t\tif (before === null) {\n\t\t\tvalue = this._initialValue;\n\t\t} else if (before.type === \"setTargetAtTime\" && (after === null || after.type === \"setValueAtTime\")) {\n\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\tlet previousVal;\n\t\t\tif (previous === null) {\n\t\t\t\tpreviousVal = this._initialValue;\n\t\t\t} else {\n\t\t\t\tpreviousVal = previous.value;\n\t\t\t}\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tvalue = this._exponentialApproach(before.time, previousVal, before.value, before.constant, computedTime);\n\t\t\t}\n\t\t} else if (after === null) {\n\t\t\tvalue = before.value;\n\t\t} else if (after.type === \"linearRampToValueAtTime\" || after.type === \"exponentialRampToValueAtTime\") {\n\t\t\tlet beforeValue = before.value;\n\t\t\tif (before.type === \"setTargetAtTime\") {\n\t\t\t\tconst previous = this._events.getBefore(before.time);\n\t\t\t\tif (previous === null) {\n\t\t\t\t\tbeforeValue = this._initialValue;\n\t\t\t\t} else {\n\t\t\t\t\tbeforeValue = previous.value;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tvalue = this._linearInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t} else {\n\t\t\t\tvalue = this._exponentialInterpolate(before.time, beforeValue, after.time, after.value, computedTime);\n\t\t\t}\n\t\t} else {\n\t\t\tvalue = before.value;\n\t\t}\n\t\treturn this._toType(value);\n\t}\n\n\tsetRampPoint(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tlet currentVal = this.getValueAtTime(time);\n\t\tthis.cancelAndHoldAtTime(time);\n\t\tif (this._fromType(currentVal) === 0) {\n\t\t\tcurrentVal = this._toType(this._minOutput);\n\t\t}\n\t\tthis.setValueAtTime(currentVal, time);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tconst numericValue = this._fromType(value);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to linearRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\tthis._assertRange(numericValue);\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"linearRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"linearRampToValueAtTime\", value, computedTime);\n\t\tthis._param.linearRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], endTime: Time): this {\n\t\tlet numericValue = this._fromType(value);\n\t\t// the value can't be 0\n\t\tnumericValue = EQ(numericValue, 0) ? this._minOutput : numericValue;\n\t\tthis._assertRange(numericValue);\n\t\tconst computedTime = this.toSeconds(endTime);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to exponentialRampToValueAtTime: ${JSON.stringify(value)}, ${JSON.stringify(endTime)}`);\n\t\t// store the event\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"exponentialRampToValueAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"exponentialRampToValueAtTime\", value, computedTime);\n\t\tthis._param.exponentialRampToValueAtTime(numericValue, computedTime);\n\t\treturn this;\n\t}\n\n\texponentialRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\tlinearRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.linearRampToValueAtTime(value, startTime + this.toSeconds(rampTime));\n\t\treturn this;\n\t}\n\n\ttargetRampTo(value: UnitMap[TypeName], rampTime: Time, startTime?: Time): this {\n\t\tstartTime = this.toSeconds(startTime);\n\t\tthis.setRampPoint(startTime);\n\t\tthis.exponentialApproachValueAtTime(value, startTime, rampTime);\n\t\treturn this;\n\t}\n\n\texponentialApproachValueAtTime(value: UnitMap[TypeName], time: Time, rampTime: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\trampTime = this.toSeconds(rampTime);\n\t\tconst timeConstant = Math.log(rampTime + 1) / Math.log(200);\n\t\tthis.setTargetAtTime(value, time, timeConstant);\n\t\t// at 90% start a linear ramp to the final value\n\t\tthis.cancelAndHoldAtTime(time + rampTime * 0.9);\n\t\tthis.linearRampToValueAtTime(value, time + rampTime);\n\t\treturn this;\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], startTime: Time, timeConstant: Positive): this {\n\t\tconst numericValue = this._fromType(value);\n\t\t// The value will never be able to approach without timeConstant > 0.\n\t\tassert(isFinite(timeConstant) && timeConstant > 0, \"timeConstant must be a number greater than 0\");\n\t\tconst computedTime = this.toSeconds(startTime);\n\t\tthis._assertRange(numericValue);\n\t\tassert(isFinite(numericValue) && isFinite(computedTime),\n\t\t\t`Invalid argument(s) to setTargetAtTime: ${JSON.stringify(value)}, ${JSON.stringify(startTime)}`);\n\t\tthis._events.add({\n\t\t\tconstant: timeConstant,\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setTargetAtTime\",\n\t\t\tvalue: numericValue,\n\t\t});\n\t\tthis.log(this.units, \"setTargetAtTime\", value, computedTime, timeConstant);\n\t\tthis._param.setTargetAtTime(numericValue, computedTime, timeConstant);\n\t\treturn this;\n\t}\n\n\tsetValueCurveAtTime(values: UnitMap[TypeName][], startTime: Time, duration: Time, scaling = 1): this {\n\t\tduration = this.toSeconds(duration);\n\t\tstartTime = this.toSeconds(startTime);\n\t\tconst startingValue = this._fromType(values[0]) * scaling;\n\t\tthis.setValueAtTime(this._toType(startingValue), startTime);\n\t\tconst segTime = duration / (values.length - 1);\n\t\tfor (let i = 1; i < values.length; i++) {\n\t\t\tconst numericValue = this._fromType(values[i]) * scaling;\n\t\t\tthis.linearRampToValueAtTime(this._toType(numericValue), startTime + i * segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tcancelScheduledValues(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelScheduledValues: ${JSON.stringify(time)}`);\n\t\tthis._events.cancel(computedTime);\n\t\tthis._param.cancelScheduledValues(computedTime);\n\t\tthis.log(this.units, \"cancelScheduledValues\", computedTime);\n\t\treturn this;\n\t}\n\n\tcancelAndHoldAtTime(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst valueAtTime = this._fromType(this.getValueAtTime(computedTime));\n\t\t// remove the schedule events\n\t\tassert(isFinite(computedTime), `Invalid argument to cancelAndHoldAtTime: ${JSON.stringify(time)}`);\n\n\t\tthis.log(this.units, \"cancelAndHoldAtTime\", computedTime, \"value=\" + valueAtTime);\n\t\t\n\t\t// if there is an event at the given computedTime\n\t\t// and that even is not a \"set\"\n\t\tconst before = this._events.get(computedTime);\n\t\tconst after = this._events.getAfter(computedTime);\n\t\tif (before && EQ(before.time, computedTime)) {\n\t\t\t// remove everything after\n\t\t\tif (after) {\n\t\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t\tthis._events.cancel(after.time);\n\t\t\t} else {\n\t\t\t\tthis._param.cancelAndHoldAtTime(computedTime);\n\t\t\t\tthis._events.cancel(computedTime + this.sampleTime);\n\t\t\t}\n\t\t} else if (after) {\n\t\t\tthis._param.cancelScheduledValues(after.time);\n\t\t\t// cancel the next event(s)\n\t\t\tthis._events.cancel(after.time);\n\t\t\tif (after.type === \"linearRampToValueAtTime\") {\n\t\t\t\tthis.linearRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t} else if (after.type === \"exponentialRampToValueAtTime\") {\n\t\t\t\tthis.exponentialRampToValueAtTime(this._toType(valueAtTime), computedTime);\n\t\t\t}\n\t\t}\n\n\t\t// set the value at the given time\n\t\tthis._events.add({\n\t\t\ttime: computedTime,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: valueAtTime,\n\t\t});\n\t\tthis._param.setValueAtTime(valueAtTime, computedTime);\n\t\treturn this;\n\t}\n\n\trampTo(value: UnitMap[TypeName], rampTime: Time = 0.1, startTime?: Time): this {\n\t\tif (this.units === \"frequency\" || this.units === \"bpm\" || this.units === \"decibels\") {\n\t\t\tthis.exponentialRampTo(value, rampTime, startTime);\n\t\t} else {\n\t\t\tthis.linearRampTo(value, rampTime, startTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Apply all of the previously scheduled events to the passed in Param or AudioParam.\n\t * The applied values will start at the context's current time and schedule\n\t * all of the events which are scheduled on this Param onto the passed in param.\n\t */\n\tapply(param: Param | AudioParam): this {\n\t\tconst now = this.context.currentTime;\n\t\t// set the param's value at the current time and schedule everything else\n\t\tparam.setValueAtTime(this.getValueAtTime(now) as number, now);\n\t\t// if the previous event was a curve, then set the rest of it\n\t\tconst previousEvent = this._events.get(now);\n\t\tif (previousEvent && previousEvent.type === \"setTargetAtTime\") {\n\t\t\t// approx it until the next event with linear ramps\n\t\t\tconst nextEvent = this._events.getAfter(previousEvent.time);\n\t\t\t// or for 2 seconds if there is no event\n\t\t\tconst endTime = nextEvent ? nextEvent.time : now + 2;\n\t\t\tconst subdivisions = (endTime - now) / 10;\n\t\t\tfor (let i = now; i < endTime; i += subdivisions) {\n\t\t\t\tparam.linearRampToValueAtTime(this.getValueAtTime(i) as number, i);\n\t\t\t}\n\t\t}\n\t\tthis._events.forEachAfter(this.context.currentTime, event => {\n\t\t\tif (event.type === \"cancelScheduledValues\") {\n\t\t\t\tparam.cancelScheduledValues(event.time);\n\t\t\t} else if (event.type === \"setTargetAtTime\") {\n\t\t\t\tparam.setTargetAtTime(event.value, event.time, event.constant);\n\t\t\t} else {\n\t\t\t\tparam[event.type](event.value, event.time);\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Replace the Param's internal AudioParam. Will apply scheduled curves \n\t * onto the parameter and replace the connections.\n\t */\n\tsetParam(param: AudioParam): this {\n\t\tassert(this._swappable, \"The Param must be assigned as 'swappable' in the constructor\");\n\t\tconst input = this.input as GainNode;\n\t\tinput.disconnect(this._param);\n\t\tthis.apply(param);\n\t\tthis._param = param;\n\t\tinput.connect(this._param);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\treturn this;\n\t}\n\n\tget defaultValue(): UnitMap[TypeName] {\n\t\treturn this._toType(this._param.defaultValue);\n\t}\n\n\t//-------------------------------------\n\t// \tAUTOMATION CURVE CALCULATIONS\n\t// \tMIT License, copyright (c) 2014 Jordan Santell\n\t//-------------------------------------\n\n\t// Calculates the the value along the curve produced by setTargetAtTime\n\tprotected _exponentialApproach(t0: number, v0: number, v1: number, timeConstant: number, t: number): number {\n\t\treturn v1 + (v0 - v1) * Math.exp(-(t - t0) / timeConstant);\n\t}\n\n\t// Calculates the the value along the curve produced by linearRampToValueAtTime\n\tprotected _linearInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 + (v1 - v0) * ((t - t0) / (t1 - t0));\n\t}\n\n\t// Calculates the the value along the curve produced by exponentialRampToValueAtTime\n\tprotected _exponentialInterpolate(t0: number, v0: number, t1: number, v1: number, t: number): number {\n\t\treturn v0 * Math.pow(v1 / v0, (t - t0) / (t1 - t0));\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
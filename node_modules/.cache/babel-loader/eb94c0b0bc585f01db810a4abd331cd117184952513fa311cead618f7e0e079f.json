{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { TimeClass } from \"../../core/type/Time\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport var Transport = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Transport, _ToneWithContext);\n  var _super = _createSuper(Transport);\n  function Transport() {\n    var _this;\n    _classCallCheck(this, Transport);\n    _this = _super.call(this, optionsFromArguments(Transport.getDefaults(), arguments));\n    _this.name = \"Transport\";\n    //-------------------------------------\n    // \tLOOPING\n    //-------------------------------------\n    /**\n     * If the transport loops or not.\n     */\n    _this._loop = new TimelineValue(false);\n    /**\n     * The loop start position in ticks\n     */\n    _this._loopStart = 0;\n    /**\n     * The loop end position in ticks\n     */\n    _this._loopEnd = 0;\n    //-------------------------------------\n    // \tTIMELINE EVENTS\n    //-------------------------------------\n    /**\n     * All the events in an object to keep track by ID\n     */\n    _this._scheduledEvents = {};\n    /**\n     * The scheduled events.\n     */\n    _this._timeline = new Timeline();\n    /**\n     * Repeated events\n     */\n    _this._repeatedEvents = new IntervalTimeline();\n    /**\n     * All of the synced Signals\n     */\n    _this._syncedSignals = [];\n    /**\n     * The swing amount\n     */\n    _this._swingAmount = 0;\n    var options = optionsFromArguments(Transport.getDefaults(), arguments);\n    // CLOCK/TEMPO\n    _this._ppq = options.ppq;\n    _this._clock = new Clock({\n      callback: _this._processTick.bind(_assertThisInitialized(_this)),\n      context: _this.context,\n      frequency: 0,\n      units: \"bpm\"\n    });\n    _this._bindClockEvents();\n    _this.bpm = _this._clock.frequency;\n    _this._clock.frequency.multiplier = options.ppq;\n    _this.bpm.setValueAtTime(options.bpm, 0);\n    readOnly(_assertThisInitialized(_this), \"bpm\");\n    _this._timeSignature = options.timeSignature;\n    // SWING\n    _this._swingTicks = options.ppq / 2; // 8n\n    return _this;\n  }\n  _createClass(Transport, [{\n    key: \"_processTick\",\n    value:\n    //-------------------------------------\n    // \tTICKS\n    //-------------------------------------\n    /**\n     * called on every tick\n     * @param  tickTime clock relative tick time\n     */\n    function _processTick(tickTime, ticks) {\n      // do the loop test\n      if (this._loop.get(tickTime)) {\n        if (ticks >= this._loopEnd) {\n          this.emit(\"loopEnd\", tickTime);\n          this._clock.setTicksAtTime(this._loopStart, tickTime);\n          ticks = this._loopStart;\n          this.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n          this.emit(\"loop\", tickTime);\n        }\n      }\n      // handle swing\n      if (this._swingAmount > 0 && ticks % this._ppq !== 0 &&\n      // not on a downbeat\n      ticks % (this._swingTicks * 2) !== 0) {\n        // add some swing\n        var progress = ticks % (this._swingTicks * 2) / (this._swingTicks * 2);\n        var amount = Math.sin(progress * Math.PI) * this._swingAmount;\n        tickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n      }\n      // invoke the timeline events scheduled on this tick\n      this._timeline.forEachAtTime(ticks, function (event) {\n        return event.invoke(tickTime);\n      });\n    }\n    //-------------------------------------\n    // \tSCHEDULABLE EVENTS\n    //-------------------------------------\n    /**\n     * Schedule an event along the timeline.\n     * @param callback The callback to be invoked at the time.\n     * @param time The time to invoke the callback at.\n     * @return The id of the event which can be used for canceling the event.\n     * @example\n     * // schedule an event on the 16th measure\n     * Tone.Transport.schedule((time) => {\n     * \t// invoked on measure 16\n     * \tconsole.log(\"measure 16!\");\n     * }, \"16:0:0\");\n     */\n  }, {\n    key: \"schedule\",\n    value: function schedule(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Schedule a repeated event along the timeline. The event will fire\n     * at the `interval` starting at the `startTime` and for the specified\n     * `duration`.\n     * @param  callback   The callback to invoke.\n     * @param  interval   The duration between successive callbacks. Must be a positive number.\n     * @param  startTime  When along the timeline the events should start being invoked.\n     * @param  duration How long the event should repeat.\n     * @return  The ID of the scheduled event. Use this to cancel the event.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // a callback invoked every eighth note after the first measure\n     * Tone.Transport.scheduleRepeat((time) => {\n     * \tosc.start(time).stop(time + 0.1);\n     * }, \"8n\", \"1m\");\n     */\n  }, {\n    key: \"scheduleRepeat\",\n    value: function scheduleRepeat(callback, interval, startTime) {\n      var duration = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : Infinity;\n      var event = new TransportRepeatEvent(this, {\n        callback: callback,\n        duration: new TimeClass(this.context, duration).toTicks(),\n        interval: new TimeClass(this.context, interval).toTicks(),\n        time: new TransportTimeClass(this.context, startTime).toTicks()\n      });\n      // kick it off if the Transport is started\n      // @ts-ignore\n      return this._addEvent(event, this._repeatedEvents);\n    }\n    /**\n     * Schedule an event that will be removed after it is invoked.\n     * @param callback The callback to invoke once.\n     * @param time The time the callback should be invoked.\n     * @returns The ID of the scheduled event.\n     */\n  }, {\n    key: \"scheduleOnce\",\n    value: function scheduleOnce(callback, time) {\n      var event = new TransportEvent(this, {\n        callback: callback,\n        once: true,\n        time: new TransportTimeClass(this.context, time).toTicks()\n      });\n      return this._addEvent(event, this._timeline);\n    }\n    /**\n     * Clear the passed in event id from the timeline\n     * @param eventId The id of the event.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear(eventId) {\n      if (this._scheduledEvents.hasOwnProperty(eventId)) {\n        var item = this._scheduledEvents[eventId.toString()];\n        item.timeline.remove(item.event);\n        item.event.dispose();\n        delete this._scheduledEvents[eventId.toString()];\n      }\n      return this;\n    }\n    /**\n     * Add an event to the correct timeline. Keep track of the\n     * timeline it was added to.\n     * @returns the event id which was just added\n     */\n  }, {\n    key: \"_addEvent\",\n    value: function _addEvent(event, timeline) {\n      this._scheduledEvents[event.id.toString()] = {\n        event: event,\n        timeline: timeline\n      };\n      timeline.add(event);\n      return event.id;\n    }\n    /**\n     * Remove scheduled events from the timeline after\n     * the given time. Repeated events will be removed\n     * if their startTime is after the given time\n     * @param after Clear all events after this time.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel() {\n      var _this2 = this;\n      var after = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      var computedAfter = this.toTicks(after);\n      this._timeline.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n      this._repeatedEvents.forEachFrom(computedAfter, function (event) {\n        return _this2.clear(event.id);\n      });\n      return this;\n    }\n    //-------------------------------------\n    // \tSTART/STOP/PAUSE\n    //-------------------------------------\n    /**\n     * Bind start/stop/pause events from the clock and emit them.\n     */\n  }, {\n    key: \"_bindClockEvents\",\n    value: function _bindClockEvents() {\n      var _this3 = this;\n      this._clock.on(\"start\", function (time, offset) {\n        offset = new TicksClass(_this3.context, offset).toSeconds();\n        _this3.emit(\"start\", time, offset);\n      });\n      this._clock.on(\"stop\", function (time) {\n        _this3.emit(\"stop\", time);\n      });\n      this._clock.on(\"pause\", function (time) {\n        _this3.emit(\"pause\", time);\n      });\n    }\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n     */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._clock.getStateAtTime(this.now());\n    }\n    /**\n     * Start the transport and all sources synced to the transport.\n     * @param  time The time when the transport should start.\n     * @param  offset The timeline offset to start the transport.\n     * @example\n     * // start the transport in one second starting at beginning of the 5th measure.\n     * Tone.Transport.start(\"+1\", \"4:0:0\");\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var offsetTicks;\n      if (isDefined(offset)) {\n        offsetTicks = this.toTicks(offset);\n      }\n      // start the clock\n      this._clock.start(time, offsetTicks);\n      return this;\n    }\n    /**\n     * Stop the transport and all sources synced to the transport.\n     * @param time The time when the transport should stop.\n     * @example\n     * Tone.Transport.stop();\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._clock.stop(time);\n      return this;\n    }\n    /**\n     * Pause the transport and all sources synced to the transport.\n     */\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      this._clock.pause(time);\n      return this;\n    }\n    /**\n     * Toggle the current state of the transport. If it is\n     * started, it will stop it, otherwise it will start the Transport.\n     * @param  time The time of the event\n     */\n  }, {\n    key: \"toggle\",\n    value: function toggle(time) {\n      time = this.toSeconds(time);\n      if (this._clock.getStateAtTime(time) !== \"started\") {\n        this.start(time);\n      } else {\n        this.stop(time);\n      }\n      return this;\n    }\n    //-------------------------------------\n    // \tSETTERS/GETTERS\n    //-------------------------------------\n    /**\n     * The time signature as just the numerator over 4.\n     * For example 4/4 would be just 4 and 6/8 would be 3.\n     * @example\n     * // common time\n     * Tone.Transport.timeSignature = 4;\n     * // 7/8\n     * Tone.Transport.timeSignature = [7, 8];\n     * // this will be reduced to a single number\n     * Tone.Transport.timeSignature; // returns 3.5\n     */\n  }, {\n    key: \"timeSignature\",\n    get: function get() {\n      return this._timeSignature;\n    },\n    set: function set(timeSig) {\n      if (isArray(timeSig)) {\n        timeSig = timeSig[0] / timeSig[1] * 4;\n      }\n      this._timeSignature = timeSig;\n    }\n    /**\n     * When the Transport.loop = true, this is the starting position of the loop.\n     */\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n    },\n    set: function set(startPosition) {\n      this._loopStart = this.toTicks(startPosition);\n    }\n    /**\n     * When the Transport.loop = true, this is the ending position of the loop.\n     */\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n    },\n    set: function set(endPosition) {\n      this._loopEnd = this.toTicks(endPosition);\n    }\n    /**\n     * If the transport loops or not.\n     */\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop.get(this.now());\n    },\n    set: function set(loop) {\n      this._loop.set(loop, this.now());\n    }\n    /**\n     * Set the loop start and stop at the same time.\n     * @example\n     * // loop over the first measure\n     * Tone.Transport.setLoopPoints(0, \"1m\");\n     * Tone.Transport.loop = true;\n     */\n  }, {\n    key: \"setLoopPoints\",\n    value: function setLoopPoints(startPosition, endPosition) {\n      this.loopStart = startPosition;\n      this.loopEnd = endPosition;\n      return this;\n    }\n    /**\n     * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n     */\n  }, {\n    key: \"swing\",\n    get: function get() {\n      return this._swingAmount;\n    },\n    set: function set(amount) {\n      // scale the values to a normal range\n      this._swingAmount = amount;\n    }\n    /**\n     * Set the subdivision which the swing will be applied to.\n     * The default value is an 8th note. Value must be less\n     * than a quarter note.\n     */\n  }, {\n    key: \"swingSubdivision\",\n    get: function get() {\n      return new TicksClass(this.context, this._swingTicks).toNotation();\n    },\n    set: function set(subdivision) {\n      this._swingTicks = this.toTicks(subdivision);\n    }\n    /**\n     * The Transport's position in Bars:Beats:Sixteenths.\n     * Setting the value will jump to that position right away.\n     */\n  }, {\n    key: \"position\",\n    get: function get() {\n      var now = this.now();\n      var ticks = this._clock.getTicksAtTime(now);\n      return new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n    },\n    set: function set(progress) {\n      var ticks = this.toTicks(progress);\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's position in seconds\n     * Setting the value will jump to that position right away.\n     */\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this._clock.seconds;\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this._clock.frequency.timeToTicks(s, now);\n      this.ticks = ticks;\n    }\n    /**\n     * The Transport's loop position as a normalized value. Always\n     * returns 0 if the transport if loop is not true.\n     */\n  }, {\n    key: \"progress\",\n    get: function get() {\n      if (this.loop) {\n        var now = this.now();\n        var ticks = this._clock.getTicksAtTime(now);\n        return (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The transports current tick position.\n     */\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this._clock.ticks;\n    },\n    set: function set(t) {\n      if (this._clock.ticks !== t) {\n        var now = this.now();\n        // stop everything synced to the transport\n        if (this.state === \"started\") {\n          var ticks = this._clock.getTicksAtTime(now);\n          // schedule to start on the next tick, #573\n          var remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n          var time = now + remainingTick;\n          this.emit(\"stop\", time);\n          this._clock.setTicksAtTime(t, time);\n          // restart it with the new time\n          this.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n        } else {\n          this._clock.setTicksAtTime(t, now);\n        }\n      }\n    }\n    /**\n     * Get the clock's ticks at the given time.\n     * @param  time  When to get the tick value\n     * @return The tick value at the given time.\n     */\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return Math.round(this._clock.getTicksAtTime(time));\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      return this._clock.getSecondsAtTime(time);\n    }\n    /**\n     * Pulses Per Quarter note. This is the smallest resolution\n     * the Transport timing supports. This should be set once\n     * on initialization and not set again. Changing this value\n     * after other objects have been created can cause problems.\n     */\n  }, {\n    key: \"PPQ\",\n    get: function get() {\n      return this._clock.frequency.multiplier;\n    },\n    set: function set(ppq) {\n      this._clock.frequency.multiplier = ppq;\n    }\n    //-------------------------------------\n    // \tSYNCING\n    //-------------------------------------\n    /**\n     * Returns the time aligned to the next subdivision\n     * of the Transport. If the Transport is not started,\n     * it will return 0.\n     * Note: this will not work precisely during tempo ramps.\n     * @param  subdivision  The subdivision to quantize to\n     * @return  The context time of the next subdivision.\n     * @example\n     * // the transport must be started, otherwise returns 0\n     * Tone.Transport.start();\n     * Tone.Transport.nextSubdivision(\"4n\");\n     */\n  }, {\n    key: \"nextSubdivision\",\n    value: function nextSubdivision(subdivision) {\n      subdivision = this.toTicks(subdivision);\n      if (this.state !== \"started\") {\n        // if the transport's not started, return 0\n        return 0;\n      } else {\n        var now = this.now();\n        // the remainder of the current ticks and the subdivision\n        var transportPos = this.getTicksAtTime(now);\n        var remainingTicks = subdivision - transportPos % subdivision;\n        return this._clock.nextTickTime(remainingTicks, now);\n      }\n    }\n    /**\n     * Attaches the signal to the tempo control signal so that\n     * any changes in the tempo will change the signal in the same\n     * ratio.\n     *\n     * @param signal\n     * @param ratio Optionally pass in the ratio between the two signals.\n     * \t\t\tOtherwise it will be computed based on their current values.\n     */\n  }, {\n    key: \"syncSignal\",\n    value: function syncSignal(signal, ratio) {\n      if (!ratio) {\n        // get the sync ratio\n        var now = this.now();\n        if (signal.getValueAtTime(now) !== 0) {\n          var bpm = this.bpm.getValueAtTime(now);\n          var computedFreq = 1 / (60 / bpm / this.PPQ);\n          ratio = signal.getValueAtTime(now) / computedFreq;\n        } else {\n          ratio = 0;\n        }\n      }\n      var ratioSignal = new Gain(ratio);\n      // @ts-ignore\n      this.bpm.connect(ratioSignal);\n      // @ts-ignore\n      ratioSignal.connect(signal._param);\n      this._syncedSignals.push({\n        initial: signal.value,\n        ratio: ratioSignal,\n        signal: signal\n      });\n      signal.value = 0;\n      return this;\n    }\n    /**\n     * Unsyncs a previously synced signal from the transport's control.\n     * See Transport.syncSignal.\n     */\n  }, {\n    key: \"unsyncSignal\",\n    value: function unsyncSignal(signal) {\n      for (var i = this._syncedSignals.length - 1; i >= 0; i--) {\n        var syncedSignal = this._syncedSignals[i];\n        if (syncedSignal.signal === signal) {\n          syncedSignal.ratio.dispose();\n          syncedSignal.signal.value = syncedSignal.initial;\n          this._syncedSignals.splice(i, 1);\n        }\n      }\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Transport.prototype), \"dispose\", this).call(this);\n      this._clock.dispose();\n      writable(this, \"bpm\");\n      this._timeline.dispose();\n      this._repeatedEvents.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        bpm: 120,\n        loopEnd: \"4m\",\n        loopStart: 0,\n        ppq: 192,\n        swing: 0,\n        swingSubdivision: \"8n\",\n        timeSignature: 4\n      });\n    }\n  }]);\n  return Transport;\n}(ToneWithContext);\nEmitter.mixin(Transport);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(function (context) {\n  context.transport = new Transport({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.transport.dispose();\n});","map":{"version":3,"mappings":"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","names":["TimeClass","TimelineValue","onContextClose","onContextInit","Gain","ToneWithContext","TicksClass","TransportTimeClass","optionsFromArguments","Emitter","readOnly","writable","IntervalTimeline","Timeline","isArray","isDefined","Clock","TransportEvent","TransportRepeatEvent","Transport","getDefaults","arguments","options","_ppq","ppq","_clock","callback","_processTick","bind","context","frequency","units","_bindClockEvents","bpm","multiplier","setValueAtTime","_timeSignature","timeSignature","_swingTicks","tickTime","ticks","_loop","get","_loopEnd","emit","setTicksAtTime","_loopStart","getSecondsAtTime","_swingAmount","progress","amount","Math","sin","PI","toSeconds","_timeline","forEachAtTime","event","invoke","time","toTicks","_addEvent","interval","startTime","duration","Infinity","_repeatedEvents","once","eventId","_scheduledEvents","hasOwnProperty","item","toString","timeline","remove","dispose","id","add","after","computedAfter","forEachFrom","clear","on","offset","getStateAtTime","now","offsetTicks","start","stop","pause","timeSig","startPosition","endPosition","loop","set","loopStart","loopEnd","toNotation","subdivision","getTicksAtTime","toBarsBeatsSixteenths","seconds","s","timeToTicks","t","state","remainingTick","getDurationOfTicks","ceil","round","transportPos","remainingTicks","nextTickTime","signal","ratio","getValueAtTime","computedFreq","PPQ","ratioSignal","connect","_param","_syncedSignals","push","initial","value","i","length","syncedSignal","splice","Object","assign","swing","swingSubdivision","mixin","transport"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\Transport.ts"],"sourcesContent":["import { TimeClass } from \"../../core/type/Time\";\nimport { PlaybackState } from \"../../core/util/StateTimeline\";\nimport { TimelineValue } from \"../../core/util/TimelineValue\";\nimport { Signal } from \"../../signal/Signal\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\nimport { Gain } from \"../context/Gain\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { TicksClass } from \"../type/Ticks\";\nimport { TransportTimeClass } from \"../type/TransportTime\";\nimport {\n\tBarsBeatsSixteenths, BPM, NormalRange, Seconds,\n\tSubdivision, Ticks, Time, TimeSignature, TransportTime\n} from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Emitter } from \"../util/Emitter\";\nimport { readOnly, writable } from \"../util/Interface\";\nimport { IntervalTimeline } from \"../util/IntervalTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isArray, isDefined } from \"../util/TypeCheck\";\nimport { Clock } from \"./Clock\";\nimport { TickParam } from \"./TickParam\";\nimport { TransportEvent } from \"./TransportEvent\";\nimport { TransportRepeatEvent } from \"./TransportRepeatEvent\";\n\ninterface TransportOptions extends ToneWithContextOptions {\n\tbpm: BPM;\n\tswing: NormalRange;\n\tswingSubdivision: Subdivision;\n\ttimeSignature: number;\n\tloopStart: Time;\n\tloopEnd: Time;\n\tppq: number;\n}\n\ntype TransportEventNames = \"start\" | \"stop\" | \"pause\" | \"loop\" | \"loopEnd\" | \"loopStart\";\n\ninterface SyncedSignalEvent {\n\tsignal: Signal;\n\tinitial: number;\n\tratio: Gain;\n}\n\ntype TransportCallback = (time: Seconds) => void;\n\n/**\n * Transport for timing musical events.\n * Supports tempo curves and time changes. Unlike browser-based timing (setInterval, requestAnimationFrame)\n * Transport timing events pass in the exact time of the scheduled event\n * in the argument of the callback function. Pass that time value to the object\n * you're scheduling. <br><br>\n * A single transport is created for you when the library is initialized.\n * <br><br>\n * The transport emits the events: \"start\", \"stop\", \"pause\", and \"loop\" which are\n * called with the time of that event as the argument.\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination();\n * // repeated event every 8th note\n * Tone.Transport.scheduleRepeat((time) => {\n * \t// use the callback time to schedule events\n * \tosc.start(time).stop(time + 0.1);\n * }, \"8n\");\n * // transport must be started before it starts invoking events\n * Tone.Transport.start();\n * @category Core\n */\nexport class Transport extends ToneWithContext<TransportOptions> implements Emitter<TransportEventNames> {\n\n\treadonly name: string = \"Transport\";\n\n\t//-------------------------------------\n\t// \tLOOPING\n\t//-------------------------------------\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tprivate _loop: TimelineValue<boolean> = new TimelineValue(false);\n\n\t/**\n\t * The loop start position in ticks\n\t */\n\tprivate _loopStart: Ticks = 0;\n\n\t/**\n\t * The loop end position in ticks\n\t */\n\tprivate _loopEnd: Ticks = 0;\n\n\t//-------------------------------------\n\t// \tCLOCK/TEMPO\n\t//-------------------------------------\n\n\t/**\n\t * Pulses per quarter is the number of ticks per quarter note.\n\t */\n\tprivate _ppq: number;\n\n\t/**\n\t * watches the main oscillator for timing ticks\n\t * initially starts at 120bpm\n\t */\n\tprivate _clock: Clock<\"bpm\">;\n\n\t/**\n\t * The Beats Per Minute of the Transport.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * Tone.Transport.bpm.value = 80;\n\t * // start/stop the oscillator every quarter note\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"4n\");\n\t * Tone.Transport.start();\n\t * // ramp the bpm to 120 over 10 seconds\n\t * Tone.Transport.bpm.rampTo(120, 10);\n\t */\n\tbpm: TickParam<\"bpm\">;\n\n\t/**\n\t * The time signature, or more accurately the numerator\n\t * of the time signature over a denominator of 4.\n\t */\n\tprivate _timeSignature: number;\n\n\t//-------------------------------------\n\t// \tTIMELINE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * All the events in an object to keep track by ID\n\t */\n\tprivate _scheduledEvents = {};\n\n\t/**\n\t * The scheduled events.\n\t */\n\tprivate _timeline: Timeline<TransportEvent> = new Timeline();\n\n\t/**\n\t * Repeated events\n\t */\n\tprivate _repeatedEvents: IntervalTimeline = new IntervalTimeline();\n\n\t/**\n\t * All of the synced Signals\n\t */\n\tprivate _syncedSignals: SyncedSignalEvent[] = [];\n\n\t//-------------------------------------\n\t// \tSWING\n\t//-------------------------------------\n\n\t/**\n\t * The subdivision of the swing\n\t */\n\tprivate _swingTicks: Ticks;\n\n\t/**\n\t * The swing amount\n\t */\n\tprivate _swingAmount: NormalRange = 0;\n\n\tconstructor(options?: Partial<TransportOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Transport.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Transport.getDefaults(), arguments);\n\n\t\t// CLOCK/TEMPO\n\t\tthis._ppq = options.ppq;\n\t\tthis._clock = new Clock({\n\t\t\tcallback: this._processTick.bind(this),\n\t\t\tcontext: this.context,\n\t\t\tfrequency: 0,\n\t\t\tunits: \"bpm\",\n\t\t});\n\t\tthis._bindClockEvents();\n\t\tthis.bpm = this._clock.frequency as unknown as TickParam<\"bpm\">;\n\t\tthis._clock.frequency.multiplier = options.ppq;\n\t\tthis.bpm.setValueAtTime(options.bpm, 0);\n\t\treadOnly(this, \"bpm\");\n\t\tthis._timeSignature = options.timeSignature;\n\n\t\t// SWING\n\t\tthis._swingTicks = options.ppq / 2; // 8n\n\t}\n\n\tstatic getDefaults(): TransportOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tbpm: 120,\n\t\t\tloopEnd: \"4m\" as Subdivision,\n\t\t\tloopStart: 0,\n\t\t\tppq: 192,\n\t\t\tswing: 0,\n\t\t\tswingSubdivision: \"8n\" as Subdivision,\n\t\t\ttimeSignature: 4,\n\t\t});\n\t}\n\n\t//-------------------------------------\n\t// \tTICKS\n\t//-------------------------------------\n\n\t/**\n\t * called on every tick\n\t * @param  tickTime clock relative tick time\n\t */\n\tprivate _processTick(tickTime: Seconds, ticks: Ticks): void {\n\t\t// do the loop test\n\t\tif (this._loop.get(tickTime)) {\n\t\t\tif (ticks >= this._loopEnd) {\n\t\t\t\tthis.emit(\"loopEnd\", tickTime);\n\t\t\t\tthis._clock.setTicksAtTime(this._loopStart, tickTime);\n\t\t\t\tticks = this._loopStart;\n\t\t\t\tthis.emit(\"loopStart\", tickTime, this._clock.getSecondsAtTime(tickTime));\n\t\t\t\tthis.emit(\"loop\", tickTime);\n\t\t\t}\n\t\t}\n\t\t// handle swing\n\t\tif (this._swingAmount > 0 &&\n\t\t\tticks % this._ppq !== 0 && // not on a downbeat\n\t\t\tticks % (this._swingTicks * 2) !== 0) {\n\t\t\t// add some swing\n\t\t\tconst progress = (ticks % (this._swingTicks * 2)) / (this._swingTicks * 2);\n\t\t\tconst amount = Math.sin((progress) * Math.PI) * this._swingAmount;\n\t\t\ttickTime += new TicksClass(this.context, this._swingTicks * 2 / 3).toSeconds() * amount;\n\t\t}\n\t\t// invoke the timeline events scheduled on this tick\n\t\tthis._timeline.forEachAtTime(ticks, event => event.invoke(tickTime));\n\t}\n\n\t//-------------------------------------\n\t// \tSCHEDULABLE EVENTS\n\t//-------------------------------------\n\n\t/**\n\t * Schedule an event along the timeline.\n\t * @param callback The callback to be invoked at the time.\n\t * @param time The time to invoke the callback at.\n\t * @return The id of the event which can be used for canceling the event.\n\t * @example\n\t * // schedule an event on the 16th measure\n\t * Tone.Transport.schedule((time) => {\n\t * \t// invoked on measure 16\n\t * \tconsole.log(\"measure 16!\");\n\t * }, \"16:0:0\");\n\t */\n\tschedule(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Schedule a repeated event along the timeline. The event will fire\n\t * at the `interval` starting at the `startTime` and for the specified\n\t * `duration`.\n\t * @param  callback   The callback to invoke.\n\t * @param  interval   The duration between successive callbacks. Must be a positive number.\n\t * @param  startTime  When along the timeline the events should start being invoked.\n\t * @param  duration How long the event should repeat.\n\t * @return  The ID of the scheduled event. Use this to cancel the event.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // a callback invoked every eighth note after the first measure\n\t * Tone.Transport.scheduleRepeat((time) => {\n\t * \tosc.start(time).stop(time + 0.1);\n\t * }, \"8n\", \"1m\");\n\t */\n\tscheduleRepeat(\n\t\tcallback: TransportCallback,\n\t\tinterval: Time | TimeClass,\n\t\tstartTime?: TransportTime | TransportTimeClass,\n\t\tduration: Time = Infinity,\n\t): number {\n\t\tconst event = new TransportRepeatEvent(this, {\n\t\t\tcallback,\n\t\t\tduration: new TimeClass(this.context, duration).toTicks(),\n\t\t\tinterval: new TimeClass(this.context, interval).toTicks(),\n\t\t\ttime: new TransportTimeClass(this.context, startTime).toTicks(),\n\t\t});\n\t\t// kick it off if the Transport is started\n\t\t// @ts-ignore\n\t\treturn this._addEvent(event, this._repeatedEvents);\n\t}\n\n\t/**\n\t * Schedule an event that will be removed after it is invoked.\n\t * @param callback The callback to invoke once.\n\t * @param time The time the callback should be invoked.\n\t * @returns The ID of the scheduled event.\n\t */\n\tscheduleOnce(callback: TransportCallback, time: TransportTime | TransportTimeClass): number {\n\t\tconst event = new TransportEvent(this, {\n\t\t\tcallback,\n\t\t\tonce: true,\n\t\t\ttime: new TransportTimeClass(this.context, time).toTicks(),\n\t\t});\n\t\treturn this._addEvent(event, this._timeline);\n\t}\n\n\t/**\n\t * Clear the passed in event id from the timeline\n\t * @param eventId The id of the event.\n\t */\n\tclear(eventId: number): this {\n\t\tif (this._scheduledEvents.hasOwnProperty(eventId)) {\n\t\t\tconst item = this._scheduledEvents[eventId.toString()];\n\t\t\titem.timeline.remove(item.event);\n\t\t\titem.event.dispose();\n\t\t\tdelete this._scheduledEvents[eventId.toString()];\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Add an event to the correct timeline. Keep track of the\n\t * timeline it was added to.\n\t * @returns the event id which was just added\n\t */\n\tprivate _addEvent(event: TransportEvent, timeline: Timeline<TransportEvent>): number {\n\t\tthis._scheduledEvents[event.id.toString()] = {\n\t\t\tevent,\n\t\t\ttimeline,\n\t\t};\n\t\ttimeline.add(event);\n\t\treturn event.id;\n\t}\n\n\t/**\n\t * Remove scheduled events from the timeline after\n\t * the given time. Repeated events will be removed\n\t * if their startTime is after the given time\n\t * @param after Clear all events after this time.\n\t */\n\tcancel(after: TransportTime = 0): this {\n\t\tconst computedAfter = this.toTicks(after);\n\t\tthis._timeline.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\tthis._repeatedEvents.forEachFrom(computedAfter, event => this.clear(event.id));\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSTART/STOP/PAUSE\n\t//-------------------------------------\n\n\t/**\n\t * Bind start/stop/pause events from the clock and emit them.\n\t */\n\tprivate _bindClockEvents(): void {\n\t\tthis._clock.on(\"start\", (time, offset) => {\n\t\t\toffset = new TicksClass(this.context, offset).toSeconds();\n\t\t\tthis.emit(\"start\", time, offset);\n\t\t});\n\n\t\tthis._clock.on(\"stop\", (time) => {\n\t\t\tthis.emit(\"stop\", time);\n\t\t});\n\n\t\tthis._clock.on(\"pause\", (time) => {\n\t\t\tthis.emit(\"pause\", time);\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\", or \"paused\"\n\t */\n\tget state(): PlaybackState {\n\t\treturn this._clock.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the transport and all sources synced to the transport.\n\t * @param  time The time when the transport should start.\n\t * @param  offset The timeline offset to start the transport.\n\t * @example\n\t * // start the transport in one second starting at beginning of the 5th measure.\n\t * Tone.Transport.start(\"+1\", \"4:0:0\");\n\t */\n\tstart(time?: Time, offset?: TransportTime): this {\n\t\tlet offsetTicks;\n\t\tif (isDefined(offset)) {\n\t\t\toffsetTicks = this.toTicks(offset);\n\t\t}\n\t\t// start the clock\n\t\tthis._clock.start(time, offsetTicks);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the transport and all sources synced to the transport.\n\t * @param time The time when the transport should stop.\n\t * @example\n\t * Tone.Transport.stop();\n\t */\n\tstop(time?: Time): this {\n\t\tthis._clock.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the transport and all sources synced to the transport.\n\t */\n\tpause(time?: Time): this {\n\t\tthis._clock.pause(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Toggle the current state of the transport. If it is\n\t * started, it will stop it, otherwise it will start the Transport.\n\t * @param  time The time of the event\n\t */\n\ttoggle(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._clock.getStateAtTime(time) !== \"started\") {\n\t\t\tthis.start(time);\n\t\t} else {\n\t\t\tthis.stop(time);\n\t\t}\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// \tSETTERS/GETTERS\n\t//-------------------------------------\n\n\t/**\n\t * The time signature as just the numerator over 4.\n\t * For example 4/4 would be just 4 and 6/8 would be 3.\n\t * @example\n\t * // common time\n\t * Tone.Transport.timeSignature = 4;\n\t * // 7/8\n\t * Tone.Transport.timeSignature = [7, 8];\n\t * // this will be reduced to a single number\n\t * Tone.Transport.timeSignature; // returns 3.5\n\t */\n\tget timeSignature(): TimeSignature {\n\t\treturn this._timeSignature;\n\t}\n\tset timeSignature(timeSig: TimeSignature) {\n\t\tif (isArray(timeSig)) {\n\t\t\ttimeSig = (timeSig[0] / timeSig[1]) * 4;\n\t\t}\n\t\tthis._timeSignature = timeSig;\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the starting position of the loop.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TimeClass(this.context, this._loopStart, \"i\").toSeconds();\n\t}\n\tset loopStart(startPosition: Time) {\n\t\tthis._loopStart = this.toTicks(startPosition);\n\t}\n\n\t/**\n\t * When the Transport.loop = true, this is the ending position of the loop.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TimeClass(this.context, this._loopEnd, \"i\").toSeconds();\n\t}\n\tset loopEnd(endPosition: Time) {\n\t\tthis._loopEnd = this.toTicks(endPosition);\n\t}\n\n\t/**\n\t * If the transport loops or not.\n\t */\n\tget loop(): boolean {\n\t\treturn this._loop.get(this.now());\n\t}\n\tset loop(loop) {\n\t\tthis._loop.set(loop, this.now());\n\t}\n\n\t/**\n\t * Set the loop start and stop at the same time.\n\t * @example\n\t * // loop over the first measure\n\t * Tone.Transport.setLoopPoints(0, \"1m\");\n\t * Tone.Transport.loop = true;\n\t */\n\tsetLoopPoints(startPosition: TransportTime, endPosition: TransportTime): this {\n\t\tthis.loopStart = startPosition;\n\t\tthis.loopEnd = endPosition;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The swing value. Between 0-1 where 1 equal to the note + half the subdivision.\n\t */\n\tget swing(): NormalRange {\n\t\treturn this._swingAmount;\n\t}\n\tset swing(amount: NormalRange) {\n\t\t// scale the values to a normal range\n\t\tthis._swingAmount = amount;\n\t}\n\n\t/**\n\t * Set the subdivision which the swing will be applied to.\n\t * The default value is an 8th note. Value must be less\n\t * than a quarter note.\n\t */\n\tget swingSubdivision(): Subdivision {\n\t\treturn new TicksClass(this.context, this._swingTicks).toNotation();\n\t}\n\tset swingSubdivision(subdivision: Subdivision) {\n\t\tthis._swingTicks = this.toTicks(subdivision);\n\t}\n\n\t/**\n\t * The Transport's position in Bars:Beats:Sixteenths.\n\t * Setting the value will jump to that position right away.\n\t */\n\tget position(): BarsBeatsSixteenths | Time {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\treturn new TicksClass(this.context, ticks).toBarsBeatsSixteenths();\n\t}\n\tset position(progress: Time) {\n\t\tconst ticks = this.toTicks(progress);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's position in seconds\n\t * Setting the value will jump to that position right away.\n\t */\n\tget seconds(): Seconds {\n\t\treturn this._clock.seconds;\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this._clock.frequency.timeToTicks(s, now);\n\t\tthis.ticks = ticks;\n\t}\n\n\t/**\n\t * The Transport's loop position as a normalized value. Always\n\t * returns 0 if the transport if loop is not true.\n\t */\n\tget progress(): NormalRange {\n\t\tif (this.loop) {\n\t\t\tconst now = this.now();\n\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\treturn (ticks - this._loopStart) / (this._loopEnd - this._loopStart);\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The transports current tick position.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this._clock.ticks;\n\t}\n\tset ticks(t: Ticks) {\n\t\tif (this._clock.ticks !== t) {\n\t\t\tconst now = this.now();\n\t\t\t// stop everything synced to the transport\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst ticks = this._clock.getTicksAtTime(now);\n\t\t\t\t// schedule to start on the next tick, #573\n\t\t\t\tconst remainingTick = this._clock.frequency.getDurationOfTicks(Math.ceil(ticks) - ticks, now);\n\t\t\t\tconst time = now + remainingTick;\n\t\t\t\tthis.emit(\"stop\", time);\n\t\t\t\tthis._clock.setTicksAtTime(t, time);\n\t\t\t\t// restart it with the new time\n\t\t\t\tthis.emit(\"start\", time, this._clock.getSecondsAtTime(time));\n\t\t\t} else {\n\t\t\t\tthis._clock.setTicksAtTime(t, now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get the clock's ticks at the given time.\n\t * @param  time  When to get the tick value\n\t * @return The tick value at the given time.\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\treturn Math.round(this._clock.getTicksAtTime(time));\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\treturn this._clock.getSecondsAtTime(time);\n\t}\n\n\t/**\n\t * Pulses Per Quarter note. This is the smallest resolution\n\t * the Transport timing supports. This should be set once\n\t * on initialization and not set again. Changing this value\n\t * after other objects have been created can cause problems.\n\t */\n\tget PPQ(): number {\n\t\treturn this._clock.frequency.multiplier;\n\t}\n\tset PPQ(ppq: number) {\n\t\tthis._clock.frequency.multiplier = ppq;\n\t}\n\n\t//-------------------------------------\n\t// \tSYNCING\n\t//-------------------------------------\n\n\t/**\n\t * Returns the time aligned to the next subdivision\n\t * of the Transport. If the Transport is not started,\n\t * it will return 0.\n\t * Note: this will not work precisely during tempo ramps.\n\t * @param  subdivision  The subdivision to quantize to\n\t * @return  The context time of the next subdivision.\n\t * @example\n\t * // the transport must be started, otherwise returns 0\n\t * Tone.Transport.start(); \n\t * Tone.Transport.nextSubdivision(\"4n\");\n\t */\n\tnextSubdivision(subdivision?: Time): Seconds {\n\t\tsubdivision = this.toTicks(subdivision);\n\t\tif (this.state !== \"started\") {\n\t\t\t// if the transport's not started, return 0\n\t\t\treturn 0;\n\t\t} else {\n\t\t\tconst now = this.now();\n\t\t\t// the remainder of the current ticks and the subdivision\n\t\t\tconst transportPos = this.getTicksAtTime(now);\n\t\t\tconst remainingTicks = subdivision - transportPos % subdivision;\n\t\t\treturn this._clock.nextTickTime(remainingTicks, now);\n\t\t}\n\t}\n\n\t/**\n\t * Attaches the signal to the tempo control signal so that\n\t * any changes in the tempo will change the signal in the same\n\t * ratio.\n\t *\n\t * @param signal\n\t * @param ratio Optionally pass in the ratio between the two signals.\n\t * \t\t\tOtherwise it will be computed based on their current values.\n\t */\n\tsyncSignal(signal: Signal<any>, ratio?: number): this {\n\t\tif (!ratio) {\n\t\t\t// get the sync ratio\n\t\t\tconst now = this.now();\n\t\t\tif (signal.getValueAtTime(now) !== 0) {\n\t\t\t\tconst bpm = this.bpm.getValueAtTime(now);\n\t\t\t\tconst computedFreq = 1 / (60 / bpm / this.PPQ);\n\t\t\t\tratio = signal.getValueAtTime(now) / computedFreq;\n\t\t\t} else {\n\t\t\t\tratio = 0;\n\t\t\t}\n\t\t}\n\t\tconst ratioSignal = new Gain(ratio);\n\t\t// @ts-ignore\n\t\tthis.bpm.connect(ratioSignal);\n\t\t// @ts-ignore\n\t\tratioSignal.connect(signal._param);\n\t\tthis._syncedSignals.push({\n\t\t\tinitial: signal.value,\n\t\t\tratio: ratioSignal,\n\t\t\tsignal,\n\t\t});\n\t\tsignal.value = 0;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsyncs a previously synced signal from the transport's control.\n\t * See Transport.syncSignal.\n\t */\n\tunsyncSignal(signal: Signal<any>): this {\n\t\tfor (let i = this._syncedSignals.length - 1; i >= 0; i--) {\n\t\t\tconst syncedSignal = this._syncedSignals[i];\n\t\t\tif (syncedSignal.signal === signal) {\n\t\t\t\tsyncedSignal.ratio.dispose();\n\t\t\t\tsyncedSignal.signal.value = syncedSignal.initial;\n\t\t\t\tthis._syncedSignals.splice(i, 1);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._clock.dispose();\n\t\twritable(this, \"bpm\");\n\t\tthis._timeline.dispose();\n\t\tthis._repeatedEvents.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// EMITTER MIXIN TO SATISFY COMPILER\n\t//-------------------------------------\n\n\ton!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\tonce!: (event: TransportEventNames, callback: (...args: any[]) => void) => this;\n\toff!: (event: TransportEventNames, callback?: ((...args: any[]) => void) | undefined) => this;\n\temit!: (event: any, ...args: any[]) => this;\n}\n\nEmitter.mixin(Transport);\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.transport = new Transport({ context });\n});\n\nonContextClose(context => {\n\tcontext.transport.dispose();\n});\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
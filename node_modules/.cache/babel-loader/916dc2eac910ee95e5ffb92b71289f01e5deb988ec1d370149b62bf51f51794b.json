{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport var Noise = /*#__PURE__*/function (_Source) {\n  _inherits(Noise, _Source);\n  var _super = _createSuper(Noise);\n  function Noise() {\n    var _this;\n    _classCallCheck(this, Noise);\n    _this = _super.call(this, optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n    _this.name = \"Noise\";\n    /**\n     * Private reference to the source\n     */\n    _this._source = null;\n    var options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n    _this._playbackRate = options.playbackRate;\n    _this.type = options.type;\n    _this._fadeIn = options.fadeIn;\n    _this._fadeOut = options.fadeOut;\n    return _this;\n  }\n  _createClass(Noise, [{\n    key: \"type\",\n    get:\n    /**\n     * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n     * @example\n     * const noise = new Tone.Noise().toDestination().start();\n     * noise.type = \"brown\";\n     */\n    function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      assert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n      if (this._type !== type) {\n        this._type = type;\n        // if it's playing, stop and restart it\n        if (this.state === \"started\") {\n          var now = this.now();\n          this._stop(now);\n          this._start(now);\n        }\n      }\n    }\n    /**\n     * The playback rate of the noise. Affects\n     * the \"frequency\" of the noise.\n     */\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n      if (this._source) {\n        this._source.playbackRate.value = rate;\n      }\n    }\n    /**\n     * internal start method\n     */\n  }, {\n    key: \"_start\",\n    value: function _start(time) {\n      var _this2 = this;\n      var buffer = _noiseBuffers[this._type];\n      this._source = new ToneBufferSource({\n        url: buffer,\n        context: this.context,\n        fadeIn: this._fadeIn,\n        fadeOut: this._fadeOut,\n        loop: true,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        },\n        playbackRate: this._playbackRate\n      }).connect(this.output);\n      this._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n    }\n    /**\n     * internal stop method\n     */\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      if (this._source) {\n        this._source.stop(this.toSeconds(time));\n        this._source = null;\n      }\n    }\n    /**\n     * The fadeIn time of the amplitude envelope.\n     */\n  }, {\n    key: \"fadeIn\",\n    get: function get() {\n      return this._fadeIn;\n    },\n    set: function set(time) {\n      this._fadeIn = time;\n      if (this._source) {\n        this._source.fadeIn = this._fadeIn;\n      }\n    }\n    /**\n     * The fadeOut time of the amplitude envelope.\n     */\n  }, {\n    key: \"fadeOut\",\n    get: function get() {\n      return this._fadeOut;\n    },\n    set: function set(time) {\n      this._fadeOut = time;\n      if (this._source) {\n        this._source.fadeOut = this._fadeOut;\n      }\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      // TODO could be optimized by cancelling the buffer source 'stop'\n      this._stop(time);\n      this._start(time);\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Noise.prototype), \"dispose\", this).call(this);\n      if (this._source) {\n        this._source.disconnect();\n      }\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        fadeIn: 0,\n        fadeOut: 0,\n        playbackRate: 1,\n        type: \"white\"\n      });\n    }\n  }]);\n  return Noise;\n}(Source);\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n// Noise buffer stats\nvar BUFFER_LENGTH = 44100 * 5;\nvar NUM_CHANNELS = 2;\n/**\n * Cache the noise buffers\n */\nvar _noiseCache = {\n  brown: null,\n  pink: null,\n  white: null\n};\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nvar _noiseBuffers = {\n  get brown() {\n    if (!_noiseCache.brown) {\n      var buffer = [];\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var lastOut = 0.0;\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          channel[i] = (lastOut + 0.02 * white) / 1.02;\n          lastOut = channel[i];\n          channel[i] *= 3.5; // (roughly) compensate for gain\n        }\n      }\n\n      _noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n    }\n    return _noiseCache.brown;\n  },\n  get pink() {\n    if (!_noiseCache.pink) {\n      var buffer = [];\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        var b0 = void 0,\n          b1 = void 0,\n          b2 = void 0,\n          b3 = void 0,\n          b4 = void 0,\n          b5 = void 0,\n          b6 = void 0;\n        b0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          var white = Math.random() * 2 - 1;\n          b0 = 0.99886 * b0 + white * 0.0555179;\n          b1 = 0.99332 * b1 + white * 0.0750759;\n          b2 = 0.96900 * b2 + white * 0.1538520;\n          b3 = 0.86650 * b3 + white * 0.3104856;\n          b4 = 0.55000 * b4 + white * 0.5329522;\n          b5 = -0.7616 * b5 - white * 0.0168980;\n          channel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n          channel[i] *= 0.11; // (roughly) compensate for gain\n          b6 = white * 0.115926;\n        }\n      }\n      _noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n    }\n    return _noiseCache.pink;\n  },\n  get white() {\n    if (!_noiseCache.white) {\n      var buffer = [];\n      for (var channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n        var channel = new Float32Array(BUFFER_LENGTH);\n        buffer[channelNum] = channel;\n        for (var i = 0; i < BUFFER_LENGTH; i++) {\n          channel[i] = Math.random() * 2 - 1;\n        }\n      }\n      _noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n    }\n    return _noiseCache.white;\n  }\n};","map":{"version":3,"mappings":"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","names":["ToneAudioBuffer","optionsFromArguments","assert","Source","ToneBufferSource","Noise","getDefaults","arguments","options","_playbackRate","playbackRate","type","_fadeIn","fadeIn","_fadeOut","fadeOut","_type","_noiseBuffers","state","now","_stop","_start","rate","_source","value","time","buffer","url","context","loop","onended","onstop","connect","output","start","toSeconds","Math","random","duration","stop","disconnect","Object","assign","BUFFER_LENGTH","NUM_CHANNELS","_noiseCache","brown","pink","white","channelNum","channel","Float32Array","lastOut","i","fromArray","b0","b1","b2","b3","b4","b5","b6"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\Noise.ts"],"sourcesContent":["import { ToneAudioBuffer } from \"../core/context/ToneAudioBuffer\";\nimport { Positive, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Source, SourceOptions } from \"../source/Source\";\nimport { ToneBufferSource } from \"./buffer/ToneBufferSource\";\n\nexport type NoiseType = \"white\" | \"brown\" | \"pink\";\n\nexport interface NoiseOptions extends SourceOptions {\n\ttype: NoiseType;\n\tplaybackRate: Positive;\n\tfadeIn: Time;\n\tfadeOut: Time;\n}\n\n/**\n * Noise is a noise generator. It uses looped noise buffers to save on performance.\n * Noise supports the noise types: \"pink\", \"white\", and \"brown\". Read more about\n * colors of noise on [Wikipedia](https://en.wikipedia.org/wiki/Colors_of_noise).\n *\n * @example\n * // initialize the noise and start\n * const noise = new Tone.Noise(\"pink\").start();\n * // make an autofilter to shape the noise\n * const autoFilter = new Tone.AutoFilter({\n * \tfrequency: \"8n\",\n * \tbaseFrequency: 200,\n * \toctaves: 8\n * }).toDestination().start();\n * // connect the noise\n * noise.connect(autoFilter);\n * // start the autofilter LFO\n * autoFilter.start();\n * @category Source\n */\nexport class Noise extends Source<NoiseOptions> {\n\n\treadonly name: string = \"Noise\";\n\n\t/**\n\t * Private reference to the source\n\t */\n\tprivate _source: ToneBufferSource | null = null;\n\n\t/**\n\t * private reference to the type\n\t */\n\tprivate _type!: NoiseType;\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tprivate _playbackRate: Positive;\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tprotected _fadeIn: Time;\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tprotected _fadeOut: Time;\n\n\t/**\n\t * @param type the noise type (white|pink|brown)\n\t */\n\tconstructor(type?: NoiseType);\n\tconstructor(options?: Partial<NoiseOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]));\n\t\tconst options = optionsFromArguments(Noise.getDefaults(), arguments, [\"type\"]);\n\n\t\tthis._playbackRate = options.playbackRate;\n\t\tthis.type = options.type;\n\t\tthis._fadeIn = options.fadeIn;\n\t\tthis._fadeOut = options.fadeOut;\n\t}\n\n\tstatic getDefaults(): NoiseOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tfadeIn: 0,\n\t\t\tfadeOut: 0,\n\t\t\tplaybackRate: 1,\n\t\t\ttype: \"white\" as NoiseType,\n\t\t});\n\t}\n\n\t/**\n\t * The type of the noise. Can be \"white\", \"brown\", or \"pink\".\n\t * @example\n\t * const noise = new Tone.Noise().toDestination().start();\n\t * noise.type = \"brown\";\n\t */\n\tget type(): NoiseType {\n\t\treturn this._type;\n\t}\n\tset type(type: NoiseType) {\n\t\tassert(type in _noiseBuffers, \"Noise: invalid type: \" + type);\n\t\tif (this._type !== type) {\n\t\t\tthis._type = type;\n\t\t\t// if it's playing, stop and restart it\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tconst now = this.now();\n\t\t\t\tthis._stop(now);\n\t\t\t\tthis._start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the noise. Affects\n\t * the \"frequency\" of the noise.\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate: Positive) {\n\t\tthis._playbackRate = rate;\n\t\tif (this._source) {\n\t\t\tthis._source.playbackRate.value = rate;\n\t\t}\n\t}\n\n\t/**\n\t * internal start method\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst buffer = _noiseBuffers[this._type];\n\t\tthis._source = new ToneBufferSource({\n\t\t\turl: buffer,\n\t\t\tcontext: this.context,\n\t\t\tfadeIn: this._fadeIn,\n\t\t\tfadeOut: this._fadeOut,\n\t\t\tloop: true,\n\t\t\tonended: () => this.onstop(this),\n\t\t\tplaybackRate: this._playbackRate,\n\t\t}).connect(this.output);\n\t\tthis._source.start(this.toSeconds(time), Math.random() * (buffer.duration - 0.001));\n\t}\n\n\t/**\n\t * internal stop method\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tif (this._source) {\n\t\t\tthis._source.stop(this.toSeconds(time));\n\t\t\tthis._source = null;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeIn time of the amplitude envelope.\n\t */\n\tget fadeIn(): Time {\n\t\treturn this._fadeIn;\n\t}\n\tset fadeIn(time) {\n\t\tthis._fadeIn = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeIn = this._fadeIn;\n\t\t}\n\t}\n\n\t/**\n\t * The fadeOut time of the amplitude envelope.\n\t */\n\tget fadeOut(): Time {\n\t\treturn this._fadeOut;\n\t}\n\tset fadeOut(time) {\n\t\tthis._fadeOut = time;\n\t\tif (this._source) {\n\t\t\tthis._source.fadeOut = this._fadeOut;\n\t\t}\n\t}\n\n\tprotected _restart(time?: Time): void {\n\t\t// TODO could be optimized by cancelling the buffer source 'stop'\n\t\tthis._stop(time);\n\t\tthis._start(time);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._source) {\n\t\t\tthis._source.disconnect();\n\t\t}\n\t\treturn this;\n\t}\n}\n\n//--------------------\n// THE NOISE BUFFERS\n//--------------------\n\n// Noise buffer stats\nconst BUFFER_LENGTH = 44100 * 5;\nconst NUM_CHANNELS = 2;\n\n/**\n * The cached noise buffers\n */\ninterface NoiseCache {\n\t[key: string]: ToneAudioBuffer | null;\n}\n\n/**\n * Cache the noise buffers\n */\nconst _noiseCache: NoiseCache = {\n\tbrown: null,\n\tpink: null,\n\twhite: null,\n};\n\n/**\n * The noise arrays. Generated on initialization.\n * borrowed heavily from https://github.com/zacharydenton/noise.js\n * (c) 2013 Zach Denton (MIT)\n */\nconst _noiseBuffers = {\n\tget brown(): ToneAudioBuffer {\n\t\tif (!_noiseCache.brown) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet lastOut = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tchannel[i] = (lastOut + (0.02 * white)) / 1.02;\n\t\t\t\t\tlastOut = channel[i];\n\t\t\t\t\tchannel[i] *= 3.5; // (roughly) compensate for gain\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.brown = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.brown;\n\t},\n\n\tget pink(): ToneAudioBuffer {\n\t\tif (!_noiseCache.pink) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tlet b0, b1, b2, b3, b4, b5, b6;\n\t\t\t\tb0 = b1 = b2 = b3 = b4 = b5 = b6 = 0.0;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tconst white = Math.random() * 2 - 1;\n\t\t\t\t\tb0 = 0.99886 * b0 + white * 0.0555179;\n\t\t\t\t\tb1 = 0.99332 * b1 + white * 0.0750759;\n\t\t\t\t\tb2 = 0.96900 * b2 + white * 0.1538520;\n\t\t\t\t\tb3 = 0.86650 * b3 + white * 0.3104856;\n\t\t\t\t\tb4 = 0.55000 * b4 + white * 0.5329522;\n\t\t\t\t\tb5 = -0.7616 * b5 - white * 0.0168980;\n\t\t\t\t\tchannel[i] = b0 + b1 + b2 + b3 + b4 + b5 + b6 + white * 0.5362;\n\t\t\t\t\tchannel[i] *= 0.11; // (roughly) compensate for gain\n\t\t\t\t\tb6 = white * 0.115926;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.pink = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.pink;\n\t},\n\n\tget white(): ToneAudioBuffer {\n\t\tif (!_noiseCache.white) {\n\t\t\tconst buffer: Float32Array[] = [];\n\t\t\tfor (let channelNum = 0; channelNum < NUM_CHANNELS; channelNum++) {\n\t\t\t\tconst channel = new Float32Array(BUFFER_LENGTH);\n\t\t\t\tbuffer[channelNum] = channel;\n\t\t\t\tfor (let i = 0; i < BUFFER_LENGTH; i++) {\n\t\t\t\t\tchannel[i] = Math.random() * 2 - 1;\n\t\t\t\t}\n\t\t\t}\n\t\t\t_noiseCache.white = new ToneAudioBuffer().fromArray(buffer);\n\t\t}\n\t\treturn _noiseCache.white;\n\t},\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
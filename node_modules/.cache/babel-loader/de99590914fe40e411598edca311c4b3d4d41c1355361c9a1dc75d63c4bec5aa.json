{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport { __awaiter } from \"tslib\";\nimport { getContext, setContext } from \"../Global\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport.\n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport function Offline(callback, duration) {\n  var channels = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 2;\n  var sampleRate = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : getContext().sampleRate;\n  return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n    var originalContext, context, bufferPromise, buffer;\n    return _regeneratorRuntime().wrap(function _callee$(_context) {\n      while (1) switch (_context.prev = _context.next) {\n        case 0:\n          // set the OfflineAudioContext based on the current context\n          originalContext = getContext();\n          context = new OfflineContext(channels, duration, sampleRate);\n          setContext(context);\n          // invoke the callback/scheduling\n          _context.next = 5;\n          return callback(context);\n        case 5:\n          // then render the audio\n          bufferPromise = context.render(); // return the original AudioContext\n          setContext(originalContext);\n          // await the rendering\n          _context.next = 9;\n          return bufferPromise;\n        case 9:\n          buffer = _context.sent;\n          return _context.abrupt(\"return\", new ToneAudioBuffer(buffer));\n        case 11:\n        case \"end\":\n          return _context.stop();\n      }\n    }, _callee);\n  }));\n}","map":{"version":3,"mappings":";;AAAA,SAASA,UAAU,EAAEC,UAAU,QAAQ,WAAW;AAElD,SAASC,cAAc,QAAQ,kBAAkB;AACjD,SAASC,eAAe,QAAQ,mBAAmB;AAEnD;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AAiCA,OAAM,SAAgBC,OAAO,CAC5BC,QAA2D,EAC3DC,QAAiB,EAE2B;EAAA,IAD5CC,QAAQ,uEAAG,CAAC;EAAA,IACZC,iFAAqBR,UAAU,EAAE,CAACQ,UAAU;;;;;;UAE5C;UACMC,eAAe,GAAGT,UAAU,EAAE;UAE9BU,OAAO,GAAG,IAAIR,cAAc,CAACK,QAAQ,EAAED,QAAQ,EAAEE,UAAU,CAAC;UAClEP,UAAU,CAACS,OAAO,CAAC;UAEnB;UAAA;UACA,OAAML,QAAQ,CAACK,OAAO,CAAC;QAAA;UAEvB;UACMC,aAAa,GAAGD,OAAO,CAACE,MAAM,EAAE,EAEtC;UACAX,UAAU,CAACQ,eAAe,CAAC;UAE3B;UAAA;UACe,OAAME,aAAa;QAAA;UAA5BE,MAAM;UAAA,iCAGL,IAAIV,eAAe,CAACU,MAAM,CAAC;QAAA;QAAA;UAAA;MAAA;IAAA;EAAA,CAClC","names":["getContext","setContext","OfflineContext","ToneAudioBuffer","Offline","callback","duration","channels","sampleRate","originalContext","context","bufferPromise","render","buffer"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\context\\Offline.ts"],"sourcesContent":["import { getContext, setContext } from \"../Global\";\nimport { Seconds } from \"../type/Units\";\nimport { OfflineContext } from \"./OfflineContext\";\nimport { ToneAudioBuffer } from \"./ToneAudioBuffer\";\n\n/**\n * Generate a buffer by rendering all of the Tone.js code within the callback using the OfflineAudioContext.\n * The OfflineAudioContext is capable of rendering much faster than real time in many cases.\n * The callback function also passes in an offline instance of [[Context]] which can be used\n * to schedule events along the Transport. \n * @param  callback  All Tone.js nodes which are created and scheduled within this callback are recorded into the output Buffer.\n * @param  duration     the amount of time to record for.\n * @return  The promise which is invoked with the ToneAudioBuffer of the recorded output.\n * @example\n * // render 2 seconds of the oscillator\n * Tone.Offline(() => {\n * \t// only nodes created in this callback will be recorded\n * \tconst oscillator = new Tone.Oscillator().toDestination().start(0);\n * }, 2).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @example\n * // can also schedule events along the Transport\n * // using the passed in Offline Transport\n * Tone.Offline(({ transport }) => {\n * \tconst osc = new Tone.Oscillator().toDestination();\n * \ttransport.schedule(time => {\n * \t\tosc.start(time).stop(time + 0.1);\n * \t}, 1);\n * \t// make sure to start the transport\n * \ttransport.start(0.2);\n * }, 4).then((buffer) => {\n * \t// do something with the output buffer\n * \tconsole.log(buffer);\n * });\n * @category Core\n */\nexport async function Offline(\n\tcallback: (context: OfflineContext) => Promise<void> | void,\n\tduration: Seconds,\n\tchannels = 2,\n\tsampleRate: number = getContext().sampleRate,\n): Promise<ToneAudioBuffer> {\n\t// set the OfflineAudioContext based on the current context\n\tconst originalContext = getContext();\n\n\tconst context = new OfflineContext(channels, duration, sampleRate);\n\tsetContext(context);\n\n\t// invoke the callback/scheduling\n\tawait callback(context);\n\n\t// then render the audio\n\tconst bufferPromise = context.render();\n\n\t// return the original AudioContext\n\tsetContext(originalContext);\n\n\t// await the rendering\n\tconst buffer = await bufferPromise;\n\n\t// return the audio\n\treturn new ToneAudioBuffer(buffer);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
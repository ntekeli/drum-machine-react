{"ast":null,"code":"import _slicedToArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _defineProperty from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/defineProperty.js\";\nimport _objectSpread from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _asyncToGenerator from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/asyncToGenerator.js\";\nimport { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nvar processBuffer = /*#__PURE__*/function () {\n  var _ref = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee(proxy, renderedBuffer, nativeOfflineAudioContext, options, outputChannelCount, processorConstructor, exposeCurrentFrameAndCurrentTime) {\n    var length, numberOfInputChannels, numberOfOutputChannels, processedBuffer, audioNodeConnections, audioWorkletProcessor, inputs, outputs, parameters, _loop, i, _ret;\n    return _regeneratorRuntime().wrap(function _callee$(_context2) {\n      while (1) switch (_context2.prev = _context2.next) {\n        case 0:\n          // Ceil the length to the next full render quantum.\n          // Bug #17: Safari does not yet expose the length.\n          length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n          numberOfInputChannels = options.channelCount * options.numberOfInputs;\n          numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n            return sum + value;\n          }, 0);\n          processedBuffer = numberOfOutputChannels === 0 ? null : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n          if (!(processorConstructor === undefined)) {\n            _context2.next = 6;\n            break;\n          }\n          throw new Error('Missing the processor constructor.');\n        case 6:\n          audioNodeConnections = getAudioNodeConnections(proxy);\n          _context2.next = 9;\n          return getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n        case 9:\n          audioWorkletProcessor = _context2.sent;\n          inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n          outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n          parameters = Array.from(proxy.parameters.keys()).reduce(function (prmtrs, name) {\n            return _objectSpread(_objectSpread({}, prmtrs), {}, _defineProperty({}, name, new Float32Array(128)));\n          }, {});\n          _loop = /*#__PURE__*/_regeneratorRuntime().mark(function _loop(i) {\n            var j, k, _j, _k, potentiallyEmptyInputs, activeSourceFlag, _j2, outputChannelSplitterNodeOutput, _k2;\n            return _regeneratorRuntime().wrap(function _loop$(_context) {\n              while (1) switch (_context.prev = _context.next) {\n                case 0:\n                  if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n                    for (j = 0; j < options.numberOfInputs; j += 1) {\n                      for (k = 0; k < options.channelCount; k += 1) {\n                        copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                      }\n                    }\n                  }\n                  if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n                    processorConstructor.parameterDescriptors.forEach(function (_ref2, index) {\n                      var name = _ref2.name;\n                      copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n                    });\n                  }\n                  for (_j = 0; _j < options.numberOfInputs; _j += 1) {\n                    for (_k = 0; _k < outputChannelCount[_j]; _k += 1) {\n                      // The byteLength will be 0 when the ArrayBuffer was transferred.\n                      if (outputs[_j][_k].byteLength === 0) {\n                        outputs[_j][_k] = new Float32Array(128);\n                      }\n                    }\n                  }\n                  _context.prev = 3;\n                  potentiallyEmptyInputs = inputs.map(function (input, index) {\n                    if (audioNodeConnections.activeInputs[index].size === 0) {\n                      return [];\n                    }\n                    return input;\n                  });\n                  activeSourceFlag = exposeCurrentFrameAndCurrentTime(i / nativeOfflineAudioContext.sampleRate, nativeOfflineAudioContext.sampleRate, function () {\n                    return audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters);\n                  });\n                  if (processedBuffer !== null) {\n                    for (_j2 = 0, outputChannelSplitterNodeOutput = 0; _j2 < options.numberOfOutputs; _j2 += 1) {\n                      for (_k2 = 0; _k2 < outputChannelCount[_j2]; _k2 += 1) {\n                        copyToChannel(processedBuffer, outputs[_j2], _k2, outputChannelSplitterNodeOutput + _k2, i);\n                      }\n                      outputChannelSplitterNodeOutput += outputChannelCount[_j2];\n                    }\n                  }\n                  if (activeSourceFlag) {\n                    _context.next = 9;\n                    break;\n                  }\n                  return _context.abrupt(\"return\", \"break\");\n                case 9:\n                  _context.next = 15;\n                  break;\n                case 11:\n                  _context.prev = 11;\n                  _context.t0 = _context[\"catch\"](3);\n                  proxy.dispatchEvent(new ErrorEvent('processorerror', {\n                    colno: _context.t0.colno,\n                    filename: _context.t0.filename,\n                    lineno: _context.t0.lineno,\n                    message: _context.t0.message\n                  }));\n                  return _context.abrupt(\"return\", \"break\");\n                case 15:\n                case \"end\":\n                  return _context.stop();\n              }\n            }, _loop, null, [[3, 11]]);\n          });\n          i = 0;\n        case 15:\n          if (!(i < length)) {\n            _context2.next = 23;\n            break;\n          }\n          return _context2.delegateYield(_loop(i), \"t0\", 17);\n        case 17:\n          _ret = _context2.t0;\n          if (!(_ret === \"break\")) {\n            _context2.next = 20;\n            break;\n          }\n          return _context2.abrupt(\"break\", 23);\n        case 20:\n          i += 128;\n          _context2.next = 15;\n          break;\n        case 23:\n          return _context2.abrupt(\"return\", processedBuffer);\n        case 24:\n        case \"end\":\n          return _context2.stop();\n      }\n    }, _callee);\n  }));\n  return function processBuffer(_x, _x2, _x3, _x4, _x5, _x6, _x7) {\n    return _ref.apply(this, arguments);\n  };\n}();\nexport var createAudioWorkletNodeRendererFactory = function createAudioWorkletNodeRendererFactory(connectAudioParam, connectMultipleOutputs, createNativeAudioBufferSourceNode, createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeConstantSourceNode, createNativeGainNode, deleteUnrenderedAudioWorkletNode, disconnectMultipleOutputs, exposeCurrentFrameAndCurrentTime, getNativeAudioNode, nativeAudioWorkletNodeConstructor, nativeOfflineAudioContextConstructor, renderAutomation, renderInputsOfAudioNode, renderNativeOfflineAudioContext) {\n  return function (name, options, processorConstructor) {\n    var renderedNativeAudioNodes = new WeakMap();\n    var processedBufferPromise = null;\n    var createAudioNode = /*#__PURE__*/function () {\n      var _ref3 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee4(proxy, nativeOfflineAudioContext) {\n        var nativeAudioWorkletNode, nativeOutputNodes, nativeAudioWorkletNodeIsOwnedByContext, outputChannelCount, numberOfOutputChannels, outputChannelSplitterNode, outputChannelMergerNodes, i, outputGainNode, numberOfInputChannels, numberOfParameters, numberOfChannels, renderBuffer, processedBuffer, audioBufferSourceNode, _nativeOutputNodes, _nativeOutputNodes2, _outputChannelSplitterNode, _outputChannelMergerNodes, _outputGainNode, _i3, outputChannelSplitterNodeOutput, outputChannelMergerNode, j, _iterator2, _step2, _step2$value, nm, audioParam, _iterator3, _step3, _step3$value, _nm, _audioParam;\n        return _regeneratorRuntime().wrap(function _callee4$(_context5) {\n          while (1) switch (_context5.prev = _context5.next) {\n            case 0:\n              nativeAudioWorkletNode = getNativeAudioNode(proxy);\n              nativeOutputNodes = null;\n              nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n              outputChannelCount = Array.isArray(options.outputChannelCount) ? options.outputChannelCount : Array.from(options.outputChannelCount); // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n              if (nativeAudioWorkletNodeConstructor === null) {\n                numberOfOutputChannels = outputChannelCount.reduce(function (sum, value) {\n                  return sum + value;\n                }, 0);\n                outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                  channelCount: Math.max(1, numberOfOutputChannels),\n                  channelCountMode: 'explicit',\n                  channelInterpretation: 'discrete',\n                  numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                outputChannelMergerNodes = [];\n                for (i = 0; i < proxy.numberOfOutputs; i += 1) {\n                  outputChannelMergerNodes.push(createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                    channelCount: 1,\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'speakers',\n                    numberOfInputs: outputChannelCount[i]\n                  }));\n                }\n                outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                  channelCount: options.channelCount,\n                  channelCountMode: options.channelCountMode,\n                  channelInterpretation: options.channelInterpretation,\n                  gain: 1\n                });\n                outputGainNode.connect = connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n              } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n              }\n              renderedNativeAudioNodes.set(nativeOfflineAudioContext, nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]);\n              if (!(nativeOutputNodes !== null)) {\n                _context5.next = 41;\n                break;\n              }\n              if (!(processedBufferPromise === null)) {\n                _context5.next = 32;\n                break;\n              }\n              if (!(processorConstructor === undefined)) {\n                _context5.next = 10;\n                break;\n              }\n              throw new Error('Missing the processor constructor.');\n            case 10:\n              if (!(nativeOfflineAudioContextConstructor === null)) {\n                _context5.next = 12;\n                break;\n              }\n              throw new Error('Missing the native OfflineAudioContext constructor.');\n            case 12:\n              // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n              numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n              numberOfParameters = processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n              numberOfChannels = numberOfInputChannels + numberOfParameters;\n              renderBuffer = /*#__PURE__*/function () {\n                var _ref4 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n                  var partialOfflineAudioContext, gainNodes, inputChannelSplitterNodes, _i, constantSourceNodes, inputChannelMergerNode, _i2, j, _iterator, _step, _step$value, index, constantSourceNode;\n                  return _regeneratorRuntime().wrap(function _callee3$(_context4) {\n                    while (1) switch (_context4.prev = _context4.next) {\n                      case 0:\n                        partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(numberOfChannels,\n                        // Ceil the length to the next full render quantum.\n                        // Bug #17: Safari does not yet expose the length.\n                        Math.ceil(proxy.context.length / 128) * 128, nativeOfflineAudioContext.sampleRate);\n                        gainNodes = [];\n                        inputChannelSplitterNodes = [];\n                        for (_i = 0; _i < options.numberOfInputs; _i += 1) {\n                          gainNodes.push(createNativeGainNode(partialOfflineAudioContext, {\n                            channelCount: options.channelCount,\n                            channelCountMode: options.channelCountMode,\n                            channelInterpretation: options.channelInterpretation,\n                            gain: 1\n                          }));\n                          inputChannelSplitterNodes.push(createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                            channelCount: options.channelCount,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'discrete',\n                            numberOfOutputs: options.channelCount\n                          }));\n                        }\n                        _context4.next = 6;\n                        return Promise.all(Array.from(proxy.parameters.values()).map( /*#__PURE__*/function () {\n                          var _ref5 = _asyncToGenerator( /*#__PURE__*/_regeneratorRuntime().mark(function _callee2(audioParam) {\n                            var constantSourceNode;\n                            return _regeneratorRuntime().wrap(function _callee2$(_context3) {\n                              while (1) switch (_context3.prev = _context3.next) {\n                                case 0:\n                                  constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                  });\n                                  _context3.next = 3;\n                                  return renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n                                case 3:\n                                  return _context3.abrupt(\"return\", constantSourceNode);\n                                case 4:\n                                case \"end\":\n                                  return _context3.stop();\n                              }\n                            }, _callee2);\n                          }));\n                          return function (_x10) {\n                            return _ref5.apply(this, arguments);\n                          };\n                        }()));\n                      case 6:\n                        constantSourceNodes = _context4.sent;\n                        inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                          channelCount: 1,\n                          channelCountMode: 'explicit',\n                          channelInterpretation: 'speakers',\n                          numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n                        for (_i2 = 0; _i2 < options.numberOfInputs; _i2 += 1) {\n                          gainNodes[_i2].connect(inputChannelSplitterNodes[_i2]);\n                          for (j = 0; j < options.channelCount; j += 1) {\n                            inputChannelSplitterNodes[_i2].connect(inputChannelMergerNode, j, _i2 * options.channelCount + j);\n                          }\n                        }\n                        _iterator = _createForOfIteratorHelper(constantSourceNodes.entries());\n                        try {\n                          for (_iterator.s(); !(_step = _iterator.n()).done;) {\n                            _step$value = _slicedToArray(_step.value, 2), index = _step$value[0], constantSourceNode = _step$value[1];\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                          }\n                        } catch (err) {\n                          _iterator.e(err);\n                        } finally {\n                          _iterator.f();\n                        }\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n                        _context4.next = 14;\n                        return Promise.all(gainNodes.map(function (gainNode) {\n                          return renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode);\n                        }));\n                      case 14:\n                        return _context4.abrupt(\"return\", renderNativeOfflineAudioContext(partialOfflineAudioContext));\n                      case 15:\n                      case \"end\":\n                        return _context4.stop();\n                    }\n                  }, _callee3);\n                }));\n                return function renderBuffer() {\n                  return _ref4.apply(this, arguments);\n                };\n              }();\n              _context5.t0 = processBuffer;\n              _context5.t1 = proxy;\n              if (!(numberOfChannels === 0)) {\n                _context5.next = 22;\n                break;\n              }\n              _context5.t2 = null;\n              _context5.next = 25;\n              break;\n            case 22:\n              _context5.next = 24;\n              return renderBuffer();\n            case 24:\n              _context5.t2 = _context5.sent;\n            case 25:\n              _context5.t3 = _context5.t2;\n              _context5.t4 = nativeOfflineAudioContext;\n              _context5.t5 = options;\n              _context5.t6 = outputChannelCount;\n              _context5.t7 = processorConstructor;\n              _context5.t8 = exposeCurrentFrameAndCurrentTime;\n              processedBufferPromise = (0, _context5.t0)(_context5.t1, _context5.t3, _context5.t4, _context5.t5, _context5.t6, _context5.t7, _context5.t8);\n            case 32:\n              _context5.next = 34;\n              return processedBufferPromise;\n            case 34:\n              processedBuffer = _context5.sent;\n              audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                buffer: null,\n                channelCount: 2,\n                channelCountMode: 'max',\n                channelInterpretation: 'speakers',\n                loop: false,\n                loopEnd: 0,\n                loopStart: 0,\n                playbackRate: 1\n              });\n              _nativeOutputNodes = nativeOutputNodes, _nativeOutputNodes2 = _slicedToArray(_nativeOutputNodes, 3), _outputChannelSplitterNode = _nativeOutputNodes2[0], _outputChannelMergerNodes = _nativeOutputNodes2[1], _outputGainNode = _nativeOutputNodes2[2];\n              if (processedBuffer !== null) {\n                audioBufferSourceNode.buffer = processedBuffer;\n                audioBufferSourceNode.start(0);\n              }\n              audioBufferSourceNode.connect(_outputChannelSplitterNode);\n              for (_i3 = 0, outputChannelSplitterNodeOutput = 0; _i3 < proxy.numberOfOutputs; _i3 += 1) {\n                outputChannelMergerNode = _outputChannelMergerNodes[_i3];\n                for (j = 0; j < outputChannelCount[_i3]; j += 1) {\n                  _outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                }\n                outputChannelSplitterNodeOutput += outputChannelCount[_i3];\n              }\n              return _context5.abrupt(\"return\", _outputGainNode);\n            case 41:\n              if (nativeAudioWorkletNodeIsOwnedByContext) {\n                _context5.next = 61;\n                break;\n              }\n              _iterator2 = _createForOfIteratorHelper(proxy.parameters.entries());\n              _context5.prev = 43;\n              _iterator2.s();\n            case 45:\n              if ((_step2 = _iterator2.n()).done) {\n                _context5.next = 51;\n                break;\n              }\n              _step2$value = _slicedToArray(_step2.value, 2), nm = _step2$value[0], audioParam = _step2$value[1];\n              _context5.next = 49;\n              return renderAutomation(nativeOfflineAudioContext, audioParam,\n              // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              nativeAudioWorkletNode.parameters.get(nm));\n            case 49:\n              _context5.next = 45;\n              break;\n            case 51:\n              _context5.next = 56;\n              break;\n            case 53:\n              _context5.prev = 53;\n              _context5.t9 = _context5[\"catch\"](43);\n              _iterator2.e(_context5.t9);\n            case 56:\n              _context5.prev = 56;\n              _iterator2.f();\n              return _context5.finish(56);\n            case 59:\n              _context5.next = 78;\n              break;\n            case 61:\n              _iterator3 = _createForOfIteratorHelper(proxy.parameters.entries());\n              _context5.prev = 62;\n              _iterator3.s();\n            case 64:\n              if ((_step3 = _iterator3.n()).done) {\n                _context5.next = 70;\n                break;\n              }\n              _step3$value = _slicedToArray(_step3.value, 2), _nm = _step3$value[0], _audioParam = _step3$value[1];\n              _context5.next = 68;\n              return connectAudioParam(nativeOfflineAudioContext, _audioParam,\n              // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n              nativeAudioWorkletNode.parameters.get(_nm));\n            case 68:\n              _context5.next = 64;\n              break;\n            case 70:\n              _context5.next = 75;\n              break;\n            case 72:\n              _context5.prev = 72;\n              _context5.t10 = _context5[\"catch\"](62);\n              _iterator3.e(_context5.t10);\n            case 75:\n              _context5.prev = 75;\n              _iterator3.f();\n              return _context5.finish(75);\n            case 78:\n              _context5.next = 80;\n              return renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n            case 80:\n              return _context5.abrupt(\"return\", nativeAudioWorkletNode);\n            case 81:\n            case \"end\":\n              return _context5.stop();\n          }\n        }, _callee4, null, [[43, 53, 56, 59], [62, 72, 75, 78]]);\n      }));\n      return function createAudioNode(_x8, _x9) {\n        return _ref3.apply(this, arguments);\n      };\n    }();\n    return {\n      render: function render(proxy, nativeOfflineAudioContext) {\n        deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n        var renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n        if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n          return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n        }\n        return createAudioNode(proxy, nativeOfflineAudioContext);\n      }\n    };\n  };\n};","map":{"version":3,"mappings":"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","names":["copyFromChannel","copyToChannel","createNestedArrays","getAudioNodeConnections","getAudioWorkletProcessor","isOwnedByContext","processBuffer","proxy","renderedBuffer","nativeOfflineAudioContext","options","outputChannelCount","processorConstructor","exposeCurrentFrameAndCurrentTime","length","Math","ceil","context","numberOfInputChannels","channelCount","numberOfInputs","numberOfOutputChannels","reduce","sum","value","processedBuffer","createBuffer","sampleRate","undefined","Error","audioNodeConnections","audioWorkletProcessor","inputs","outputs","numberOfOutputs","parameters","Array","from","keys","prmtrs","name","Float32Array","j","k","i","parameterDescriptors","forEach","index","byteLength","potentiallyEmptyInputs","map","input","activeInputs","size","activeSourceFlag","process","outputChannelSplitterNodeOutput","dispatchEvent","ErrorEvent","colno","filename","lineno","message","createAudioWorkletNodeRendererFactory","connectAudioParam","connectMultipleOutputs","createNativeAudioBufferSourceNode","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeConstantSourceNode","createNativeGainNode","deleteUnrenderedAudioWorkletNode","disconnectMultipleOutputs","getNativeAudioNode","nativeAudioWorkletNodeConstructor","nativeOfflineAudioContextConstructor","renderAutomation","renderInputsOfAudioNode","renderNativeOfflineAudioContext","renderedNativeAudioNodes","WeakMap","processedBufferPromise","createAudioNode","nativeAudioWorkletNode","nativeOutputNodes","nativeAudioWorkletNodeIsOwnedByContext","isArray","outputChannelSplitterNode","max","channelCountMode","channelInterpretation","outputChannelMergerNodes","push","outputGainNode","gain","connect","bind","disconnect","set","numberOfParameters","numberOfChannels","renderBuffer","partialOfflineAudioContext","gainNodes","inputChannelSplitterNodes","Promise","all","values","audioParam","constantSourceNode","offset","constantSourceNodes","inputChannelMergerNode","entries","start","destination","gainNode","audioBufferSourceNode","buffer","loop","loopEnd","loopStart","playbackRate","outputChannelMergerNode","nm","get","render","renderedNativeAudioWorkletNodeOrGainNode","resolve"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-worklet-node-renderer-factory.ts"],"sourcesContent":["import { copyFromChannel } from '../helpers/copy-from-channel';\nimport { copyToChannel } from '../helpers/copy-to-channel';\nimport { createNestedArrays } from '../helpers/create-nested-arrays';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioWorkletProcessor } from '../helpers/get-audio-worklet-processor';\nimport { isOwnedByContext } from '../helpers/is-owned-by-context';\nimport {\n    IAudioWorkletNode,\n    IAudioWorkletNodeOptions,\n    IAudioWorkletProcessorConstructor,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport {\n    TAudioWorkletNodeRendererFactoryFactory,\n    TExposeCurrentFrameAndCurrentTimeFunction,\n    TNativeAudioBuffer,\n    TNativeAudioNode,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode,\n    TNativeChannelMergerNode,\n    TNativeChannelSplitterNode,\n    TNativeGainNode,\n    TNativeOfflineAudioContext\n} from '../types';\n\nconst processBuffer = async <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n    proxy: IAudioWorkletNode<T>,\n    renderedBuffer: null | TNativeAudioBuffer,\n    nativeOfflineAudioContext: TNativeOfflineAudioContext,\n    options: IAudioWorkletNodeOptions,\n    outputChannelCount: number[],\n    processorConstructor: undefined | IAudioWorkletProcessorConstructor,\n    exposeCurrentFrameAndCurrentTime: TExposeCurrentFrameAndCurrentTimeFunction\n): Promise<null | TNativeAudioBuffer> => {\n    // Ceil the length to the next full render quantum.\n    // Bug #17: Safari does not yet expose the length.\n    const length = renderedBuffer === null ? Math.ceil(proxy.context.length / 128) * 128 : renderedBuffer.length;\n    const numberOfInputChannels = options.channelCount * options.numberOfInputs;\n    const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n    const processedBuffer =\n        numberOfOutputChannels === 0\n            ? null\n            : nativeOfflineAudioContext.createBuffer(numberOfOutputChannels, length, nativeOfflineAudioContext.sampleRate);\n\n    if (processorConstructor === undefined) {\n        throw new Error('Missing the processor constructor.');\n    }\n\n    const audioNodeConnections = getAudioNodeConnections(proxy);\n    const audioWorkletProcessor = await getAudioWorkletProcessor(nativeOfflineAudioContext, proxy);\n    const inputs = createNestedArrays(options.numberOfInputs, options.channelCount);\n    const outputs = createNestedArrays(options.numberOfOutputs, outputChannelCount);\n    const parameters: { [name: string]: Float32Array } = Array.from(proxy.parameters.keys()).reduce(\n        (prmtrs, name) => ({ ...prmtrs, [name]: new Float32Array(128) }),\n        {}\n    );\n\n    for (let i = 0; i < length; i += 128) {\n        if (options.numberOfInputs > 0 && renderedBuffer !== null) {\n            for (let j = 0; j < options.numberOfInputs; j += 1) {\n                for (let k = 0; k < options.channelCount; k += 1) {\n                    copyFromChannel(renderedBuffer, inputs[j], k, k, i);\n                }\n            }\n        }\n\n        if (processorConstructor.parameterDescriptors !== undefined && renderedBuffer !== null) {\n            processorConstructor.parameterDescriptors.forEach(({ name }, index) => {\n                copyFromChannel(renderedBuffer, parameters, name, numberOfInputChannels + index, i);\n            });\n        }\n\n        for (let j = 0; j < options.numberOfInputs; j += 1) {\n            for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                // The byteLength will be 0 when the ArrayBuffer was transferred.\n                if (outputs[j][k].byteLength === 0) {\n                    outputs[j][k] = new Float32Array(128);\n                }\n            }\n        }\n\n        try {\n            const potentiallyEmptyInputs = inputs.map((input, index) => {\n                if (audioNodeConnections.activeInputs[index].size === 0) {\n                    return [];\n                }\n\n                return input;\n            });\n            const activeSourceFlag = exposeCurrentFrameAndCurrentTime(\n                i / nativeOfflineAudioContext.sampleRate,\n                nativeOfflineAudioContext.sampleRate,\n                () => audioWorkletProcessor.process(potentiallyEmptyInputs, outputs, parameters)\n            );\n\n            if (processedBuffer !== null) {\n                for (let j = 0, outputChannelSplitterNodeOutput = 0; j < options.numberOfOutputs; j += 1) {\n                    for (let k = 0; k < outputChannelCount[j]; k += 1) {\n                        copyToChannel(processedBuffer, outputs[j], k, outputChannelSplitterNodeOutput + k, i);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[j];\n                }\n            }\n\n            if (!activeSourceFlag) {\n                break;\n            }\n        } catch (error) {\n            proxy.dispatchEvent(\n                new ErrorEvent('processorerror', {\n                    colno: error.colno,\n                    filename: error.filename,\n                    lineno: error.lineno,\n                    message: error.message\n                })\n            );\n\n            break;\n        }\n    }\n\n    return processedBuffer;\n};\n\nexport const createAudioWorkletNodeRendererFactory: TAudioWorkletNodeRendererFactoryFactory = (\n    connectAudioParam,\n    connectMultipleOutputs,\n    createNativeAudioBufferSourceNode,\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeConstantSourceNode,\n    createNativeGainNode,\n    deleteUnrenderedAudioWorkletNode,\n    disconnectMultipleOutputs,\n    exposeCurrentFrameAndCurrentTime,\n    getNativeAudioNode,\n    nativeAudioWorkletNodeConstructor,\n    nativeOfflineAudioContextConstructor,\n    renderAutomation,\n    renderInputsOfAudioNode,\n    renderNativeOfflineAudioContext\n) => {\n    return <T extends IMinimalOfflineAudioContext | IOfflineAudioContext>(\n        name: string,\n        options: IAudioWorkletNodeOptions,\n        processorConstructor: undefined | IAudioWorkletProcessorConstructor\n    ) => {\n        const renderedNativeAudioNodes = new WeakMap<TNativeOfflineAudioContext, TNativeAudioWorkletNode | TNativeGainNode>();\n\n        let processedBufferPromise: null | Promise<null | TNativeAudioBuffer> = null;\n\n        const createAudioNode = async (proxy: IAudioWorkletNode<T>, nativeOfflineAudioContext: TNativeOfflineAudioContext) => {\n            let nativeAudioWorkletNode = getNativeAudioNode<T, TNativeAudioWorkletNode>(proxy);\n            let nativeOutputNodes: null | [TNativeChannelSplitterNode, TNativeChannelMergerNode[], TNativeGainNode] = null;\n\n            const nativeAudioWorkletNodeIsOwnedByContext = isOwnedByContext(nativeAudioWorkletNode, nativeOfflineAudioContext);\n            const outputChannelCount = Array.isArray(options.outputChannelCount)\n                ? options.outputChannelCount\n                : Array.from(options.outputChannelCount);\n\n            // Bug #61: Only Chrome, Edge & Firefox have an implementation of the AudioWorkletNode yet.\n            if (nativeAudioWorkletNodeConstructor === null) {\n                const numberOfOutputChannels = outputChannelCount.reduce((sum, value) => sum + value, 0);\n                const outputChannelSplitterNode = createNativeChannelSplitterNode(nativeOfflineAudioContext, {\n                    channelCount: Math.max(1, numberOfOutputChannels),\n                    channelCountMode: 'explicit',\n                    channelInterpretation: 'discrete',\n                    numberOfOutputs: Math.max(1, numberOfOutputChannels)\n                });\n                const outputChannelMergerNodes: TNativeChannelMergerNode[] = [];\n\n                for (let i = 0; i < proxy.numberOfOutputs; i += 1) {\n                    outputChannelMergerNodes.push(\n                        createNativeChannelMergerNode(nativeOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: outputChannelCount[i]\n                        })\n                    );\n                }\n\n                const outputGainNode = createNativeGainNode(nativeOfflineAudioContext, {\n                    channelCount: options.channelCount,\n                    channelCountMode: options.channelCountMode,\n                    channelInterpretation: options.channelInterpretation,\n                    gain: 1\n                });\n\n                outputGainNode.connect = <TNativeAudioNode['connect']>connectMultipleOutputs.bind(null, outputChannelMergerNodes);\n                outputGainNode.disconnect = <TNativeAudioNode['disconnect']>disconnectMultipleOutputs.bind(null, outputChannelMergerNodes);\n\n                nativeOutputNodes = [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode];\n            } else if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                nativeAudioWorkletNode = new nativeAudioWorkletNodeConstructor(nativeOfflineAudioContext, name);\n            }\n\n            renderedNativeAudioNodes.set(\n                nativeOfflineAudioContext,\n                nativeOutputNodes === null ? nativeAudioWorkletNode : nativeOutputNodes[2]\n            );\n\n            if (nativeOutputNodes !== null) {\n                if (processedBufferPromise === null) {\n                    if (processorConstructor === undefined) {\n                        throw new Error('Missing the processor constructor.');\n                    }\n\n                    if (nativeOfflineAudioContextConstructor === null) {\n                        throw new Error('Missing the native OfflineAudioContext constructor.');\n                    }\n\n                    // Bug #47: The AudioDestinationNode in Safari gets not initialized correctly.\n                    const numberOfInputChannels = proxy.channelCount * proxy.numberOfInputs;\n                    const numberOfParameters =\n                        processorConstructor.parameterDescriptors === undefined ? 0 : processorConstructor.parameterDescriptors.length;\n                    const numberOfChannels = numberOfInputChannels + numberOfParameters;\n\n                    const renderBuffer = async () => {\n                        const partialOfflineAudioContext = new nativeOfflineAudioContextConstructor(\n                            numberOfChannels,\n                            // Ceil the length to the next full render quantum.\n                            // Bug #17: Safari does not yet expose the length.\n                            Math.ceil(proxy.context.length / 128) * 128,\n                            nativeOfflineAudioContext.sampleRate\n                        );\n                        const gainNodes: TNativeGainNode[] = [];\n                        const inputChannelSplitterNodes = [];\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes.push(\n                                createNativeGainNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: options.channelCountMode,\n                                    channelInterpretation: options.channelInterpretation,\n                                    gain: 1\n                                })\n                            );\n                            inputChannelSplitterNodes.push(\n                                createNativeChannelSplitterNode(partialOfflineAudioContext, {\n                                    channelCount: options.channelCount,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    numberOfOutputs: options.channelCount\n                                })\n                            );\n                        }\n\n                        const constantSourceNodes = await Promise.all(\n                            Array.from(proxy.parameters.values()).map(async (audioParam) => {\n                                const constantSourceNode = createNativeConstantSourceNode(partialOfflineAudioContext, {\n                                    channelCount: 1,\n                                    channelCountMode: 'explicit',\n                                    channelInterpretation: 'discrete',\n                                    offset: audioParam.value\n                                });\n\n                                await renderAutomation(partialOfflineAudioContext, audioParam, constantSourceNode.offset);\n\n                                return constantSourceNode;\n                            })\n                        );\n\n                        const inputChannelMergerNode = createNativeChannelMergerNode(partialOfflineAudioContext, {\n                            channelCount: 1,\n                            channelCountMode: 'explicit',\n                            channelInterpretation: 'speakers',\n                            numberOfInputs: Math.max(1, numberOfInputChannels + numberOfParameters)\n                        });\n\n                        for (let i = 0; i < options.numberOfInputs; i += 1) {\n                            gainNodes[i].connect(inputChannelSplitterNodes[i]);\n\n                            for (let j = 0; j < options.channelCount; j += 1) {\n                                inputChannelSplitterNodes[i].connect(inputChannelMergerNode, j, i * options.channelCount + j);\n                            }\n                        }\n\n                        for (const [index, constantSourceNode] of constantSourceNodes.entries()) {\n                            constantSourceNode.connect(inputChannelMergerNode, 0, numberOfInputChannels + index);\n                            constantSourceNode.start(0);\n                        }\n\n                        inputChannelMergerNode.connect(partialOfflineAudioContext.destination);\n\n                        await Promise.all(\n                            gainNodes.map((gainNode) => renderInputsOfAudioNode(proxy, partialOfflineAudioContext, gainNode))\n                        );\n\n                        return renderNativeOfflineAudioContext(partialOfflineAudioContext);\n                    };\n\n                    processedBufferPromise = processBuffer(\n                        proxy,\n                        numberOfChannels === 0 ? null : await renderBuffer(),\n                        nativeOfflineAudioContext,\n                        options,\n                        outputChannelCount,\n                        processorConstructor,\n                        exposeCurrentFrameAndCurrentTime\n                    );\n                }\n\n                const processedBuffer = await processedBufferPromise;\n                const audioBufferSourceNode = createNativeAudioBufferSourceNode(nativeOfflineAudioContext, {\n                    buffer: null,\n                    channelCount: 2,\n                    channelCountMode: 'max',\n                    channelInterpretation: 'speakers',\n                    loop: false,\n                    loopEnd: 0,\n                    loopStart: 0,\n                    playbackRate: 1\n                });\n                const [outputChannelSplitterNode, outputChannelMergerNodes, outputGainNode] = nativeOutputNodes;\n\n                if (processedBuffer !== null) {\n                    audioBufferSourceNode.buffer = processedBuffer;\n                    audioBufferSourceNode.start(0);\n                }\n\n                audioBufferSourceNode.connect(outputChannelSplitterNode);\n\n                for (let i = 0, outputChannelSplitterNodeOutput = 0; i < proxy.numberOfOutputs; i += 1) {\n                    const outputChannelMergerNode = outputChannelMergerNodes[i];\n\n                    for (let j = 0; j < outputChannelCount[i]; j += 1) {\n                        outputChannelSplitterNode.connect(outputChannelMergerNode, outputChannelSplitterNodeOutput + j, j);\n                    }\n\n                    outputChannelSplitterNodeOutput += outputChannelCount[i];\n                }\n\n                return outputGainNode;\n            }\n\n            if (!nativeAudioWorkletNodeIsOwnedByContext) {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await renderAutomation(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            } else {\n                for (const [nm, audioParam] of proxy.parameters.entries()) {\n                    await connectAudioParam(\n                        nativeOfflineAudioContext,\n                        audioParam,\n                        // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                        <TNativeAudioParam>(<IReadOnlyMap<string, TNativeAudioParam>>nativeAudioWorkletNode.parameters).get(nm)\n                    );\n                }\n            }\n\n            await renderInputsOfAudioNode(proxy, nativeOfflineAudioContext, nativeAudioWorkletNode);\n\n            return nativeAudioWorkletNode;\n        };\n\n        return {\n            render(\n                proxy: IAudioWorkletNode<T>,\n                nativeOfflineAudioContext: TNativeOfflineAudioContext\n            ): Promise<TNativeAudioWorkletNode | TNativeGainNode> {\n                deleteUnrenderedAudioWorkletNode(nativeOfflineAudioContext, proxy);\n\n                const renderedNativeAudioWorkletNodeOrGainNode = renderedNativeAudioNodes.get(nativeOfflineAudioContext);\n\n                if (renderedNativeAudioWorkletNodeOrGainNode !== undefined) {\n                    return Promise.resolve(renderedNativeAudioWorkletNodeOrGainNode);\n                }\n\n                return createAudioNode(proxy, nativeOfflineAudioContext);\n            }\n        };\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport var IntervalTimeline = /*#__PURE__*/function (_Tone) {\n  _inherits(IntervalTimeline, _Tone);\n  var _super = _createSuper(IntervalTimeline);\n  function IntervalTimeline() {\n    var _this;\n    _classCallCheck(this, IntervalTimeline);\n    _this = _super.apply(this, arguments);\n    _this.name = \"IntervalTimeline\";\n    /**\n     * The root node of the inteval tree\n     */\n    _this._root = null;\n    /**\n     * Keep track of the length of the timeline.\n     */\n    _this._length = 0;\n    return _this;\n  }\n  /**\n   * The event to add to the timeline. All events must\n   * have a time and duration value\n   * @param  event  The event to add to the timeline\n   */\n  _createClass(IntervalTimeline, [{\n    key: \"add\",\n    value: function add(event) {\n      assert(isDefined(event.time), \"Events must have a time property\");\n      assert(isDefined(event.duration), \"Events must have a duration parameter\");\n      event.time = event.time.valueOf();\n      var node = new IntervalNode(event.time, event.time + event.duration, event);\n      if (this._root === null) {\n        this._root = node;\n      } else {\n        this._root.insert(node);\n      }\n      this._length++;\n      // Restructure tree to be balanced\n      while (node !== null) {\n        node.updateHeight();\n        node.updateMax();\n        this._rebalance(node);\n        node = node.parent;\n      }\n      return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  event  The event to remove from the timeline\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(event) {\n      if (this._root !== null) {\n        var results = [];\n        this._root.search(event.time, results);\n        for (var _i = 0, _results = results; _i < _results.length; _i++) {\n          var node = _results[_i];\n          if (node.event === event) {\n            this._removeNode(node);\n            this._length--;\n            break;\n          }\n        }\n      }\n      return this;\n    }\n    /**\n     * The number of items in the timeline.\n     * @readOnly\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._length;\n    }\n    /**\n     * Remove events whose time time is after the given time\n     * @param  after  The time to query.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      var _this2 = this;\n      this.forEachFrom(after, function (event) {\n        return _this2.remove(event);\n      });\n      return this;\n    }\n    /**\n     * Set the root node as the given node\n     */\n  }, {\n    key: \"_setRoot\",\n    value: function _setRoot(node) {\n      this._root = node;\n      if (this._root !== null) {\n        this._root.parent = null;\n      }\n    }\n    /**\n     * Replace the references to the node in the node's parent\n     * with the replacement node.\n     */\n  }, {\n    key: \"_replaceNodeInParent\",\n    value: function _replaceNodeInParent(node, replacement) {\n      if (node.parent !== null) {\n        if (node.isLeftChild()) {\n          node.parent.left = replacement;\n        } else {\n          node.parent.right = replacement;\n        }\n        this._rebalance(node.parent);\n      } else {\n        this._setRoot(replacement);\n      }\n    }\n    /**\n     * Remove the node from the tree and replace it with\n     * a successor which follows the schema.\n     */\n  }, {\n    key: \"_removeNode\",\n    value: function _removeNode(node) {\n      if (node.left === null && node.right === null) {\n        this._replaceNodeInParent(node, null);\n      } else if (node.right === null) {\n        this._replaceNodeInParent(node, node.left);\n      } else if (node.left === null) {\n        this._replaceNodeInParent(node, node.right);\n      } else {\n        var balance = node.getBalance();\n        var replacement;\n        var temp = null;\n        if (balance > 0) {\n          if (node.left.right === null) {\n            replacement = node.left;\n            replacement.right = node.right;\n            temp = replacement;\n          } else {\n            replacement = node.left.right;\n            while (replacement.right !== null) {\n              replacement = replacement.right;\n            }\n            if (replacement.parent) {\n              replacement.parent.right = replacement.left;\n              temp = replacement.parent;\n              replacement.left = node.left;\n              replacement.right = node.right;\n            }\n          }\n        } else if (node.right.left === null) {\n          replacement = node.right;\n          replacement.left = node.left;\n          temp = replacement;\n        } else {\n          replacement = node.right.left;\n          while (replacement.left !== null) {\n            replacement = replacement.left;\n          }\n          if (replacement.parent) {\n            replacement.parent.left = replacement.right;\n            temp = replacement.parent;\n            replacement.left = node.left;\n            replacement.right = node.right;\n          }\n        }\n        if (node.parent !== null) {\n          if (node.isLeftChild()) {\n            node.parent.left = replacement;\n          } else {\n            node.parent.right = replacement;\n          }\n        } else {\n          this._setRoot(replacement);\n        }\n        if (temp) {\n          this._rebalance(temp);\n        }\n      }\n      node.dispose();\n    }\n    /**\n     * Rotate the tree to the left\n     */\n  }, {\n    key: \"_rotateLeft\",\n    value: function _rotateLeft(node) {\n      var parent = node.parent;\n      var isLeftChild = node.isLeftChild();\n      // Make node.right the new root of this sub tree (instead of node)\n      var pivotNode = node.right;\n      if (pivotNode) {\n        node.right = pivotNode.left;\n        pivotNode.left = node;\n      }\n      if (parent !== null) {\n        if (isLeftChild) {\n          parent.left = pivotNode;\n        } else {\n          parent.right = pivotNode;\n        }\n      } else {\n        this._setRoot(pivotNode);\n      }\n    }\n    /**\n     * Rotate the tree to the right\n     */\n  }, {\n    key: \"_rotateRight\",\n    value: function _rotateRight(node) {\n      var parent = node.parent;\n      var isLeftChild = node.isLeftChild();\n      // Make node.left the new root of this sub tree (instead of node)\n      var pivotNode = node.left;\n      if (pivotNode) {\n        node.left = pivotNode.right;\n        pivotNode.right = node;\n      }\n      if (parent !== null) {\n        if (isLeftChild) {\n          parent.left = pivotNode;\n        } else {\n          parent.right = pivotNode;\n        }\n      } else {\n        this._setRoot(pivotNode);\n      }\n    }\n    /**\n     * Balance the BST\n     */\n  }, {\n    key: \"_rebalance\",\n    value: function _rebalance(node) {\n      var balance = node.getBalance();\n      if (balance > 1 && node.left) {\n        if (node.left.getBalance() < 0) {\n          this._rotateLeft(node.left);\n        } else {\n          this._rotateRight(node);\n        }\n      } else if (balance < -1 && node.right) {\n        if (node.right.getBalance() > 0) {\n          this._rotateRight(node.right);\n        } else {\n          this._rotateLeft(node);\n        }\n      }\n    }\n    /**\n     * Get an event whose time and duration span the give time. Will\n     * return the match whose \"time\" value is closest to the given time.\n     * @return  The event which spans the desired time\n     */\n  }, {\n    key: \"get\",\n    value: function get(time) {\n      if (this._root !== null) {\n        var results = [];\n        this._root.search(time, results);\n        if (results.length > 0) {\n          var max = results[0];\n          for (var i = 1; i < results.length; i++) {\n            if (results[i].low > max.low) {\n              max = results[i];\n            }\n          }\n          return max.event;\n        }\n      }\n      return null;\n    }\n    /**\n     * Iterate over everything in the timeline.\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      if (this._root !== null) {\n        var allNodes = [];\n        this._root.traverse(function (node) {\n          return allNodes.push(node);\n        });\n        allNodes.forEach(function (node) {\n          if (node.event) {\n            callback(node.event);\n          }\n        });\n      }\n      return this;\n    }\n    /**\n     * Iterate over everything in the array in which the given time\n     * overlaps with the time and duration time of the event.\n     * @param  time The time to check if items are overlapping\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachAtTime\",\n    value: function forEachAtTime(time, callback) {\n      if (this._root !== null) {\n        var results = [];\n        this._root.search(time, results);\n        results.forEach(function (node) {\n          if (node.event) {\n            callback(node.event);\n          }\n        });\n      }\n      return this;\n    }\n    /**\n     * Iterate over everything in the array in which the time is greater\n     * than or equal to the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachFrom\",\n    value: function forEachFrom(time, callback) {\n      if (this._root !== null) {\n        var results = [];\n        this._root.searchAfter(time, results);\n        results.forEach(function (node) {\n          if (node.event) {\n            callback(node.event);\n          }\n        });\n      }\n      return this;\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(IntervalTimeline.prototype), \"dispose\", this).call(this);\n      if (this._root !== null) {\n        this._root.traverse(function (node) {\n          return node.dispose();\n        });\n      }\n      this._root = null;\n      return this;\n    }\n  }]);\n  return IntervalTimeline;\n}(Tone);\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nvar IntervalNode = /*#__PURE__*/function () {\n  function IntervalNode(low, high, event) {\n    _classCallCheck(this, IntervalNode);\n    // the nodes to the left\n    this._left = null;\n    // the nodes to the right\n    this._right = null;\n    // the parent node\n    this.parent = null;\n    // the number of child nodes\n    this.height = 0;\n    this.event = event;\n    // the low value\n    this.low = low;\n    // the high value\n    this.high = high;\n    // the high value for this and all child nodes\n    this.max = this.high;\n  }\n  /**\n   * Insert a node into the correct spot in the tree\n   */\n  _createClass(IntervalNode, [{\n    key: \"insert\",\n    value: function insert(node) {\n      if (node.low <= this.low) {\n        if (this.left === null) {\n          this.left = node;\n        } else {\n          this.left.insert(node);\n        }\n      } else if (this.right === null) {\n        this.right = node;\n      } else {\n        this.right.insert(node);\n      }\n    }\n    /**\n     * Search the tree for nodes which overlap\n     * with the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n  }, {\n    key: \"search\",\n    value: function search(point, results) {\n      // If p is to the right of the rightmost point of any interval\n      // in this node and all children, there won't be any matches.\n      if (point > this.max) {\n        return;\n      }\n      // Search left children\n      if (this.left !== null) {\n        this.left.search(point, results);\n      }\n      // Check this node\n      if (this.low <= point && this.high > point) {\n        results.push(this);\n      }\n      // If p is to the left of the time of this interval,\n      // then it can't be in any child to the right.\n      if (this.low > point) {\n        return;\n      }\n      // Search right children\n      if (this.right !== null) {\n        this.right.search(point, results);\n      }\n    }\n    /**\n     * Search the tree for nodes which are less\n     * than the given point\n     * @param  point  The point to query\n     * @param  results  The array to put the results\n     */\n  }, {\n    key: \"searchAfter\",\n    value: function searchAfter(point, results) {\n      // Check this node\n      if (this.low >= point) {\n        results.push(this);\n        if (this.left !== null) {\n          this.left.searchAfter(point, results);\n        }\n      }\n      // search the right side\n      if (this.right !== null) {\n        this.right.searchAfter(point, results);\n      }\n    }\n    /**\n     * Invoke the callback on this element and both it's branches\n     * @param  {Function}  callback\n     */\n  }, {\n    key: \"traverse\",\n    value: function traverse(callback) {\n      callback(this);\n      if (this.left !== null) {\n        this.left.traverse(callback);\n      }\n      if (this.right !== null) {\n        this.right.traverse(callback);\n      }\n    }\n    /**\n     * Update the height of the node\n     */\n  }, {\n    key: \"updateHeight\",\n    value: function updateHeight() {\n      if (this.left !== null && this.right !== null) {\n        this.height = Math.max(this.left.height, this.right.height) + 1;\n      } else if (this.right !== null) {\n        this.height = this.right.height + 1;\n      } else if (this.left !== null) {\n        this.height = this.left.height + 1;\n      } else {\n        this.height = 0;\n      }\n    }\n    /**\n     * Update the height of the node\n     */\n  }, {\n    key: \"updateMax\",\n    value: function updateMax() {\n      this.max = this.high;\n      if (this.left !== null) {\n        this.max = Math.max(this.max, this.left.max);\n      }\n      if (this.right !== null) {\n        this.max = Math.max(this.max, this.right.max);\n      }\n    }\n    /**\n     * The balance is how the leafs are distributed on the node\n     * @return  Negative numbers are balanced to the right\n     */\n  }, {\n    key: \"getBalance\",\n    value: function getBalance() {\n      var balance = 0;\n      if (this.left !== null && this.right !== null) {\n        balance = this.left.height - this.right.height;\n      } else if (this.left !== null) {\n        balance = this.left.height + 1;\n      } else if (this.right !== null) {\n        balance = -(this.right.height + 1);\n      }\n      return balance;\n    }\n    /**\n     * @returns true if this node is the left child of its parent\n     */\n  }, {\n    key: \"isLeftChild\",\n    value: function isLeftChild() {\n      return this.parent !== null && this.parent.left === this;\n    }\n    /**\n     * get/set the left node\n     */\n  }, {\n    key: \"left\",\n    get: function get() {\n      return this._left;\n    },\n    set: function set(node) {\n      this._left = node;\n      if (node !== null) {\n        node.parent = this;\n      }\n      this.updateHeight();\n      this.updateMax();\n    }\n    /**\n     * get/set the right node\n     */\n  }, {\n    key: \"right\",\n    get: function get() {\n      return this._right;\n    },\n    set: function set(node) {\n      this._right = node;\n      if (node !== null) {\n        node.parent = this;\n      }\n      this.updateHeight();\n      this.updateMax();\n    }\n    /**\n     * null out references.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this.parent = null;\n      this._left = null;\n      this._right = null;\n      this.event = null;\n    }\n  }]);\n  return IntervalNode;\n}();","map":{"version":3,"mappings":"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","names":["Tone","isDefined","assert","IntervalTimeline","event","time","duration","valueOf","node","IntervalNode","_root","insert","_length","updateHeight","updateMax","_rebalance","parent","results","search","_removeNode","after","forEachFrom","remove","replacement","isLeftChild","left","right","_setRoot","_replaceNodeInParent","balance","getBalance","temp","dispose","pivotNode","_rotateLeft","_rotateRight","length","max","i","low","callback","allNodes","traverse","push","forEach","searchAfter","high","point","height","Math","_left","_right"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\util\\IntervalTimeline.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { isDefined } from \"./TypeCheck\";\nimport { assert } from \"./Debug\";\n\n/**\n * An IntervalTimeline event must have a time and duration\n */\nexport interface IntervalTimelineEvent {\n\ttime: number;\n\tduration: number;\n\t[propName: string]: any;\n}\n\ntype IteratorCallback = (event: IntervalTimelineEvent) => void;\n\n/**\n * Similar to Tone.Timeline, but all events represent\n * intervals with both \"time\" and \"duration\" times. The\n * events are placed in a tree structure optimized\n * for querying an intersection point with the timeline\n * events. Internally uses an [Interval Tree](https://en.wikipedia.org/wiki/Interval_tree)\n * to represent the data.\n */\nexport class IntervalTimeline extends Tone {\n\n\treadonly name: string = \"IntervalTimeline\";\n\n\t/**\n\t * The root node of the inteval tree\n\t */\n\tprivate _root: IntervalNode | null = null;\n\n\t/**\n\t * Keep track of the length of the timeline.\n\t */\n\tprivate _length = 0;\n\n\t/**\n\t * The event to add to the timeline. All events must\n\t * have a time and duration value\n\t * @param  event  The event to add to the timeline\n\t */\n\tadd(event: IntervalTimelineEvent): this {\n\t\tassert(isDefined(event.time), \"Events must have a time property\");\n\t\tassert(isDefined(event.duration), \"Events must have a duration parameter\");\n\n\t\tevent.time = event.time.valueOf();\n\t\tlet node: IntervalNode | null = new IntervalNode(event.time, event.time + event.duration, event);\n\t\tif (this._root === null) {\n\t\t\tthis._root = node;\n\t\t} else {\n\t\t\tthis._root.insert(node);\n\t\t}\n\t\tthis._length++;\n\t\t// Restructure tree to be balanced\n\t\twhile (node !== null) {\n\t\t\tnode.updateHeight();\n\t\t\tnode.updateMax();\n\t\t\tthis._rebalance(node);\n\t\t\tnode = node.parent;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  event  The event to remove from the timeline\n\t */\n\tremove(event: IntervalTimelineEvent): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(event.time, results);\n\t\t\tfor (const node of results) {\n\t\t\t\tif (node.event === event) {\n\t\t\t\t\tthis._removeNode(node);\n\t\t\t\t\tthis._length--;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t * @readOnly\n\t */\n\tget length(): number {\n\t\treturn this._length;\n\t}\n\n\t/**\n\t * Remove events whose time time is after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tthis.forEachFrom(after, event => this.remove(event));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the root node as the given node\n\t */\n\tprivate _setRoot(node: IntervalNode | null): void {\n\t\tthis._root = node;\n\t\tif (this._root !== null) {\n\t\t\tthis._root.parent = null;\n\t\t}\n\t}\n\n\t/**\n\t * Replace the references to the node in the node's parent\n\t * with the replacement node.\n\t */\n\tprivate _replaceNodeInParent(node: IntervalNode, replacement: IntervalNode | null): void {\n\t\tif (node.parent !== null) {\n\t\t\tif (node.isLeftChild()) {\n\t\t\t\tnode.parent.left = replacement;\n\t\t\t} else {\n\t\t\t\tnode.parent.right = replacement;\n\t\t\t}\n\t\t\tthis._rebalance(node.parent);\n\t\t} else {\n\t\t\tthis._setRoot(replacement);\n\t\t}\n\t}\n\n\t/**\n\t * Remove the node from the tree and replace it with\n\t * a successor which follows the schema.\n\t */\n\tprivate _removeNode(node: IntervalNode): void {\n\t\tif (node.left === null && node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, null);\n\t\t} else if (node.right === null) {\n\t\t\tthis._replaceNodeInParent(node, node.left);\n\t\t} else if (node.left === null) {\n\t\t\tthis._replaceNodeInParent(node, node.right);\n\t\t} else {\n\t\t\tconst balance = node.getBalance();\n\t\t\tlet replacement: IntervalNode;\n\t\t\tlet temp: IntervalNode | null = null;\n\t\t\tif (balance > 0) {\n\t\t\t\tif (node.left.right === null) {\n\t\t\t\t\treplacement = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\ttemp = replacement;\n\t\t\t\t} else {\n\t\t\t\t\treplacement = node.left.right;\n\t\t\t\t\twhile (replacement.right !== null) {\n\t\t\t\t\t\treplacement = replacement.right;\n\t\t\t\t\t}\n\t\t\t\t\tif (replacement.parent) {\n\t\t\t\t\t\treplacement.parent.right = replacement.left;\n\t\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t} else if (node.right.left === null) {\n\t\t\t\treplacement = node.right;\n\t\t\t\treplacement.left = node.left;\n\t\t\t\ttemp = replacement;\n\t\t\t} else {\n\t\t\t\treplacement = node.right.left;\n\t\t\t\twhile (replacement.left !== null) {\n\t\t\t\t\treplacement = replacement.left;\n\t\t\t\t}\n\t\t\t\tif (replacement.parent) {\n\t\t\t\t\treplacement.parent.left = replacement.right;\n\t\t\t\t\ttemp = replacement.parent;\n\t\t\t\t\treplacement.left = node.left;\n\t\t\t\t\treplacement.right = node.right;\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (node.parent !== null) {\n\t\t\t\tif (node.isLeftChild()) {\n\t\t\t\t\tnode.parent.left = replacement;\n\t\t\t\t} else {\n\t\t\t\t\tnode.parent.right = replacement;\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._setRoot(replacement);\n\t\t\t}\n\t\t\tif (temp) {\n\t\t\t\tthis._rebalance(temp);\n\t\t\t}\n\t\t}\n\t\tnode.dispose();\n\t}\n\n\t/**\n\t * Rotate the tree to the left\n\t */\n\tprivate _rotateLeft(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.right the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.right;\n\t\tif (pivotNode) {\n\t\t\tnode.right = pivotNode.left;\n\t\t\tpivotNode.left = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Rotate the tree to the right\n\t */\n\tprivate _rotateRight(node: IntervalNode): void {\n\t\tconst parent = node.parent;\n\t\tconst isLeftChild = node.isLeftChild();\n\n\t\t// Make node.left the new root of this sub tree (instead of node)\n\t\tconst pivotNode = node.left;\n\t\tif (pivotNode) {\n\t\t\tnode.left = pivotNode.right;\n\t\t\tpivotNode.right = node;\n\t\t}\n\n\t\tif (parent !== null) {\n\t\t\tif (isLeftChild) {\n\t\t\t\tparent.left = pivotNode;\n\t\t\t} else {\n\t\t\t\tparent.right = pivotNode;\n\t\t\t}\n\t\t} else {\n\t\t\tthis._setRoot(pivotNode);\n\t\t}\n\t}\n\n\t/**\n\t * Balance the BST\n\t */\n\tprivate _rebalance(node: IntervalNode): void {\n\t\tconst balance = node.getBalance();\n\t\tif (balance > 1 && node.left) {\n\t\t\tif (node.left.getBalance() < 0) {\n\t\t\t\tthis._rotateLeft(node.left);\n\t\t\t} else {\n\t\t\t\tthis._rotateRight(node);\n\t\t\t}\n\t\t} else if (balance < -1 && node.right) {\n\t\t\tif (node.right.getBalance() > 0) {\n\t\t\t\tthis._rotateRight(node.right);\n\t\t\t} else {\n\t\t\t\tthis._rotateLeft(node);\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Get an event whose time and duration span the give time. Will\n\t * return the match whose \"time\" value is closest to the given time.\n\t * @return  The event which spans the desired time\n\t */\n\tget(time: number): IntervalTimelineEvent | null {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tif (results.length > 0) {\n\t\t\t\tlet max = results[0];\n\t\t\t\tfor (let i = 1; i < results.length; i++) {\n\t\t\t\t\tif (results[i].low > max.low) {\n\t\t\t\t\t\tmax = results[i];\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn max.event;\n\t\t\t}\n\t\t}\n\t\treturn null;\n\t}\n\n\t/**\n\t * Iterate over everything in the timeline.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst allNodes: IntervalNode[] = [];\n\t\t\tthis._root.traverse(node => allNodes.push(node));\n\t\t\tallNodes.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the given time\n\t * overlaps with the time and duration time of the event.\n\t * @param  time The time to check if items are overlapping\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.search(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array in which the time is greater\n\t * than or equal to the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: IteratorCallback): this {\n\t\tif (this._root !== null) {\n\t\t\tconst results: IntervalNode[] = [];\n\t\t\tthis._root.searchAfter(time, results);\n\t\t\tresults.forEach(node => {\n\t\t\t\tif (node.event) {\n\t\t\t\t\tcallback(node.event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._root !== null) {\n\t\t\tthis._root.traverse(node => node.dispose());\n\t\t}\n\t\tthis._root = null;\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINTERVAL NODE HELPER\n//-------------------------------------\n\n/**\n * Represents a node in the binary search tree, with the addition\n * of a \"high\" value which keeps track of the highest value of\n * its children.\n * References:\n * https://brooknovak.wordpress.com/2013/12/07/augmented-interval-tree-in-c/\n * http://www.mif.vu.lt/~valdas/ALGORITMAI/LITERATURA/Cormen/Cormen.pdf\n * @param low\n * @param high\n */\nclass IntervalNode {\n\n\t// the event container\n\tevent: IntervalTimelineEvent | null;\n\t// the low value\n\tlow: number;\n\t// the high value\n\thigh: number;\n\t// the high value for this and all child nodes\n\tmax: number;\n\t// the nodes to the left\n\tprivate _left: IntervalNode | null = null;\n\t// the nodes to the right\n\tprivate _right: IntervalNode | null = null;\n\t// the parent node\n\tparent: IntervalNode | null = null;\n\t// the number of child nodes\n\theight = 0;\n\n\tconstructor(low: number, high: number, event: IntervalTimelineEvent) {\n\t\tthis.event = event;\n\t\t// the low value\n\t\tthis.low = low;\n\t\t// the high value\n\t\tthis.high = high;\n\t\t// the high value for this and all child nodes\n\t\tthis.max = this.high;\n\t}\n\n\t/**\n\t * Insert a node into the correct spot in the tree\n\t */\n\tinsert(node: IntervalNode): void {\n\t\tif (node.low <= this.low) {\n\t\t\tif (this.left === null) {\n\t\t\t\tthis.left = node;\n\t\t\t} else {\n\t\t\t\tthis.left.insert(node);\n\t\t\t}\n\t\t} else if (this.right === null) {\n\t\t\tthis.right = node;\n\t\t} else {\n\t\t\tthis.right.insert(node);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which overlap\n\t * with the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearch(point: number, results: IntervalNode[]): void {\n\t\t// If p is to the right of the rightmost point of any interval\n\t\t// in this node and all children, there won't be any matches.\n\t\tif (point > this.max) {\n\t\t\treturn;\n\t\t}\n\t\t// Search left children\n\t\tif (this.left !== null) {\n\t\t\tthis.left.search(point, results);\n\t\t}\n\t\t// Check this node\n\t\tif (this.low <= point && this.high > point) {\n\t\t\tresults.push(this);\n\t\t}\n\t\t// If p is to the left of the time of this interval,\n\t\t// then it can't be in any child to the right.\n\t\tif (this.low > point) {\n\t\t\treturn;\n\t\t}\n\t\t// Search right children\n\t\tif (this.right !== null) {\n\t\t\tthis.right.search(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Search the tree for nodes which are less\n\t * than the given point\n\t * @param  point  The point to query\n\t * @param  results  The array to put the results\n\t */\n\tsearchAfter(point: number, results: IntervalNode[]): void {\n\t\t// Check this node\n\t\tif (this.low >= point) {\n\t\t\tresults.push(this);\n\t\t\tif (this.left !== null) {\n\t\t\t\tthis.left.searchAfter(point, results);\n\t\t\t}\n\t\t}\n\t\t// search the right side\n\t\tif (this.right !== null) {\n\t\t\tthis.right.searchAfter(point, results);\n\t\t}\n\t}\n\n\t/**\n\t * Invoke the callback on this element and both it's branches\n\t * @param  {Function}  callback\n\t */\n\ttraverse(callback: (self: IntervalNode) => void): void {\n\t\tcallback(this);\n\t\tif (this.left !== null) {\n\t\t\tthis.left.traverse(callback);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.right.traverse(callback);\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateHeight(): void {\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tthis.height = Math.max(this.left.height, this.right.height) + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tthis.height = this.right.height + 1;\n\t\t} else if (this.left !== null) {\n\t\t\tthis.height = this.left.height + 1;\n\t\t} else {\n\t\t\tthis.height = 0;\n\t\t}\n\t}\n\n\t/**\n\t * Update the height of the node\n\t */\n\tupdateMax(): void {\n\t\tthis.max = this.high;\n\t\tif (this.left !== null) {\n\t\t\tthis.max = Math.max(this.max, this.left.max);\n\t\t}\n\t\tif (this.right !== null) {\n\t\t\tthis.max = Math.max(this.max, this.right.max);\n\t\t}\n\t}\n\n\t/**\n\t * The balance is how the leafs are distributed on the node\n\t * @return  Negative numbers are balanced to the right\n\t */\n\tgetBalance(): number {\n\t\tlet balance = 0;\n\t\tif (this.left !== null && this.right !== null) {\n\t\t\tbalance = this.left.height - this.right.height;\n\t\t} else if (this.left !== null) {\n\t\t\tbalance = this.left.height + 1;\n\t\t} else if (this.right !== null) {\n\t\t\tbalance = -(this.right.height + 1);\n\t\t}\n\t\treturn balance;\n\t}\n\n\t/**\n\t * @returns true if this node is the left child of its parent\n\t */\n\tisLeftChild(): boolean {\n\t\treturn this.parent !== null && this.parent.left === this;\n\t}\n\n\t/**\n\t * get/set the left node\n\t */\n\tget left(): IntervalNode | null {\n\t\treturn this._left;\n\t}\n\n\tset left(node: IntervalNode | null) {\n\t\tthis._left = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * get/set the right node\n\t */\n\tget right(): IntervalNode | null {\n\t\treturn this._right;\n\t}\n\n\tset right(node: IntervalNode | null) {\n\t\tthis._right = node;\n\t\tif (node !== null) {\n\t\t\tnode.parent = this;\n\t\t}\n\t\tthis.updateHeight();\n\t\tthis.updateMax();\n\t}\n\n\t/**\n\t * null out references.\n\t */\n\tdispose(): void {\n\t\tthis.parent = null;\n\t\tthis._left = null;\n\t\tthis._right = null;\n\t\tthis.event = null;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
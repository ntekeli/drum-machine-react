{"ast":null,"code":"import _objectSpread from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport { ReadOnlyMap } from '../read-only-map';\nvar DEFAULT_OPTIONS = {\n  channelCount: 2,\n  // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n  channelCountMode: 'explicit',\n  channelInterpretation: 'speakers',\n  numberOfInputs: 1,\n  numberOfOutputs: 1,\n  parameterData: {},\n  processorOptions: {}\n};\nexport var createAudioWorkletNodeConstructor = function createAudioWorkletNodeConstructor(addUnrenderedAudioWorkletNode, audioNodeConstructor, createAudioParam, createAudioWorkletNodeRenderer, createNativeAudioWorkletNode, getAudioNodeConnections, getBackupOfflineAudioContext, getNativeContext, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor, sanitizeAudioWorkletNodeOptions, setActiveAudioWorkletNodeInputs, testAudioWorkletNodeOptionsClonability, wrapEventListener) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(AudioWorkletNode, _audioNodeConstructor);\n    var _super = _createSuper(AudioWorkletNode);\n    function AudioWorkletNode(context, name, options) {\n      var _this;\n      _classCallCheck(this, AudioWorkletNode);\n      var _a;\n      var nativeContext = getNativeContext(context);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var mergedOptions = sanitizeAudioWorkletNodeOptions(_objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options));\n      // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n      testAudioWorkletNodeOptionsClonability(mergedOptions);\n      var nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n      var processorConstructor = nodeNameToProcessorConstructorMap === null || nodeNameToProcessorConstructorMap === void 0 ? void 0 : nodeNameToProcessorConstructorMap.get(name);\n      // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n      var nativeContextOrBackupOfflineAudioContext = isOffline || nativeContext.state !== 'closed' ? nativeContext : (_a = getBackupOfflineAudioContext(nativeContext)) !== null && _a !== void 0 ? _a : nativeContext;\n      var nativeAudioWorkletNode = createNativeAudioWorkletNode(nativeContextOrBackupOfflineAudioContext, isOffline ? null : context.baseLatency, nativeAudioWorkletNodeConstructor, name, processorConstructor, mergedOptions);\n      var audioWorkletNodeRenderer = isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null;\n      /*\n       * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n       * returns false.\n       */\n      _this = _super.call(this, context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n      var parameters = [];\n      nativeAudioWorkletNode.parameters.forEach(function (nativeAudioParam, nm) {\n        var audioParam = createAudioParam(_assertThisInitialized(_this), isOffline, nativeAudioParam);\n        parameters.push([nm, audioParam]);\n      });\n      _this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n      _this._onprocessorerror = null;\n      _this._parameters = new ReadOnlyMap(parameters);\n      /*\n       * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n       * the destination.\n       */\n      if (isOffline) {\n        addUnrenderedAudioWorkletNode(nativeContext, _assertThisInitialized(_this));\n      }\n      var _getAudioNodeConnecti = getAudioNodeConnections(_assertThisInitialized(_this)),\n        activeInputs = _getAudioNodeConnecti.activeInputs;\n      setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n      return _this;\n    }\n    _createClass(AudioWorkletNode, [{\n      key: \"onprocessorerror\",\n      get: function get() {\n        return this._onprocessorerror;\n      },\n      set: function set(value) {\n        var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n        this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n        var nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n        this._onprocessorerror = nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener ? value : nativeOnProcessorError;\n      }\n    }, {\n      key: \"parameters\",\n      get: function get() {\n        if (this._parameters === null) {\n          // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n          return this._nativeAudioWorkletNode.parameters;\n        }\n        return this._parameters;\n      }\n    }, {\n      key: \"port\",\n      get: function get() {\n        return this._nativeAudioWorkletNode.port;\n      }\n    }]);\n    return AudioWorkletNode;\n  }(audioNodeConstructor);\n};","map":{"version":3,"mappings":"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","names":["NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS","ReadOnlyMap","DEFAULT_OPTIONS","channelCount","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","parameterData","processorOptions","createAudioWorkletNodeConstructor","addUnrenderedAudioWorkletNode","audioNodeConstructor","createAudioParam","createAudioWorkletNodeRenderer","createNativeAudioWorkletNode","getAudioNodeConnections","getBackupOfflineAudioContext","getNativeContext","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","sanitizeAudioWorkletNodeOptions","setActiveAudioWorkletNodeInputs","testAudioWorkletNodeOptionsClonability","wrapEventListener","context","name","options","nativeContext","isOffline","mergedOptions","nodeNameToProcessorConstructorMap","get","processorConstructor","nativeContextOrBackupOfflineAudioContext","state","nativeAudioWorkletNode","baseLatency","audioWorkletNodeRenderer","parameters","forEach","nativeAudioParam","nm","audioParam","push","_nativeAudioWorkletNode","_onprocessorerror","_parameters","activeInputs","value","wrappedListener","onprocessorerror","nativeOnProcessorError","port"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-worklet-node-constructor.ts"],"sourcesContent":["import { NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS } from '../globals';\nimport {\n    IAudioParam,\n    IAudioWorkletNode,\n    IAudioWorkletNodeEventMap,\n    IAudioWorkletNodeOptions,\n    IMinimalAudioContext,\n    IMinimalOfflineAudioContext,\n    IOfflineAudioContext,\n    IReadOnlyMap\n} from '../interfaces';\nimport { ReadOnlyMap } from '../read-only-map';\nimport {\n    TAudioNodeRenderer,\n    TAudioParamMap,\n    TAudioWorkletNodeConstructorFactory,\n    TContext,\n    TErrorEventHandler,\n    TNativeAudioContext,\n    TNativeAudioParam,\n    TNativeAudioWorkletNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    channelCount: 2,\n    // Bug #61: The channelCountMode should be 'max' according to the spec but is set to 'explicit' to achieve consistent behavior.\n    channelCountMode: 'explicit',\n    channelInterpretation: 'speakers',\n    numberOfInputs: 1,\n    numberOfOutputs: 1,\n    parameterData: {},\n    processorOptions: {}\n} as const;\n\nexport const createAudioWorkletNodeConstructor: TAudioWorkletNodeConstructorFactory = (\n    addUnrenderedAudioWorkletNode,\n    audioNodeConstructor,\n    createAudioParam,\n    createAudioWorkletNodeRenderer,\n    createNativeAudioWorkletNode,\n    getAudioNodeConnections,\n    getBackupOfflineAudioContext,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor,\n    sanitizeAudioWorkletNodeOptions,\n    setActiveAudioWorkletNodeInputs,\n    testAudioWorkletNodeOptionsClonability,\n    wrapEventListener\n) => {\n    return class AudioWorkletNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioWorkletNodeEventMap>\n        implements IAudioWorkletNode<T>\n    {\n        private _nativeAudioWorkletNode: TNativeAudioWorkletNode;\n\n        private _onprocessorerror: null | TErrorEventHandler<this>;\n\n        private _parameters: null | TAudioParamMap;\n\n        constructor(context: T, name: string, options?: Partial<IAudioWorkletNodeOptions>) {\n            const nativeContext = getNativeContext(context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const mergedOptions = sanitizeAudioWorkletNodeOptions({ ...DEFAULT_OPTIONS, ...options });\n\n            // Bug #191: Safari doesn't throw an error if the options aren't clonable.\n            testAudioWorkletNodeOptionsClonability(mergedOptions);\n\n            const nodeNameToProcessorConstructorMap = NODE_NAME_TO_PROCESSOR_CONSTRUCTOR_MAPS.get(nativeContext);\n            const processorConstructor = nodeNameToProcessorConstructorMap?.get(name);\n            // Bug #186: Chrome and Edge do not allow to create an AudioWorkletNode on a closed AudioContext.\n            const nativeContextOrBackupOfflineAudioContext =\n                isOffline || nativeContext.state !== 'closed'\n                    ? nativeContext\n                    : getBackupOfflineAudioContext(<TNativeAudioContext>nativeContext) ?? nativeContext;\n            const nativeAudioWorkletNode = createNativeAudioWorkletNode(\n                nativeContextOrBackupOfflineAudioContext,\n                isOffline ? null : (<IMinimalAudioContext>(<any>context)).baseLatency,\n                nativeAudioWorkletNodeConstructor,\n                name,\n                processorConstructor,\n                mergedOptions\n            );\n            const audioWorkletNodeRenderer = <TAudioNodeRenderer<T, this>>(\n                (isOffline ? createAudioWorkletNodeRenderer(name, mergedOptions, processorConstructor) : null)\n            );\n\n            /*\n             * @todo Add a mechanism to switch an AudioWorkletNode to passive once the process() function of the AudioWorkletProcessor\n             * returns false.\n             */\n            super(context, true, nativeAudioWorkletNode, audioWorkletNodeRenderer);\n\n            const parameters: [string, IAudioParam][] = [];\n\n            nativeAudioWorkletNode.parameters.forEach((nativeAudioParam, nm) => {\n                const audioParam = createAudioParam(this, isOffline, nativeAudioParam);\n\n                parameters.push([nm, audioParam]);\n            });\n\n            this._nativeAudioWorkletNode = nativeAudioWorkletNode;\n            this._onprocessorerror = null;\n            this._parameters = new ReadOnlyMap(parameters);\n\n            /*\n             * Bug #86 & #87: Invoking the renderer of an AudioWorkletNode might be necessary if it has no direct or indirect connection to\n             * the destination.\n             */\n            if (isOffline) {\n                addUnrenderedAudioWorkletNode(nativeContext, <IAudioWorkletNode<IMinimalOfflineAudioContext | IOfflineAudioContext>>this);\n            }\n\n            const { activeInputs } = getAudioNodeConnections(this);\n\n            setActiveAudioWorkletNodeInputs(nativeAudioWorkletNode, activeInputs);\n        }\n\n        get onprocessorerror(): null | TErrorEventHandler<this> {\n            return this._onprocessorerror;\n        }\n\n        set onprocessorerror(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, <EventListenerOrEventListenerObject>value) : null;\n\n            this._nativeAudioWorkletNode.onprocessorerror = wrappedListener;\n\n            const nativeOnProcessorError = this._nativeAudioWorkletNode.onprocessorerror;\n\n            this._onprocessorerror =\n                nativeOnProcessorError !== null && nativeOnProcessorError === wrappedListener\n                    ? value\n                    : <null | TErrorEventHandler<this>>nativeOnProcessorError;\n        }\n\n        get parameters(): TAudioParamMap {\n            if (this._parameters === null) {\n                // @todo The definition that TypeScript uses of the AudioParamMap is lacking many methods.\n                return <IReadOnlyMap<string, TNativeAudioParam>>this._nativeAudioWorkletNode.parameters;\n            }\n\n            return this._parameters;\n        }\n\n        get port(): MessagePort {\n            return this._nativeAudioWorkletNode.port;\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
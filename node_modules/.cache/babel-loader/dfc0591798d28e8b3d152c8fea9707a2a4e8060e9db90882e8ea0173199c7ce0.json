{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport var WaveShaper = /*#__PURE__*/function (_SignalOperator) {\n  _inherits(WaveShaper, _SignalOperator);\n  var _super = _createSuper(WaveShaper);\n  function WaveShaper() {\n    var _this;\n    _classCallCheck(this, WaveShaper);\n    _this = _super.call(this, Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n    _this.name = \"WaveShaper\";\n    /**\n     * the waveshaper node\n     */\n    _this._shaper = _this.context.createWaveShaper();\n    /**\n     * The input to the waveshaper node.\n     */\n    _this.input = _this._shaper;\n    /**\n     * The output from the waveshaper node\n     */\n    _this.output = _this._shaper;\n    var options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n    if (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n      _this.curve = Float32Array.from(options.mapping);\n    } else if (isFunction(options.mapping)) {\n      _this.setMap(options.mapping, options.length);\n    }\n    return _this;\n  }\n  _createClass(WaveShaper, [{\n    key: \"setMap\",\n    value:\n    /**\n     * Uses a mapping function to set the value of the curve.\n     * @param mapping The function used to define the values.\n     *                The mapping function take two arguments:\n     *                the first is the value at the current position\n     *                which goes from -1 to 1 over the number of elements\n     *                in the curve array. The second argument is the array position.\n     * @example\n     * const shaper = new Tone.WaveShaper();\n     * // map the input signal from [-1, 1] to [0, 10]\n     * shaper.setMap((val, index) => (val + 1) * 5);\n     */\n    function setMap(mapping) {\n      var length = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1024;\n      var array = new Float32Array(length);\n      for (var i = 0, len = length; i < len; i++) {\n        var normalized = i / (len - 1) * 2 - 1;\n        array[i] = mapping(normalized, i);\n      }\n      this.curve = array;\n      return this;\n    }\n    /**\n     * The array to set as the waveshaper curve. For linear curves\n     * array length does not make much difference, but for complex curves\n     * longer arrays will provide smoother interpolation.\n     */\n  }, {\n    key: \"curve\",\n    get: function get() {\n      return this._shaper.curve;\n    },\n    set: function set(mapping) {\n      this._shaper.curve = mapping;\n    }\n    /**\n     * Specifies what type of oversampling (if any) should be used when\n     * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n     */\n  }, {\n    key: \"oversample\",\n    get: function get() {\n      return this._shaper.oversample;\n    },\n    set: function set(oversampling) {\n      var isOverSampleType = [\"none\", \"2x\", \"4x\"].some(function (str) {\n        return str.includes(oversampling);\n      });\n      assert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n      this._shaper.oversample = oversampling;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(WaveShaper.prototype), \"dispose\", this).call(this);\n      this._shaper.disconnect();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Signal.getDefaults(), {\n        length: 1024\n      });\n    }\n  }]);\n  return WaveShaper;\n}(SignalOperator);","map":{"version":3,"mappings":"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","names":["optionsFromArguments","isArray","isFunction","assert","Signal","SignalOperator","WaveShaper","Object","assign","getDefaults","arguments","context","createWaveShaper","_shaper","options","mapping","Float32Array","curve","from","setMap","length","array","i","len","normalized","oversample","oversampling","isOverSampleType","some","str","includes","disconnect"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\signal\\WaveShaper.ts"],"sourcesContent":["import { ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isFunction } from \"../core/util/TypeCheck\";\nimport { assert } from \"../core/util/Debug\";\nimport { Signal } from \"./Signal\";\nimport { SignalOperator } from \"./SignalOperator\";\n\nexport type WaveShaperMappingFn = (value: number, index?: number) => number;\n\ntype WaveShaperMapping = WaveShaperMappingFn | number[] | Float32Array;\n\ninterface WaveShaperOptions extends ToneAudioNodeOptions {\n\tmapping?: WaveShaperMapping;\n\tlength: number;\n\tcurve?: number[] | Float32Array;\n}\n\n/**\n * Wraps the native Web Audio API\n * [WaveShaperNode](http://webaudio.github.io/web-audio-api/#the-waveshapernode-interface).\n *\n * @example\n * const osc = new Tone.Oscillator().toDestination().start();\n * // multiply the output of the signal by 2 using the waveshaper's function\n * const timesTwo = new Tone.WaveShaper((val) => val * 2, 2048).connect(osc.frequency);\n * const signal = new Tone.Signal(440).connect(timesTwo);\n * @category Signal\n */\nexport class WaveShaper extends SignalOperator<WaveShaperOptions> {\n\n\treadonly name: string = \"WaveShaper\";\n\n\t/**\n\t * the waveshaper node\n\t */\n\tprivate _shaper: WaveShaperNode = this.context.createWaveShaper();\n\n\t/**\n\t * The input to the waveshaper node.\n\t */\n\tinput = this._shaper;\n\n\t/**\n\t * The output from the waveshaper node\n\t */\n\toutput = this._shaper;\n\n\t/**\n\t * @param mapping The function used to define the values.\n\t *                The mapping function should take two arguments:\n\t *                the first is the value at the current position\n\t *                and the second is the array position.\n\t *                If the argument is an array, that array will be\n\t *                set as the wave shaping function. The input\n\t *                signal is an AudioRange [-1, 1] value and the output\n\t *                signal can take on any numerical values.\n\t *\n\t * @param bufferLen The length of the WaveShaperNode buffer.\n\t */\n\tconstructor(mapping?: WaveShaperMapping, length?: number);\n\tconstructor(options?: Partial<WaveShaperOptions>);\n\tconstructor() {\n\t\tsuper(Object.assign(optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"])));\n\t\tconst options = optionsFromArguments(WaveShaper.getDefaults(), arguments, [\"mapping\", \"length\"]);\n\n\t\tif (isArray(options.mapping) || options.mapping instanceof Float32Array) {\n\t\t\tthis.curve = Float32Array.from(options.mapping);\n\t\t} else if (isFunction(options.mapping)) {\n\t\t\tthis.setMap(options.mapping, options.length);\n\t\t}\n\t}\n\n\tstatic getDefaults(): WaveShaperOptions {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tlength: 1024,\n\t\t});\n\t}\n\n\t/**\n\t * Uses a mapping function to set the value of the curve.\n\t * @param mapping The function used to define the values.\n\t *                The mapping function take two arguments:\n\t *                the first is the value at the current position\n\t *                which goes from -1 to 1 over the number of elements\n\t *                in the curve array. The second argument is the array position.\n\t * @example\n\t * const shaper = new Tone.WaveShaper();\n\t * // map the input signal from [-1, 1] to [0, 10]\n\t * shaper.setMap((val, index) => (val + 1) * 5);\n\t */\n\tsetMap(mapping: WaveShaperMappingFn, length = 1024): this {\n\t\tconst array = new Float32Array(length);\n\t\tfor (let i = 0, len = length; i < len; i++) {\n\t\t\tconst normalized = (i / (len - 1)) * 2 - 1;\n\t\t\tarray[i] = mapping(normalized, i);\n\t\t}\n\t\tthis.curve = array;\n\t\treturn this;\n\t}\n\n\t/**\n\t * The array to set as the waveshaper curve. For linear curves\n\t * array length does not make much difference, but for complex curves\n\t * longer arrays will provide smoother interpolation.\n\t */\n\tget curve(): Float32Array | null {\n\t\treturn this._shaper.curve;\n\t}\n\n\tset curve(mapping: Float32Array | null) {\n\t\tthis._shaper.curve = mapping;\n\t}\n\n\t/**\n\t * Specifies what type of oversampling (if any) should be used when\n\t * applying the shaping curve. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\n\tset oversample(oversampling: OverSampleType) {\n\t\tconst isOverSampleType = [\"none\", \"2x\", \"4x\"].some(str => str.includes(oversampling));\n\t\tassert(isOverSampleType, \"oversampling must be either 'none', '2x', or '4x'\");\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
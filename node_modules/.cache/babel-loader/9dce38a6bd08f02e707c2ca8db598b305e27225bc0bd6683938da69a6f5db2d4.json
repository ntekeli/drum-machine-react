{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound.\n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n *\n * @category Effect\n */\nexport var Reverb = /*#__PURE__*/function (_Effect) {\n  _inherits(Reverb, _Effect);\n  var _super = _createSuper(Reverb);\n  function Reverb() {\n    var _this;\n    _classCallCheck(this, Reverb);\n    _this = _super.call(this, optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n    _this.name = \"Reverb\";\n    /**\n     * Convolver node\n     */\n    _this._convolver = _this.context.createConvolver();\n    /**\n     * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n     * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n     * before the IR is generated with the latest values.\n     */\n    _this.ready = Promise.resolve();\n    var options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n    _this._decay = options.decay;\n    _this._preDelay = options.preDelay;\n    _this.generate();\n    _this.connectEffect(_this._convolver);\n    return _this;\n  }\n  _createClass(Reverb, [{\n    key: \"decay\",\n    get:\n    /**\n     * The duration of the reverb.\n     */\n    function get() {\n      return this._decay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0.001);\n      this._decay = time;\n      this.generate();\n    }\n    /**\n     * The amount of time before the reverb is fully ramped in.\n     */\n  }, {\n    key: \"preDelay\",\n    get: function get() {\n      return this._preDelay;\n    },\n    set: function set(time) {\n      time = this.toSeconds(time);\n      assertRange(time, 0);\n      this._preDelay = time;\n      this.generate();\n    }\n    /**\n     * Generate the Impulse Response. Returns a promise while the IR is being generated.\n     * @return Promise which returns this object.\n     */\n  }, {\n    key: \"generate\",\n    value: function generate() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var previousReady, context, noiseL, noiseR, merge, gainNode, renderPromise;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              previousReady = this.ready; // create a noise burst which decays over the duration in each channel\n              context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n              noiseL = new Noise({\n                context: context\n              });\n              noiseR = new Noise({\n                context: context\n              });\n              merge = new Merge({\n                context: context\n              });\n              noiseL.connect(merge, 0, 0);\n              noiseR.connect(merge, 0, 1);\n              gainNode = new Gain({\n                context: context\n              }).toDestination();\n              merge.connect(gainNode);\n              noiseL.start(0);\n              noiseR.start(0);\n              // predelay\n              gainNode.gain.setValueAtTime(0, 0);\n              gainNode.gain.setValueAtTime(1, this._preDelay);\n              // decay\n              gainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n              // render the buffer\n              renderPromise = context.render();\n              this.ready = renderPromise.then(noOp);\n              // wait for the previous `ready` to resolve\n              _context.next = 18;\n              return previousReady;\n            case 18:\n              _context.next = 20;\n              return renderPromise;\n            case 20:\n              this._convolver.buffer = _context.sent.get();\n              return _context.abrupt(\"return\", this);\n            case 22:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Reverb.prototype), \"dispose\", this).call(this);\n      this._convolver.disconnect();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Effect.getDefaults(), {\n        decay: 1.5,\n        preDelay: 0.01\n      });\n    }\n  }]);\n  return Reverb;\n}(Effect);","map":{"version":3,"mappings":"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","names":["Merge","Gain","optionsFromArguments","Noise","Effect","OfflineContext","noOp","assertRange","Reverb","getDefaults","arguments","context","createConvolver","Promise","resolve","options","_decay","decay","_preDelay","preDelay","generate","connectEffect","_convolver","time","toSeconds","previousReady","ready","sampleRate","noiseL","noiseR","merge","connect","gainNode","toDestination","start","gain","setValueAtTime","exponentialApproachValueAtTime","renderPromise","render","then","buffer","get","disconnect","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\effect\\Reverb.ts"],"sourcesContent":["import { Merge } from \"../component/channel/Merge\";\nimport { Gain } from \"../core/context/Gain\";\nimport { Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Effect, EffectOptions } from \"./Effect\";\nimport { OfflineContext } from \"../core/context/OfflineContext\";\nimport { noOp } from \"../core/util/Interface\";\nimport { assertRange } from \"../core/util/Debug\";\n\ninterface ReverbOptions extends EffectOptions {\n\tdecay: Seconds;\n\tpreDelay: Seconds;\n}\n\n/**\n * Simple convolution created with decaying noise.\n * Generates an Impulse Response Buffer\n * with Tone.Offline then feeds the IR into ConvolverNode.\n * The impulse response generation is async, so you have\n * to wait until [[ready]] resolves before it will make a sound. \n *\n * Inspiration from [ReverbGen](https://github.com/adelespinasse/reverbGen).\n * Copyright (c) 2014 Alan deLespinasse Apache 2.0 License.\n * \n * @category Effect\n */\nexport class Reverb extends Effect<ReverbOptions> {\n\n\treadonly name: string = \"Reverb\";\n\n\t/**\n\t * Convolver node\n\t */\n\tprivate _convolver: ConvolverNode = this.context.createConvolver();\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tprivate _decay: Seconds;\n\t\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tprivate _preDelay: Seconds;\n\n\t/**\n\t * Resolves when the reverb buffer is generated. Whenever either [[decay]]\n\t * or [[preDelay]] are set, you have to wait until [[ready]] resolves\n\t * before the IR is generated with the latest values. \n\t */\n\tready: Promise<void> = Promise.resolve();\n\n\t/**\n\t * @param decay The amount of time it will reverberate for.\n\t */\n\tconstructor(decay?: Seconds);\n\tconstructor(options?: Partial<ReverbOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]));\n\t\tconst options = optionsFromArguments(Reverb.getDefaults(), arguments, [\"decay\"]);\n\n\t\tthis._decay = options.decay;\n\t\tthis._preDelay = options.preDelay;\n\t\tthis.generate();\n\n\t\tthis.connectEffect(this._convolver);\n\t}\n\n\tstatic getDefaults(): ReverbOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdecay: 1.5,\n\t\t\tpreDelay: 0.01,\n\t\t});\n\t}\n\n\t/**\n\t * The duration of the reverb.\n\t */\n\tget decay(): Time {\n\t\treturn this._decay;\n\t}\n\tset decay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0.001);\n\t\tthis._decay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * The amount of time before the reverb is fully ramped in.\n\t */\n\tget preDelay(): Time {\n\t\treturn this._preDelay;\n\t}\n\tset preDelay(time) {\n\t\ttime = this.toSeconds(time);\n\t\tassertRange(time, 0);\n\t\tthis._preDelay = time;\n\t\tthis.generate();\n\t}\n\n\t/**\n\t * Generate the Impulse Response. Returns a promise while the IR is being generated.\n\t * @return Promise which returns this object.\n\t */\n\tasync generate(): Promise<this> {\n\t\tconst previousReady = this.ready;\n\n\t\t// create a noise burst which decays over the duration in each channel\n\t\tconst context = new OfflineContext(2, this._decay + this._preDelay, this.context.sampleRate);\n\t\tconst noiseL = new Noise({ context });\n\t\tconst noiseR = new Noise({ context });\n\t\tconst merge = new Merge({ context });\n\t\tnoiseL.connect(merge, 0, 0);\n\t\tnoiseR.connect(merge, 0, 1);\n\t\tconst gainNode = new Gain({ context }).toDestination();\n\t\tmerge.connect(gainNode);\n\t\tnoiseL.start(0);\n\t\tnoiseR.start(0);\n\t\t// predelay\n\t\tgainNode.gain.setValueAtTime(0, 0);\n\t\tgainNode.gain.setValueAtTime(1, this._preDelay);\n\t\t// decay\n\t\tgainNode.gain.exponentialApproachValueAtTime(0, this._preDelay, this.decay);\n\t\t\n\t\t// render the buffer\n\t\tconst renderPromise = context.render();\n\t\tthis.ready = renderPromise.then(noOp);\n\t\t\n\t\t// wait for the previous `ready` to resolve\n\t\tawait previousReady;\n\t\t// set the buffer\n\t\tthis._convolver.buffer = (await renderPromise).get() as AudioBuffer;\n\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._convolver.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
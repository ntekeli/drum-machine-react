{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { MidiClass } from \"../core/type/Midi\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument } from \"./Instrument\";\nimport { Synth } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport var PolySynth = /*#__PURE__*/function (_Instrument) {\n  _inherits(PolySynth, _Instrument);\n  var _super = _createSuper(PolySynth);\n  function PolySynth() {\n    var _this;\n    _classCallCheck(this, PolySynth);\n    _this = _super.call(this, optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n    _this.name = \"PolySynth\";\n    /**\n     * The voices which are not currently in use\n     */\n    _this._availableVoices = [];\n    /**\n     * The currently active voices\n     */\n    _this._activeVoices = [];\n    /**\n     * All of the allocated voices for this synth.\n     */\n    _this._voices = [];\n    /**\n     * The GC timeout. Held so that it could be cancelled when the node is disposed.\n     */\n    _this._gcTimeout = -1;\n    /**\n     * A moving average of the number of active voices\n     */\n    _this._averageActiveVoices = 0;\n    var options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n    // check against the old API (pre 14.3.0)\n    assert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n    var defaults = options.voice.getDefaults();\n    _this.options = Object.assign(defaults, options.options);\n    _this.voice = options.voice;\n    _this.maxPolyphony = options.maxPolyphony;\n    // create the first voice\n    _this._dummyVoice = _this._getNextAvailableVoice();\n    // remove it from the voices list\n    var index = _this._voices.indexOf(_this._dummyVoice);\n    _this._voices.splice(index, 1);\n    // kick off the GC interval\n    _this._gcTimeout = _this.context.setInterval(_this._collectGarbage.bind(_assertThisInitialized(_this)), 1);\n    return _this;\n  }\n  _createClass(PolySynth, [{\n    key: \"activeVoices\",\n    get:\n    /**\n     * The number of active voices.\n     */\n    function get() {\n      return this._activeVoices.length;\n    }\n    /**\n     * Invoked when the source is done making sound, so that it can be\n     * readded to the pool of available voices\n     */\n  }, {\n    key: \"_makeVoiceAvailable\",\n    value: function _makeVoiceAvailable(voice) {\n      this._availableVoices.push(voice);\n      // remove the midi note from 'active voices'\n      var activeVoiceIndex = this._activeVoices.findIndex(function (e) {\n        return e.voice === voice;\n      });\n      this._activeVoices.splice(activeVoiceIndex, 1);\n    }\n    /**\n     * Get an available voice from the pool of available voices.\n     * If one is not available and the maxPolyphony limit is reached,\n     * steal a voice, otherwise return null.\n     */\n  }, {\n    key: \"_getNextAvailableVoice\",\n    value: function _getNextAvailableVoice() {\n      // if there are available voices, return the first one\n      if (this._availableVoices.length) {\n        return this._availableVoices.shift();\n      } else if (this._voices.length < this.maxPolyphony) {\n        // otherwise if there is still more maxPolyphony, make a new voice\n        var voice = new this.voice(Object.assign(this.options, {\n          context: this.context,\n          onsilence: this._makeVoiceAvailable.bind(this)\n        }));\n        voice.connect(this.output);\n        this._voices.push(voice);\n        return voice;\n      } else {\n        warn(\"Max polyphony exceeded. Note dropped.\");\n      }\n    }\n    /**\n     * Occasionally check if there are any allocated voices which can be cleaned up.\n     */\n  }, {\n    key: \"_collectGarbage\",\n    value: function _collectGarbage() {\n      this._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n      if (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n        // take off an available note\n        var firstAvail = this._availableVoices.shift();\n        var index = this._voices.indexOf(firstAvail);\n        this._voices.splice(index, 1);\n        if (!this.context.isOffline) {\n          firstAvail.dispose();\n        }\n      }\n    }\n    /**\n     * Internal method which triggers the attack\n     */\n  }, {\n    key: \"_triggerAttack\",\n    value: function _triggerAttack(notes, time, velocity) {\n      var _this2 = this;\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this2.context, note).toMidi();\n        var voice = _this2._getNextAvailableVoice();\n        if (voice) {\n          voice.triggerAttack(note, time, velocity);\n          _this2._activeVoices.push({\n            midi: midiNote,\n            voice: voice,\n            released: false\n          });\n          _this2.log(\"triggerAttack\", note, time);\n        }\n      });\n    }\n    /**\n     * Internal method which triggers the release\n     */\n  }, {\n    key: \"_triggerRelease\",\n    value: function _triggerRelease(notes, time) {\n      var _this3 = this;\n      notes.forEach(function (note) {\n        var midiNote = new MidiClass(_this3.context, note).toMidi();\n        var event = _this3._activeVoices.find(function (_ref) {\n          var midi = _ref.midi,\n            released = _ref.released;\n          return midi === midiNote && !released;\n        });\n        if (event) {\n          // trigger release on that note\n          event.voice.triggerRelease(time);\n          // mark it as released\n          event.released = true;\n          _this3.log(\"triggerRelease\", note, time);\n        }\n      });\n    }\n    /**\n     * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n     * to wait for just-in-time scheduling\n     */\n  }, {\n    key: \"_scheduleEvent\",\n    value: function _scheduleEvent(type, notes, time, velocity) {\n      var _this4 = this;\n      assert(!this.disposed, \"Synth was already disposed\");\n      // if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n      if (time <= this.now()) {\n        // do it immediately\n        if (type === \"attack\") {\n          this._triggerAttack(notes, time, velocity);\n        } else {\n          this._triggerRelease(notes, time);\n        }\n      } else {\n        // schedule it to start in the future\n        this.context.setTimeout(function () {\n          _this4._scheduleEvent(type, notes, time, velocity);\n        }, time - this.now());\n      }\n    }\n    /**\n     * Trigger the attack portion of the note\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  The start time of the note.\n     * @param velocity The velocity of the note.\n     * @example\n     * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n     * // trigger a chord immediately with a velocity of 0.2\n     * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n     */\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(notes, time, velocity) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n      var computedTime = this.toSeconds(time);\n      this._scheduleEvent(\"attack\", notes, computedTime, velocity);\n      return this;\n    }\n    /**\n     * Trigger the release of the note. Unlike monophonic instruments,\n     * a note (or array of notes) needs to be passed in as the first argument.\n     * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n     * @param  time  When the release will be triggered.\n     * @example\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n     * // trigger the release of the given notes.\n     * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n     * poly.triggerRelease(\"F5\", \"+3\");\n     */\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(notes, time) {\n      if (!Array.isArray(notes)) {\n        notes = [notes];\n      }\n      var computedTime = this.toSeconds(time);\n      this._scheduleEvent(\"release\", notes, computedTime);\n      return this;\n    }\n    /**\n     * Trigger the attack and release after the specified duration\n     * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n     * @param  duration the duration of the note\n     * @param  time  if no time is given, defaults to now\n     * @param  velocity the velocity of the attack (0-1)\n     * @example\n     * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n     * // can pass in an array of durations as well\n     * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n     */\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(notes, duration, time, velocity) {\n      var computedTime = this.toSeconds(time);\n      this.triggerAttack(notes, computedTime, velocity);\n      if (isArray(duration)) {\n        assert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n        notes = notes;\n        for (var i = 0; i < notes.length; i++) {\n          var d = duration[Math.min(i, duration.length - 1)];\n          var durationSeconds = this.toSeconds(d);\n          assert(durationSeconds > 0, \"The duration must be greater than 0\");\n          this.triggerRelease(notes[i], computedTime + durationSeconds);\n        }\n      } else {\n        var _durationSeconds = this.toSeconds(duration);\n        assert(_durationSeconds > 0, \"The duration must be greater than 0\");\n        this.triggerRelease(notes, computedTime + _durationSeconds);\n      }\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 1);\n        this._syncMethod(\"triggerRelease\", 1);\n      }\n      return this;\n    }\n    /**\n     * Set a member/attribute of the voices\n     * @example\n     * const poly = new Tone.PolySynth().toDestination();\n     * // set all of the voices using an options object for the synth type\n     * poly.set({\n     * \tenvelope: {\n     * \t\tattack: 0.25\n     * \t}\n     * });\n     * poly.triggerAttackRelease(\"Bb3\", 0.2);\n     */\n  }, {\n    key: \"set\",\n    value: function set(options) {\n      // remove options which are controlled by the PolySynth\n      var sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n      // store all of the options\n      this.options = deepMerge(this.options, sanitizedOptions);\n      this._voices.forEach(function (voice) {\n        return voice.set(sanitizedOptions);\n      });\n      this._dummyVoice.set(sanitizedOptions);\n      return this;\n    }\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._dummyVoice.get();\n    }\n    /**\n     * Trigger the release portion of all the currently active voices immediately.\n     * Useful for silencing the synth.\n     */\n  }, {\n    key: \"releaseAll\",\n    value: function releaseAll(time) {\n      var computedTime = this.toSeconds(time);\n      this._activeVoices.forEach(function (_ref2) {\n        var voice = _ref2.voice;\n        voice.triggerRelease(computedTime);\n      });\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(PolySynth.prototype), \"dispose\", this).call(this);\n      this._dummyVoice.dispose();\n      this._voices.forEach(function (v) {\n        return v.dispose();\n      });\n      this._activeVoices = [];\n      this._availableVoices = [];\n      this.context.clearInterval(this._gcTimeout);\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        maxPolyphony: 32,\n        options: {},\n        voice: Synth\n      });\n    }\n  }]);\n  return PolySynth;\n}(Instrument);","map":{"version":3,"mappings":"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","names":["MidiClass","deepMerge","omitFromObject","optionsFromArguments","isArray","isNumber","Instrument","Synth","assert","warn","PolySynth","getDefaults","arguments","options","voice","defaults","Object","assign","maxPolyphony","_dummyVoice","_getNextAvailableVoice","index","_voices","indexOf","splice","_gcTimeout","context","setInterval","_collectGarbage","bind","_activeVoices","length","_availableVoices","push","activeVoiceIndex","findIndex","e","shift","onsilence","_makeVoiceAvailable","connect","output","_averageActiveVoices","Math","max","activeVoices","ceil","firstAvail","isOffline","dispose","notes","time","velocity","forEach","midiNote","note","toMidi","triggerAttack","midi","released","log","event","find","triggerRelease","type","disposed","now","_triggerAttack","_triggerRelease","setTimeout","_scheduleEvent","Array","computedTime","toSeconds","duration","i","d","min","durationSeconds","_syncState","_syncMethod","sanitizedOptions","set","get","v","clearInterval"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\instrument\\PolySynth.ts"],"sourcesContent":["import { MidiClass } from \"../core/type/Midi\";\nimport { Frequency, MidiNote, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { deepMerge, omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { isArray, isNumber } from \"../core/util/TypeCheck\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { MembraneSynth, MembraneSynthOptions } from \"./MembraneSynth\";\nimport { FMSynth, FMSynthOptions } from \"./FMSynth\";\nimport { AMSynth, AMSynthOptions } from \"./AMSynth\";\nimport { MonoSynth, MonoSynthOptions } from \"./MonoSynth\";\nimport { MetalSynth, MetalSynthOptions } from \"./MetalSynth\";\nimport { Monophonic } from \"./Monophonic\";\nimport { Synth, SynthOptions } from \"./Synth\";\nimport { assert, warn } from \"../core/util/Debug\";\n\ntype VoiceConstructor<V> = {\n\tgetDefaults: () => VoiceOptions<V>;\n} & (new (...args: any[]) => V);\n\ntype OmitMonophonicOptions<T> = Omit<T, \"context\" | \"onsilence\">;\n\ntype VoiceOptions<T> =\n\tT extends MembraneSynth ? MembraneSynthOptions :\n\t\tT extends MetalSynth ? MetalSynthOptions :\n\t\t\tT extends FMSynth ? FMSynthOptions :\n\t\t\t\tT extends MonoSynth ? MonoSynthOptions :\n\t\t\t\t\tT extends AMSynth ? AMSynthOptions :\n\t\t\t\t\t\tT extends Synth ? SynthOptions :\n\t\t\t\t\t\t\tnever;\n\n/**\n * The settable synth options. excludes monophonic options.\n */\ntype PartialVoiceOptions<T> = RecursivePartial<OmitMonophonicOptions<VoiceOptions<T>>>;\n\nexport interface PolySynthOptions<Voice> extends InstrumentOptions {\n\tmaxPolyphony: number;\n\tvoice: VoiceConstructor<Voice>;\n\toptions: PartialVoiceOptions<Voice>;\n}\n\n/**\n * PolySynth handles voice creation and allocation for any\n * instruments passed in as the second paramter. PolySynth is\n * not a synthesizer by itself, it merely manages voices of\n * one of the other types of synths, allowing any of the\n * monophonic synthesizers to be polyphonic.\n *\n * @example\n * const synth = new Tone.PolySynth().toDestination();\n * // set the attributes across all the voices using 'set'\n * synth.set({ detune: -1200 });\n * // play a chord\n * synth.triggerAttackRelease([\"C4\", \"E4\", \"A4\"], 1);\n * @category Instrument\n */\nexport class PolySynth<Voice extends Monophonic<any> = Synth> extends Instrument<VoiceOptions<Voice>> {\n\n\treadonly name: string = \"PolySynth\";\n\n\t/**\n\t * The voices which are not currently in use\n\t */\n\tprivate _availableVoices: Voice[] = [];\n\n\t/**\n\t * The currently active voices\n\t */\n\tprivate _activeVoices: Array<{ midi: MidiNote; voice: Voice; released: boolean }> = [];\n\n\t/**\n\t * All of the allocated voices for this synth.\n\t */\n\tprivate _voices: Voice[] = [];\n\n\t/**\n\t * The options that are set on the synth.\n\t */\n\tprivate options: VoiceOptions<Voice>;\n\n\t/**\n\t * The polyphony limit.\n\t */\n\tmaxPolyphony: number;\n\n\t/**\n\t * The voice constructor\n\t */\n\tprivate readonly voice: VoiceConstructor<Voice>;\n\n\t/**\n\t * A voice used for holding the get/set values\n\t */\n\tprivate _dummyVoice: Voice;\n\n\t/**\n\t * The GC timeout. Held so that it could be cancelled when the node is disposed.\n\t */\n\tprivate _gcTimeout = -1;\n\n\t/**\n\t * A moving average of the number of active voices\n\t */\n\tprivate _averageActiveVoices = 0;\n\n\t/**\n\t * @param voice The constructor of the voices\n\t * @param options\tThe options object to set the synth voice\n\t */\n\tconstructor(\n\t\tvoice?: VoiceConstructor<Voice>,\n\t\toptions?: PartialVoiceOptions<Voice>,\n\t);\n\tconstructor(options?: Partial<PolySynthOptions<Voice>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]));\n\t\tconst options = optionsFromArguments(PolySynth.getDefaults(), arguments, [\"voice\", \"options\"]);\n\n\t\t// check against the old API (pre 14.3.0)\n\t\tassert(!isNumber(options.voice), \"DEPRECATED: The polyphony count is no longer the first argument.\");\n\n\t\tconst defaults = options.voice.getDefaults();\n\t\tthis.options = Object.assign(defaults, options.options) as VoiceOptions<Voice>;\n\t\tthis.voice = options.voice as unknown as VoiceConstructor<Voice>;\n\t\tthis.maxPolyphony = options.maxPolyphony;\n\n\t\t// create the first voice\n\t\tthis._dummyVoice = this._getNextAvailableVoice() as Voice;\n\t\t// remove it from the voices list\n\t\tconst index = this._voices.indexOf(this._dummyVoice);\n\t\tthis._voices.splice(index, 1);\n\t\t// kick off the GC interval\n\t\tthis._gcTimeout = this.context.setInterval(this._collectGarbage.bind(this), 1);\n\t}\n\n\tstatic getDefaults(): PolySynthOptions<Synth> {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tmaxPolyphony: 32,\n\t\t\toptions: {},\n\t\t\tvoice: Synth,\n\t\t});\n\t}\n\n\t/**\n\t * The number of active voices.\n\t */\n\tget activeVoices(): number {\n\t\treturn this._activeVoices.length;\n\t}\n\n\t/**\n\t * Invoked when the source is done making sound, so that it can be\n\t * readded to the pool of available voices\n\t */\n\tprivate _makeVoiceAvailable(voice: Voice): void {\n\t\tthis._availableVoices.push(voice);\n\t\t// remove the midi note from 'active voices'\n\t\tconst activeVoiceIndex = this._activeVoices.findIndex((e) => e.voice === voice);\n\t\tthis._activeVoices.splice(activeVoiceIndex, 1);\n\t}\n\n\t/**\n\t * Get an available voice from the pool of available voices.\n\t * If one is not available and the maxPolyphony limit is reached,\n\t * steal a voice, otherwise return null.\n\t */\n\tprivate _getNextAvailableVoice(): Voice | undefined {\n\t\t// if there are available voices, return the first one\n\t\tif (this._availableVoices.length) {\n\t\t\treturn this._availableVoices.shift();\n\t\t} else if (this._voices.length < this.maxPolyphony) {\n\t\t\t// otherwise if there is still more maxPolyphony, make a new voice\n\t\t\tconst voice = new this.voice(Object.assign(this.options, {\n\t\t\t\tcontext: this.context,\n\t\t\t\tonsilence: this._makeVoiceAvailable.bind(this),\n\t\t\t}));\n\t\t\tvoice.connect(this.output);\n\t\t\tthis._voices.push(voice);\n\t\t\treturn voice;\n\t\t} else {\n\t\t\twarn(\"Max polyphony exceeded. Note dropped.\");\n\t\t}\n\t}\n\n\t/**\n\t * Occasionally check if there are any allocated voices which can be cleaned up.\n\t */\n\tprivate _collectGarbage(): void {\n\t\tthis._averageActiveVoices = Math.max(this._averageActiveVoices * 0.95, this.activeVoices);\n\t\tif (this._availableVoices.length && this._voices.length > Math.ceil(this._averageActiveVoices + 1)) {\n\t\t\t// take off an available note\n\t\t\tconst firstAvail = this._availableVoices.shift() as Voice;\n\t\t\tconst index = this._voices.indexOf(firstAvail);\n\t\t\tthis._voices.splice(index, 1);\n\t\t\tif (!this.context.isOffline) {\n\t\t\t\tfirstAvail.dispose();\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Internal method which triggers the attack\n\t */\n\tprivate _triggerAttack(notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst voice = this._getNextAvailableVoice();\n\t\t\tif (voice) {\n\t\t\t\tvoice.triggerAttack(note, time, velocity);\n\t\t\t\tthis._activeVoices.push({\n\t\t\t\t\tmidi: midiNote, voice, released: false,\n\t\t\t\t});\n\t\t\t\tthis.log(\"triggerAttack\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Internal method which triggers the release\n\t */\n\tprivate _triggerRelease(notes: Frequency[], time: Seconds): void {\n\t\tnotes.forEach(note => {\n\t\t\tconst midiNote = new MidiClass(this.context, note).toMidi();\n\t\t\tconst event = this._activeVoices.find(({ midi, released }) => midi === midiNote && !released);\n\t\t\tif (event) {\n\t\t\t\t// trigger release on that note\n\t\t\t\tevent.voice.triggerRelease(time);\n\t\t\t\t// mark it as released\n\t\t\t\tevent.released = true;\n\t\t\t\tthis.log(\"triggerRelease\", note, time);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Schedule the attack/release events. If the time is in the future, then it should set a timeout\n\t * to wait for just-in-time scheduling\n\t */\n\tprivate _scheduleEvent(type: \"attack\" | \"release\", notes: Frequency[], time: Seconds, velocity?: NormalRange): void {\n\t\tassert(!this.disposed, \"Synth was already disposed\");\n\t\t// if the notes are greater than this amount of time in the future, they should be scheduled with setTimeout\n\t\tif (time <= this.now()) {\n\t\t\t// do it immediately\n\t\t\tif (type === \"attack\") {\n\t\t\t\tthis._triggerAttack(notes, time, velocity);\n\t\t\t} else {\n\t\t\t\tthis._triggerRelease(notes, time);\n\t\t\t}\n\t\t} else {\n\t\t\t// schedule it to start in the future\n\t\t\tthis.context.setTimeout(() => {\n\t\t\t\tthis._scheduleEvent(type, notes, time, velocity);\n\t\t\t}, time - this.now());\n\t\t}\n\t}\n\n\t/**\n\t * Trigger the attack portion of the note\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  The start time of the note.\n\t * @param velocity The velocity of the note.\n\t * @example\n\t * const synth = new Tone.PolySynth(Tone.FMSynth).toDestination();\n\t * // trigger a chord immediately with a velocity of 0.2\n\t * synth.triggerAttack([\"Ab3\", \"C4\", \"F5\"], Tone.now(), 0.2);\n\t */\n\ttriggerAttack(notes: Frequency | Frequency[], time?: Time, velocity?: NormalRange): this {\n\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"attack\", notes, computedTime, velocity);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release of the note. Unlike monophonic instruments,\n\t * a note (or array of notes) needs to be passed in as the first argument.\n\t * @param  notes The notes to play. Accepts a single Frequency or an array of frequencies.\n\t * @param  time  When the release will be triggered.\n\t * @example\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * poly.triggerAttack([\"Ab3\", \"C4\", \"F5\"]);\n\t * // trigger the release of the given notes. \n\t * poly.triggerRelease([\"Ab3\", \"C4\"], \"+1\");\n\t * poly.triggerRelease(\"F5\", \"+3\");\n\t */\n\ttriggerRelease(notes: Frequency | Frequency[], time?: Time): this {\n\t\tif (!Array.isArray(notes)) {\n\t\t\tnotes = [notes];\n\t\t}\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._scheduleEvent(\"release\", notes, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the attack and release after the specified duration\n\t * @param  notes The notes to play. Accepts a single  Frequency or an array of frequencies.\n\t * @param  duration the duration of the note\n\t * @param  time  if no time is given, defaults to now\n\t * @param  velocity the velocity of the attack (0-1)\n\t * @example\n\t * const poly = new Tone.PolySynth(Tone.AMSynth).toDestination();\n\t * // can pass in an array of durations as well\n\t * poly.triggerAttackRelease([\"Eb3\", \"G4\", \"Bb4\", \"D5\"], [4, 3, 2, 1]);\n\t */\n\ttriggerAttackRelease(\n\t\tnotes: Frequency | Frequency[],\n\t\tduration: Time | Time[],\n\t\ttime?: Time,\n\t\tvelocity?: NormalRange,\n\t): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.triggerAttack(notes, computedTime, velocity);\n\t\tif (isArray(duration)) {\n\t\t\tassert(isArray(notes), \"If the duration is an array, the notes must also be an array\");\n\t\t\tnotes = notes as Frequency[];\n\t\t\tfor (let i = 0; i < notes.length; i++) {\n\t\t\t\tconst d = duration[Math.min(i, duration.length - 1)];\n\t\t\t\tconst durationSeconds = this.toSeconds(d);\n\t\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\t\tthis.triggerRelease(notes[i], computedTime + durationSeconds);\n\t\t\t}\n\t\t} else {\n\t\t\tconst durationSeconds = this.toSeconds(duration);\n\t\t\tassert(durationSeconds > 0, \"The duration must be greater than 0\");\n\t\t\tthis.triggerRelease(notes, computedTime + durationSeconds);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 1);\n\t\t\tthis._syncMethod(\"triggerRelease\", 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set a member/attribute of the voices\n\t * @example\n\t * const poly = new Tone.PolySynth().toDestination();\n\t * // set all of the voices using an options object for the synth type\n\t * poly.set({\n\t * \tenvelope: {\n\t * \t\tattack: 0.25\n\t * \t}\n\t * });\n\t * poly.triggerAttackRelease(\"Bb3\", 0.2);\n\t */\n\tset(options: RecursivePartial<VoiceOptions<Voice>>): this {\n\t\t// remove options which are controlled by the PolySynth\n\t\tconst sanitizedOptions = omitFromObject(options, [\"onsilence\", \"context\"]);\n\t\t// store all of the options\n\t\tthis.options = deepMerge(this.options, sanitizedOptions);\n\t\tthis._voices.forEach(voice => voice.set(sanitizedOptions));\n\t\tthis._dummyVoice.set(sanitizedOptions);\n\t\treturn this;\n\t}\n\n\tget(): VoiceOptions<Voice> {\n\t\treturn this._dummyVoice.get();\n\t}\n\n\t/**\n\t * Trigger the release portion of all the currently active voices immediately.\n\t * Useful for silencing the synth.\n\t */\n\treleaseAll(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis._activeVoices.forEach(({ voice }) => {\n\t\t\tvoice.triggerRelease(computedTime);\n\t\t});\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._dummyVoice.dispose();\n\t\tthis._voices.forEach(v => v.dispose());\n\t\tthis._activeVoices = [];\n\t\tthis._availableVoices = [];\n\t\tthis.context.clearInterval(this._gcTimeout);\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
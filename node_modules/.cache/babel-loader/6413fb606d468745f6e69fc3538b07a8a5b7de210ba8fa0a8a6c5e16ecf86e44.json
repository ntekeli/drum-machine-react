{"ast":null,"code":"import _objectWithoutProperties from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectWithoutProperties.js\";\nimport _objectSpread from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nvar _excluded = [\"channelCount\", \"channelCountMode\", \"pan\"];\nimport { interceptConnections } from '../helpers/intercept-connections';\nexport var createNativeStereoPannerNodeFakerFactory = function createNativeStereoPannerNodeFakerFactory(createNativeChannelMergerNode, createNativeChannelSplitterNode, createNativeGainNode, createNativeWaveShaperNode, createNotSupportedError, monitorConnections) {\n  // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n  var CURVE_SIZE = 16385;\n  var DC_CURVE = new Float32Array([1, 1]);\n  var HALF_PI = Math.PI / 2;\n  var SINGLE_CHANNEL_OPTIONS = {\n    channelCount: 1,\n    channelCountMode: 'explicit',\n    channelInterpretation: 'discrete'\n  };\n  var SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n    oversample: 'none'\n  });\n  var buildInternalGraphForMono = function buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n    var leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    var rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    for (var i = 0; i < CURVE_SIZE; i += 1) {\n      var x = i / (CURVE_SIZE - 1) * HALF_PI;\n      leftWaveShaperCurve[i] = Math.cos(x);\n      rightWaveShaperCurve[i] = Math.sin(x);\n    }\n    var leftGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var leftWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: leftWaveShaperCurve\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: DC_CURVE\n    }));\n    var rightGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var rightWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: rightWaveShaperCurve\n    }));\n    return {\n      connectGraph: function connectGraph() {\n        inputGainNode.connect(leftGainNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.connect(rightGainNode);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.connect(leftGainNode.gain);\n        rightWaveShaperNode.connect(rightGainNode.gain);\n        leftGainNode.connect(channelMergerNode, 0, 0);\n        rightGainNode.connect(channelMergerNode, 0, 1);\n      },\n      disconnectGraph: function disconnectGraph() {\n        inputGainNode.disconnect(leftGainNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        inputGainNode.disconnect(rightGainNode);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n        leftWaveShaperNode.disconnect(leftGainNode.gain);\n        rightWaveShaperNode.disconnect(rightGainNode.gain);\n        leftGainNode.disconnect(channelMergerNode, 0, 0);\n        rightGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n    };\n  };\n  var buildInternalGraphForStereo = function buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode) {\n    var leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    var leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    var rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    var rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n    var centerIndex = Math.floor(CURVE_SIZE / 2);\n    for (var i = 0; i < CURVE_SIZE; i += 1) {\n      if (i > centerIndex) {\n        var x = (i - centerIndex) / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n        leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n        rightInputForLeftOutputWaveShaperCurve[i] = 0;\n        rightInputForRightOutputWaveShaperCurve[i] = 1;\n      } else {\n        var _x = i / (CURVE_SIZE - 1 - centerIndex) * HALF_PI;\n        leftInputForLeftOutputWaveShaperCurve[i] = 1;\n        leftInputForRightOutputWaveShaperCurve[i] = 0;\n        rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(_x);\n        rightInputForRightOutputWaveShaperCurve[i] = Math.sin(_x);\n      }\n    }\n    var channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n      channelCount: 2,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      numberOfOutputs: 2\n    });\n    var leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var leftInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: leftInputForLeftOutputWaveShaperCurve\n    }));\n    var leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var leftInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: leftInputForRightOutputWaveShaperCurve\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var panWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: DC_CURVE\n    }));\n    var rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var rightInputForLeftOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: rightInputForLeftOutputWaveShaperCurve\n    }));\n    var rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_OPTIONS), {}, {\n      gain: 0\n    }));\n    // Bug #119: Safari does not fully support the WaveShaperNode.\n    var rightInputForRightOutputWaveShaperNode = createNativeWaveShaperNode(nativeContext, _objectSpread(_objectSpread({}, SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS), {}, {\n      curve: rightInputForRightOutputWaveShaperCurve\n    }));\n    return {\n      connectGraph: function connectGraph() {\n        inputGainNode.connect(channelSplitterNode);\n        inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.connect(panGainNode);\n        panGainNode.connect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.connect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n      },\n      disconnectGraph: function disconnectGraph() {\n        inputGainNode.disconnect(channelSplitterNode);\n        inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n        channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n        channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n        channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n        channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n        panWaveShaperNode.disconnect(panGainNode);\n        panGainNode.disconnect(leftInputForLeftOutputWaveShaperNode.inputs === undefined ? leftInputForLeftOutputWaveShaperNode : leftInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(leftInputForRightOutputWaveShaperNode.inputs === undefined ? leftInputForRightOutputWaveShaperNode : leftInputForRightOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForLeftOutputWaveShaperNode.inputs === undefined ? rightInputForLeftOutputWaveShaperNode : rightInputForLeftOutputWaveShaperNode.inputs[0]);\n        panGainNode.disconnect(rightInputForRightOutputWaveShaperNode.inputs === undefined ? rightInputForRightOutputWaveShaperNode : rightInputForRightOutputWaveShaperNode.inputs[0]);\n        leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n        leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n        rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n        rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n        leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n        leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n        rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n      }\n    };\n  };\n  var buildInternalGraph = function buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode) {\n    if (channelCount === 1) {\n      return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n    if (channelCount === 2) {\n      return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n    }\n    throw createNotSupportedError();\n  };\n  return function (nativeContext, _ref) {\n    var channelCount = _ref.channelCount,\n      channelCountMode = _ref.channelCountMode,\n      pan = _ref.pan,\n      audioNodeOptions = _objectWithoutProperties(_ref, _excluded);\n    if (channelCountMode === 'max') {\n      throw createNotSupportedError();\n    }\n    var channelMergerNode = createNativeChannelMergerNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      channelCount: 1,\n      channelCountMode: channelCountMode,\n      numberOfInputs: 2\n    }));\n    var inputGainNode = createNativeGainNode(nativeContext, _objectSpread(_objectSpread({}, audioNodeOptions), {}, {\n      channelCount: channelCount,\n      channelCountMode: channelCountMode,\n      gain: 1\n    }));\n    var panGainNode = createNativeGainNode(nativeContext, {\n      channelCount: 1,\n      channelCountMode: 'explicit',\n      channelInterpretation: 'discrete',\n      gain: pan\n    });\n    var _buildInternalGraph = buildInternalGraph(nativeContext, channelCount, inputGainNode, panGainNode, channelMergerNode),\n      connectGraph = _buildInternalGraph.connectGraph,\n      disconnectGraph = _buildInternalGraph.disconnectGraph;\n    Object.defineProperty(panGainNode.gain, 'defaultValue', {\n      get: function get() {\n        return 0;\n      }\n    });\n    Object.defineProperty(panGainNode.gain, 'maxValue', {\n      get: function get() {\n        return 1;\n      }\n    });\n    Object.defineProperty(panGainNode.gain, 'minValue', {\n      get: function get() {\n        return -1;\n      }\n    });\n    var nativeStereoPannerNodeFakerFactory = {\n      get bufferSize() {\n        return undefined;\n      },\n      get channelCount() {\n        return inputGainNode.channelCount;\n      },\n      set channelCount(value) {\n        if (inputGainNode.channelCount !== value) {\n          if (isConnected) {\n            disconnectGraph();\n          }\n          var _buildInternalGraph2 = buildInternalGraph(nativeContext, value, inputGainNode, panGainNode, channelMergerNode);\n          connectGraph = _buildInternalGraph2.connectGraph;\n          disconnectGraph = _buildInternalGraph2.disconnectGraph;\n          if (isConnected) {\n            connectGraph();\n          }\n        }\n        inputGainNode.channelCount = value;\n      },\n      get channelCountMode() {\n        return inputGainNode.channelCountMode;\n      },\n      set channelCountMode(value) {\n        if (value === 'clamped-max' || value === 'max') {\n          throw createNotSupportedError();\n        }\n        inputGainNode.channelCountMode = value;\n      },\n      get channelInterpretation() {\n        return inputGainNode.channelInterpretation;\n      },\n      set channelInterpretation(value) {\n        inputGainNode.channelInterpretation = value;\n      },\n      get context() {\n        return inputGainNode.context;\n      },\n      get inputs() {\n        return [inputGainNode];\n      },\n      get numberOfInputs() {\n        return inputGainNode.numberOfInputs;\n      },\n      get numberOfOutputs() {\n        return inputGainNode.numberOfOutputs;\n      },\n      get pan() {\n        return panGainNode.gain;\n      },\n      addEventListener: function addEventListener() {\n        return inputGainNode.addEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      },\n      dispatchEvent: function dispatchEvent() {\n        return inputGainNode.dispatchEvent(arguments.length <= 0 ? undefined : arguments[0]);\n      },\n      removeEventListener: function removeEventListener() {\n        return inputGainNode.removeEventListener(arguments.length <= 0 ? undefined : arguments[0], arguments.length <= 1 ? undefined : arguments[1], arguments.length <= 2 ? undefined : arguments[2]);\n      }\n    };\n    var isConnected = false;\n    var whenConnected = function whenConnected() {\n      connectGraph();\n      isConnected = true;\n    };\n    var whenDisconnected = function whenDisconnected() {\n      disconnectGraph();\n      isConnected = false;\n    };\n    return monitorConnections(interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode), whenConnected, whenDisconnected);\n  };\n};","map":{"version":3,"mappings":"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","names":["interceptConnections","createNativeStereoPannerNodeFakerFactory","createNativeChannelMergerNode","createNativeChannelSplitterNode","createNativeGainNode","createNativeWaveShaperNode","createNotSupportedError","monitorConnections","CURVE_SIZE","DC_CURVE","Float32Array","HALF_PI","Math","PI","SINGLE_CHANNEL_OPTIONS","channelCount","channelCountMode","channelInterpretation","SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS","oversample","buildInternalGraphForMono","nativeContext","inputGainNode","panGainNode","channelMergerNode","leftWaveShaperCurve","rightWaveShaperCurve","i","x","cos","sin","leftGainNode","gain","leftWaveShaperNode","curve","panWaveShaperNode","rightGainNode","rightWaveShaperNode","connectGraph","connect","inputs","undefined","disconnectGraph","disconnect","buildInternalGraphForStereo","leftInputForLeftOutputWaveShaperCurve","leftInputForRightOutputWaveShaperCurve","rightInputForLeftOutputWaveShaperCurve","rightInputForRightOutputWaveShaperCurve","centerIndex","floor","channelSplitterNode","numberOfOutputs","leftInputForLeftOutputGainNode","leftInputForLeftOutputWaveShaperNode","leftInputForRightOutputGainNode","leftInputForRightOutputWaveShaperNode","rightInputForLeftOutputGainNode","rightInputForLeftOutputWaveShaperNode","rightInputForRightOutputGainNode","rightInputForRightOutputWaveShaperNode","buildInternalGraph","pan","audioNodeOptions","numberOfInputs","Object","defineProperty","get","nativeStereoPannerNodeFakerFactory","bufferSize","value","isConnected","context","addEventListener","dispatchEvent","removeEventListener","whenConnected","whenDisconnected"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\native-stereo-panner-node-faker-factory.ts"],"sourcesContent":["import { interceptConnections } from '../helpers/intercept-connections';\nimport { INativeWaveShaperNodeFaker } from '../interfaces';\nimport {\n    TNativeAudioNode,\n    TNativeChannelMergerNode,\n    TNativeContext,\n    TNativeGainNode,\n    TNativeStereoPannerNode,\n    TNativeStereoPannerNodeFakerFactoryFactory\n} from '../types';\n\nexport const createNativeStereoPannerNodeFakerFactory: TNativeStereoPannerNodeFakerFactoryFactory = (\n    createNativeChannelMergerNode,\n    createNativeChannelSplitterNode,\n    createNativeGainNode,\n    createNativeWaveShaperNode,\n    createNotSupportedError,\n    monitorConnections\n) => {\n    // The curve has a size of 14bit plus 1 value to have an exact representation for zero. This value has been determined experimentally.\n    const CURVE_SIZE = 16385;\n    const DC_CURVE = new Float32Array([1, 1]);\n    const HALF_PI = Math.PI / 2;\n    const SINGLE_CHANNEL_OPTIONS = { channelCount: 1, channelCountMode: 'explicit', channelInterpretation: 'discrete' } as const;\n    const SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS = { ...SINGLE_CHANNEL_OPTIONS, oversample: 'none' } as const;\n\n    const buildInternalGraphForMono = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            const x = (i / (CURVE_SIZE - 1)) * HALF_PI;\n\n            leftWaveShaperCurve[i] = Math.cos(x);\n            rightWaveShaperCurve[i] = Math.sin(x);\n        }\n\n        const leftGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: leftWaveShaperCurve })\n        );\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: rightWaveShaperCurve })\n        );\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(leftGainNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.connect(rightGainNode);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.connect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.connect(leftGainNode.gain);\n                rightWaveShaperNode.connect(rightGainNode.gain);\n\n                leftGainNode.connect(channelMergerNode, 0, 0);\n                rightGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(leftGainNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n                inputGainNode.disconnect(rightGainNode);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(leftWaveShaperNode.inputs === undefined ? leftWaveShaperNode : leftWaveShaperNode.inputs[0]);\n                panGainNode.disconnect(rightWaveShaperNode.inputs === undefined ? rightWaveShaperNode : rightWaveShaperNode.inputs[0]);\n\n                leftWaveShaperNode.disconnect(leftGainNode.gain);\n                rightWaveShaperNode.disconnect(rightGainNode.gain);\n\n                leftGainNode.disconnect(channelMergerNode, 0, 0);\n                rightGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraphForStereo = (\n        nativeContext: TNativeContext,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        const leftInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const leftInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForLeftOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n        const rightInputForRightOutputWaveShaperCurve = new Float32Array(CURVE_SIZE);\n\n        const centerIndex = Math.floor(CURVE_SIZE / 2);\n\n        for (let i = 0; i < CURVE_SIZE; i += 1) {\n            if (i > centerIndex) {\n                const x = ((i - centerIndex) / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                leftInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n                rightInputForLeftOutputWaveShaperCurve[i] = 0;\n                rightInputForRightOutputWaveShaperCurve[i] = 1;\n            } else {\n                const x = (i / (CURVE_SIZE - 1 - centerIndex)) * HALF_PI;\n\n                leftInputForLeftOutputWaveShaperCurve[i] = 1;\n                leftInputForRightOutputWaveShaperCurve[i] = 0;\n                rightInputForLeftOutputWaveShaperCurve[i] = Math.cos(x);\n                rightInputForRightOutputWaveShaperCurve[i] = Math.sin(x);\n            }\n        }\n\n        const channelSplitterNode = createNativeChannelSplitterNode(nativeContext, {\n            channelCount: 2,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            numberOfOutputs: 2\n        });\n        const leftInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForLeftOutputWaveShaperCurve\n        });\n        const leftInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const leftInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: leftInputForRightOutputWaveShaperCurve\n        });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const panWaveShaperNode = <INativeWaveShaperNodeFaker>(\n            createNativeWaveShaperNode(nativeContext, { ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS, curve: DC_CURVE })\n        );\n        const rightInputForLeftOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForLeftOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForLeftOutputWaveShaperCurve\n        });\n        const rightInputForRightOutputGainNode = createNativeGainNode(nativeContext, { ...SINGLE_CHANNEL_OPTIONS, gain: 0 });\n        // Bug #119: Safari does not fully support the WaveShaperNode.\n        const rightInputForRightOutputWaveShaperNode = <INativeWaveShaperNodeFaker>createNativeWaveShaperNode(nativeContext, {\n            ...SINGLE_CHANNEL_WAVE_SHAPER_OPTIONS,\n            curve: rightInputForRightOutputWaveShaperCurve\n        });\n\n        return {\n            connectGraph(): void {\n                inputGainNode.connect(channelSplitterNode);\n                inputGainNode.connect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.connect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.connect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.connect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.connect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.connect(panGainNode);\n\n                panGainNode.connect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.connect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.connect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.connect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.connect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.connect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.connect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.connect(channelMergerNode, 0, 1);\n            },\n            disconnectGraph(): void {\n                inputGainNode.disconnect(channelSplitterNode);\n                inputGainNode.disconnect(panWaveShaperNode.inputs === undefined ? panWaveShaperNode : panWaveShaperNode.inputs[0]);\n\n                channelSplitterNode.disconnect(leftInputForLeftOutputGainNode, 0);\n                channelSplitterNode.disconnect(leftInputForRightOutputGainNode, 0);\n                channelSplitterNode.disconnect(rightInputForLeftOutputGainNode, 1);\n                channelSplitterNode.disconnect(rightInputForRightOutputGainNode, 1);\n\n                panWaveShaperNode.disconnect(panGainNode);\n\n                panGainNode.disconnect(\n                    leftInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForLeftOutputWaveShaperNode\n                        : leftInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    leftInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? leftInputForRightOutputWaveShaperNode\n                        : leftInputForRightOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForLeftOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForLeftOutputWaveShaperNode\n                        : rightInputForLeftOutputWaveShaperNode.inputs[0]\n                );\n                panGainNode.disconnect(\n                    rightInputForRightOutputWaveShaperNode.inputs === undefined\n                        ? rightInputForRightOutputWaveShaperNode\n                        : rightInputForRightOutputWaveShaperNode.inputs[0]\n                );\n\n                leftInputForLeftOutputWaveShaperNode.disconnect(leftInputForLeftOutputGainNode.gain);\n                leftInputForRightOutputWaveShaperNode.disconnect(leftInputForRightOutputGainNode.gain);\n                rightInputForLeftOutputWaveShaperNode.disconnect(rightInputForLeftOutputGainNode.gain);\n                rightInputForRightOutputWaveShaperNode.disconnect(rightInputForRightOutputGainNode.gain);\n\n                leftInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n                rightInputForLeftOutputGainNode.disconnect(channelMergerNode, 0, 0);\n\n                leftInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n                rightInputForRightOutputGainNode.disconnect(channelMergerNode, 0, 1);\n            }\n        };\n    };\n\n    const buildInternalGraph = (\n        nativeContext: TNativeContext,\n        channelCount: number,\n        inputGainNode: TNativeGainNode,\n        panGainNode: TNativeGainNode,\n        channelMergerNode: TNativeChannelMergerNode\n    ) => {\n        if (channelCount === 1) {\n            return buildInternalGraphForMono(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        if (channelCount === 2) {\n            return buildInternalGraphForStereo(nativeContext, inputGainNode, panGainNode, channelMergerNode);\n        }\n\n        throw createNotSupportedError();\n    };\n\n    return (nativeContext, { channelCount, channelCountMode, pan, ...audioNodeOptions }) => {\n        if (channelCountMode === 'max') {\n            throw createNotSupportedError();\n        }\n\n        const channelMergerNode = createNativeChannelMergerNode(nativeContext, {\n            ...audioNodeOptions,\n            channelCount: 1,\n            channelCountMode,\n            numberOfInputs: 2\n        });\n        const inputGainNode = createNativeGainNode(nativeContext, { ...audioNodeOptions, channelCount, channelCountMode, gain: 1 });\n        const panGainNode = createNativeGainNode(nativeContext, {\n            channelCount: 1,\n            channelCountMode: 'explicit',\n            channelInterpretation: 'discrete',\n            gain: pan\n        });\n\n        let { connectGraph, disconnectGraph } = buildInternalGraph(\n            nativeContext,\n            channelCount,\n            inputGainNode,\n            panGainNode,\n            channelMergerNode\n        );\n\n        Object.defineProperty(panGainNode.gain, 'defaultValue', { get: () => 0 });\n        Object.defineProperty(panGainNode.gain, 'maxValue', { get: () => 1 });\n        Object.defineProperty(panGainNode.gain, 'minValue', { get: () => -1 });\n\n        const nativeStereoPannerNodeFakerFactory = {\n            get bufferSize(): undefined {\n                return undefined;\n            },\n            get channelCount(): number {\n                return inputGainNode.channelCount;\n            },\n            set channelCount(value) {\n                if (inputGainNode.channelCount !== value) {\n                    if (isConnected) {\n                        disconnectGraph();\n                    }\n\n                    ({ connectGraph, disconnectGraph } = buildInternalGraph(\n                        nativeContext,\n                        value,\n                        inputGainNode,\n                        panGainNode,\n                        channelMergerNode\n                    ));\n\n                    if (isConnected) {\n                        connectGraph();\n                    }\n                }\n\n                inputGainNode.channelCount = value;\n            },\n            get channelCountMode(): TNativeStereoPannerNode['channelCountMode'] {\n                return inputGainNode.channelCountMode;\n            },\n            set channelCountMode(value) {\n                if (value === 'clamped-max' || value === 'max') {\n                    throw createNotSupportedError();\n                }\n\n                inputGainNode.channelCountMode = value;\n            },\n            get channelInterpretation(): TNativeStereoPannerNode['channelInterpretation'] {\n                return inputGainNode.channelInterpretation;\n            },\n            set channelInterpretation(value) {\n                inputGainNode.channelInterpretation = value;\n            },\n            get context(): TNativeStereoPannerNode['context'] {\n                return inputGainNode.context;\n            },\n            get inputs(): TNativeAudioNode[] {\n                return [inputGainNode];\n            },\n            get numberOfInputs(): number {\n                return inputGainNode.numberOfInputs;\n            },\n            get numberOfOutputs(): number {\n                return inputGainNode.numberOfOutputs;\n            },\n            get pan(): TNativeStereoPannerNode['pan'] {\n                return panGainNode.gain;\n            },\n            addEventListener(...args: any[]): void {\n                return inputGainNode.addEventListener(args[0], args[1], args[2]);\n            },\n            dispatchEvent(...args: any[]): boolean {\n                return inputGainNode.dispatchEvent(args[0]);\n            },\n            removeEventListener(...args: any[]): void {\n                return inputGainNode.removeEventListener(args[0], args[1], args[2]);\n            }\n        };\n\n        let isConnected = false;\n\n        const whenConnected = () => {\n            connectGraph();\n\n            isConnected = true;\n        };\n        const whenDisconnected = () => {\n            disconnectGraph();\n\n            isConnected = false;\n        };\n\n        return monitorConnections(\n            interceptConnections(nativeStereoPannerNodeFakerFactory, channelMergerNode),\n            whenConnected,\n            whenDisconnected\n        );\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\nvar OmniOscillatorSourceMap = {\n  am: AMOscillator,\n  fat: FatOscillator,\n  fm: FMOscillator,\n  oscillator: Oscillator,\n  pulse: PulseOscillator,\n  pwm: PWMOscillator\n};\n/**\n * OmniOscillator aggregates all of the oscillator types into one.\n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport var OmniOscillator = /*#__PURE__*/function (_Source) {\n  _inherits(OmniOscillator, _Source);\n  var _super = _createSuper(OmniOscillator);\n  function OmniOscillator() {\n    var _this;\n    _classCallCheck(this, OmniOscillator);\n    _this = _super.call(this, optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    _this.name = \"OmniOscillator\";\n    var options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(_assertThisInitialized(_this), [\"frequency\", \"detune\"]);\n    // set the options\n    _this.set(options);\n    return _this;\n  }\n  _createClass(OmniOscillator, [{\n    key: \"_start\",\n    value:\n    /**\n     * start the oscillator\n     */\n    function _start(time) {\n      this._oscillator.start(time);\n    }\n    /**\n     * start the oscillator\n     */\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      this._oscillator.stop(time);\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      this._oscillator.restart(time);\n      return this;\n    }\n    /**\n     * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n     * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n     * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n     * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n     * when it's not.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n     * omniOsc.type = \"pwm\";\n     * // modulationFrequency is parameter which is available\n     * // only when the type is \"pwm\".\n     * omniOsc.modulationFrequency.value = 0.5;\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      var _this2 = this;\n      var prefix = \"\";\n      if ([\"am\", \"fm\", \"fat\"].some(function (p) {\n        return _this2._sourceType === p;\n      })) {\n        prefix = this._sourceType;\n      }\n      return prefix + this._oscillator.type;\n    },\n    set: function set(type) {\n      if (type.substr(0, 2) === \"fm\") {\n        this._createNewOscillator(\"fm\");\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(2);\n      } else if (type.substr(0, 2) === \"am\") {\n        this._createNewOscillator(\"am\");\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(2);\n      } else if (type.substr(0, 3) === \"fat\") {\n        this._createNewOscillator(\"fat\");\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type.substr(3);\n      } else if (type === \"pwm\") {\n        this._createNewOscillator(\"pwm\");\n        this._oscillator = this._oscillator;\n      } else if (type === \"pulse\") {\n        this._createNewOscillator(\"pulse\");\n      } else {\n        this._createNewOscillator(\"oscillator\");\n        this._oscillator = this._oscillator;\n        this._oscillator.type = type;\n      }\n    }\n    /**\n     * The value is an empty array when the type is not \"custom\".\n     * This is not available on \"pwm\" and \"pulse\" oscillator types.\n     * See [[Oscillator.partials]]\n     */\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._oscillator.partials;\n    },\n    set: function set(partials) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n        this._oscillator.partials = partials;\n      }\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._oscillator.partialCount;\n    },\n    set: function set(partialCount) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n        this._oscillator.partialCount = partialCount;\n      }\n    }\n  }, {\n    key: \"set\",\n    value: function set(props) {\n      // make sure the type is set first\n      if (Reflect.has(props, \"type\") && props.type) {\n        this.type = props.type;\n      }\n      // then set the rest\n      _get(_getPrototypeOf(OmniOscillator.prototype), \"set\", this).call(this, props);\n      return this;\n    }\n    /**\n     * connect the oscillator to the frequency and detune signals\n     */\n  }, {\n    key: \"_createNewOscillator\",\n    value: function _createNewOscillator(oscType) {\n      var _this3 = this;\n      if (oscType !== this._sourceType) {\n        this._sourceType = oscType;\n        var OscConstructor = OmniOscillatorSourceMap[oscType];\n        // short delay to avoid clicks on the change\n        var now = this.now();\n        if (this._oscillator) {\n          var oldOsc = this._oscillator;\n          oldOsc.stop(now);\n          // dispose the old one\n          this.context.setTimeout(function () {\n            return oldOsc.dispose();\n          }, this.blockTime);\n        }\n        this._oscillator = new OscConstructor({\n          context: this.context\n        });\n        this.frequency.connect(this._oscillator.frequency);\n        this.detune.connect(this._oscillator.detune);\n        this._oscillator.connect(this.output);\n        this._oscillator.onstop = function () {\n          return _this3.onstop(_this3);\n        };\n        if (this.state === \"started\") {\n          this._oscillator.start(now);\n        }\n      }\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._oscillator.phase;\n    },\n    set: function set(phase) {\n      this._oscillator.phase = phase;\n    }\n    /**\n     * The source type of the oscillator.\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n     * console.log(omniOsc.sourceType); // 'fm'\n     */\n  }, {\n    key: \"sourceType\",\n    get: function get() {\n      return this._sourceType;\n    },\n    set: function set(sType) {\n      // the basetype defaults to sine\n      var baseType = \"sine\";\n      if (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n        baseType = this._oscillator.type;\n      }\n      // set the type\n      if (sType === \"fm\") {\n        this.type = \"fm\" + baseType;\n      } else if (sType === \"am\") {\n        this.type = \"am\" + baseType;\n      } else if (sType === \"fat\") {\n        this.type = \"fat\" + baseType;\n      } else if (sType === \"oscillator\") {\n        this.type = baseType;\n      } else if (sType === \"pulse\") {\n        this.type = \"pulse\";\n      } else if (sType === \"pwm\") {\n        this.type = \"pwm\";\n      }\n    }\n  }, {\n    key: \"_getOscType\",\n    value: function _getOscType(osc, sourceType) {\n      return osc instanceof OmniOscillatorSourceMap[sourceType];\n    }\n    /**\n     * The base type of the oscillator. See [[Oscillator.baseType]]\n     * @example\n     * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n     * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n     */\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._oscillator.baseType;\n    },\n    set: function set(baseType) {\n      if (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\") && baseType !== \"pulse\" && baseType !== \"pwm\") {\n        this._oscillator.baseType = baseType;\n      }\n    }\n    /**\n     * The width of the oscillator when sourceType === \"pulse\".\n     * See [[PWMOscillator.width]]\n     */\n  }, {\n    key: \"width\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"pulse\")) {\n        return this._oscillator.width;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * The number of detuned oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n  }, {\n    key: \"count\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fat\")) {\n        return this._oscillator.count;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(count) {\n      if (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n        this._oscillator.count = count;\n      }\n    }\n    /**\n     * The detune spread between the oscillators when sourceType === \"fat\".\n     * See [[FatOscillator.count]]\n     */\n  }, {\n    key: \"spread\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fat\")) {\n        return this._oscillator.spread;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(spread) {\n      if (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n        this._oscillator.spread = spread;\n      }\n    }\n    /**\n     * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n  }, {\n    key: \"modulationType\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n        return this._oscillator.modulationType;\n      } else {\n        return undefined;\n      }\n    },\n    set: function set(mType) {\n      if ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n        this._oscillator.modulationType = mType;\n      }\n    }\n    /**\n     * The modulation index when the sourceType === \"fm\"\n     * See [[FMOscillator]].\n     */\n  }, {\n    key: \"modulationIndex\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\")) {\n        return this._oscillator.modulationIndex;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n     * See [[AMOscillator]] or [[FMOscillator]]\n     */\n  }, {\n    key: \"harmonicity\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n        return this._oscillator.harmonicity;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n     * see [[PWMOscillator]]\n     * @min 0.1\n     * @max 5\n     */\n  }, {\n    key: \"modulationFrequency\",\n    get: function get() {\n      if (this._getOscType(this._oscillator, \"pwm\")) {\n        return this._oscillator.modulationFrequency;\n      } else {\n        return undefined;\n      }\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", generateWaveform(this, length));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(OmniOscillator.prototype), \"dispose\", this).call(this);\n      this.detune.dispose();\n      this.frequency.dispose();\n      this._oscillator.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Oscillator.getDefaults(), FMOscillator.getDefaults(), AMOscillator.getDefaults(), FatOscillator.getDefaults(), PulseOscillator.getDefaults(), PWMOscillator.getDefaults());\n    }\n  }]);\n  return OmniOscillator;\n}(Source);","map":{"version":3,"mappings":"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","names":["optionsFromArguments","readOnly","isNumber","isString","Signal","Source","AMOscillator","FatOscillator","FMOscillator","Oscillator","generateWaveform","PulseOscillator","PWMOscillator","OmniOscillatorSourceMap","am","fat","fm","oscillator","pulse","pwm","OmniOscillator","getDefaults","arguments","options","frequency","context","units","value","detune","set","time","_oscillator","start","stop","restart","prefix","some","_sourceType","p","type","substr","_createNewOscillator","partials","_getOscType","partialCount","props","Reflect","has","oscType","OscConstructor","now","oldOsc","setTimeout","dispose","blockTime","connect","output","onstop","state","phase","sType","baseType","osc","sourceType","width","undefined","count","spread","modulationType","mType","modulationIndex","harmonicity","modulationFrequency","length","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\oscillator\\OmniOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isNumber, isString } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { AMOscillator } from \"./AMOscillator\";\nimport { FatOscillator } from \"./FatOscillator\";\nimport { FMOscillator } from \"./FMOscillator\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tgenerateWaveform,\n\tOmniOscillatorOptions, \n\tOmniOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { PulseOscillator } from \"./PulseOscillator\";\nimport { PWMOscillator } from \"./PWMOscillator\";\n\nexport { OmniOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * All of the oscillator types that OmniOscillator can take on\n */\ntype AnyOscillator = Oscillator | PWMOscillator | PulseOscillator | FatOscillator | AMOscillator | FMOscillator;\n\n/**\n * All of the Oscillator constructor types mapped to their name.\n */\ninterface OmniOscillatorSource {\n\t\"fm\": FMOscillator;\n\t\"am\": AMOscillator;\n\t\"pwm\": PWMOscillator;\n\t\"pulse\": PulseOscillator;\n\t\"oscillator\": Oscillator;\n\t\"fat\": FatOscillator;\n}\n\n/**\n * The available oscillator types.\n */\nexport type OmniOscSourceType = keyof OmniOscillatorSource;\n\n// Conditional Types\ntype IsAmOrFmOscillator<Osc, Ret> = Osc extends AMOscillator ? Ret : Osc extends FMOscillator ? Ret : undefined;\ntype IsFatOscillator<Osc, Ret> = Osc extends FatOscillator ? Ret : undefined;\ntype IsPWMOscillator<Osc, Ret> = Osc extends PWMOscillator ? Ret : undefined;\ntype IsPulseOscillator<Osc, Ret> = Osc extends PulseOscillator ? Ret : undefined;\ntype IsFMOscillator<Osc, Ret> = Osc extends FMOscillator ? Ret : undefined;\n\ntype AnyOscillatorConstructor = new (...args: any[]) => AnyOscillator;\n\nconst OmniOscillatorSourceMap: {\n\t[key in OmniOscSourceType]: AnyOscillatorConstructor\n} = {\n\tam: AMOscillator,\n\tfat: FatOscillator,\n\tfm: FMOscillator,\n\toscillator: Oscillator,\n\tpulse: PulseOscillator,\n\tpwm: PWMOscillator,\n};\n\n/**\n * OmniOscillator aggregates all of the oscillator types into one. \n * @example\n * return Tone.Offline(() => {\n * \tconst omniOsc = new Tone.OmniOscillator(\"C#4\", \"pwm\").toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class OmniOscillator<OscType extends AnyOscillator>\n\textends Source<OmniOscillatorOptions>\n\timplements Omit<ToneOscillatorInterface, \"type\"> {\n\n\treadonly name: string = \"OmniOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The oscillator that can switch types\n\t */\n\tprivate _oscillator!: AnyOscillator;\n\n\t/**\n\t * the type of the oscillator source\n\t */\n\tprivate _sourceType!: OmniOscSourceType;\n\n\t/**\n\t * @param frequency The initial frequency of the oscillator.\n\t * @param type The type of the oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: OmniOscillatorType);\n\tconstructor(options?: Partial<OmniOscillatorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(OmniOscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\n\t\t// set the options\n\t\tthis.set(options);\n\t}\n\n\tstatic getDefaults(): OmniOscillatorOptions {\n\t\treturn Object.assign(\n\t\t\tOscillator.getDefaults(),\n\t\t\tFMOscillator.getDefaults(),\n\t\t\tAMOscillator.getDefaults(),\n\t\t\tFatOscillator.getDefaults(),\n\t\t\tPulseOscillator.getDefaults(),\n\t\t\tPWMOscillator.getDefaults(),\n\t\t);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._oscillator.start(time);\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._oscillator.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._oscillator.restart(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The type of the oscillator. Can be any of the basic types: sine, square, triangle, sawtooth. Or\n\t * prefix the basic types with \"fm\", \"am\", or \"fat\" to use the FMOscillator, AMOscillator or FatOscillator\n\t * types. The oscillator could also be set to \"pwm\" or \"pulse\". All of the parameters of the\n\t * oscillator's class are accessible when the oscillator is set to that type, but throws an error\n\t * when it's not. \n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator().toDestination().start();\n\t * omniOsc.type = \"pwm\";\n\t * // modulationFrequency is parameter which is available\n\t * // only when the type is \"pwm\".\n\t * omniOsc.modulationFrequency.value = 0.5;\n\t */\n\tget type(): OmniOscillatorType {\n\t\tlet prefix = \"\";\n\t\tif ([\"am\", \"fm\", \"fat\"].some(p => this._sourceType === p)) {\n\t\t\tprefix = this._sourceType;\n\t\t}\n\t\treturn prefix + this._oscillator.type as OmniOscillatorType;\n\t}\n\tset type(type) {\n\t\tif (type.substr(0, 2) === \"fm\") {\n\t\t\tthis._createNewOscillator(\"fm\");\n\t\t\tthis._oscillator = this._oscillator as FMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 2) === \"am\") {\n\t\t\tthis._createNewOscillator(\"am\");\n\t\t\tthis._oscillator = this._oscillator as AMOscillator;\n\t\t\tthis._oscillator.type = type.substr(2) as ToneOscillatorType;\n\t\t} else if (type.substr(0, 3) === \"fat\") {\n\t\t\tthis._createNewOscillator(\"fat\");\n\t\t\tthis._oscillator = this._oscillator as FatOscillator;\n\t\t\tthis._oscillator.type = type.substr(3) as ToneOscillatorType;\n\t\t} else if (type === \"pwm\") {\n\t\t\tthis._createNewOscillator(\"pwm\");\n\t\t\tthis._oscillator = this._oscillator as PWMOscillator;\n\t\t} else if (type === \"pulse\") {\n\t\t\tthis._createNewOscillator(\"pulse\");\n\t\t} else {\n\t\t\tthis._createNewOscillator(\"oscillator\");\n\t\t\tthis._oscillator = this._oscillator as Oscillator;\n\t\t\tthis._oscillator.type = (type as ToneOscillatorType);\n\t\t}\n\t}\n\n\t/**\n\t * The value is an empty array when the type is not \"custom\".\n\t * This is not available on \"pwm\" and \"pulse\" oscillator types.\n\t * See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partials = partials;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillator.partialCount;\n\t}\n\tset partialCount(partialCount) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") && !this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\tthis._oscillator.partialCount = partialCount;\n\t\t}\n\t}\n\n\tset(props: Partial<OmniOscillatorOptions>): this {\n\t\t// make sure the type is set first\n\t\tif (Reflect.has(props, \"type\") && props.type) {\n\t\t\tthis.type = props.type;\n\t\t}\n\t\t// then set the rest\n\t\tsuper.set(props);\n\t\treturn this;\n\t}\n\n\t/**\n\t * connect the oscillator to the frequency and detune signals\n\t */\n\tprivate _createNewOscillator(oscType: OmniOscSourceType): void {\n\t\tif (oscType !== this._sourceType) {\n\t\t\tthis._sourceType = oscType;\n\t\t\tconst OscConstructor = OmniOscillatorSourceMap[oscType];\n\t\t\t// short delay to avoid clicks on the change\n\t\t\tconst now = this.now();\n\t\t\tif (this._oscillator) {\n\t\t\t\tconst oldOsc = this._oscillator;\n\t\t\t\toldOsc.stop(now);\n\t\t\t\t// dispose the old one\n\t\t\t\tthis.context.setTimeout(() => oldOsc.dispose(), this.blockTime);\n\t\t\t}\n\t\t\tthis._oscillator = new OscConstructor({\n\t\t\t\tcontext: this.context,\n\t\t\t});\n\t\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\t\tthis.detune.connect(this._oscillator.detune);\n\t\t\tthis._oscillator.connect(this.output);\n\t\t\tthis._oscillator.onstop = () => this.onstop(this);\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._oscillator.start(now);\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t}\n\n\t/**\n\t * The source type of the oscillator.\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare\");\n\t * console.log(omniOsc.sourceType); // 'fm'\n\t */\n\tget sourceType(): OmniOscSourceType {\n\t\treturn this._sourceType;\n\t}\n\tset sourceType(sType) {\n\t\t// the basetype defaults to sine\n\t\tlet baseType = \"sine\";\n\t\tif (this._oscillator.type !== \"pwm\" && this._oscillator.type !== \"pulse\") {\n\t\t\tbaseType = this._oscillator.type;\n\t\t}\n\n\t\t// set the type\n\t\tif (sType === \"fm\") {\n\t\t\tthis.type = \"fm\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"am\") {\n\t\t\tthis.type = \"am\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"fat\") {\n\t\t\tthis.type = \"fat\" + baseType as OmniOscillatorType;\n\t\t} else if (sType === \"oscillator\") {\n\t\t\tthis.type = baseType as OmniOscillatorType;\n\t\t} else if (sType === \"pulse\") {\n\t\t\tthis.type = \"pulse\";\n\t\t} else if (sType === \"pwm\") {\n\t\t\tthis.type = \"pwm\";\n\t\t}\n\t}\n\n\tprivate _getOscType<SourceType extends OmniOscSourceType>(\n\t\tosc: AnyOscillator,\n\t\tsourceType: SourceType,\n\t): osc is OmniOscillatorSource[SourceType] {\n\t\treturn osc instanceof OmniOscillatorSourceMap[sourceType];\n\t}\n\n\t/**\n\t * The base type of the oscillator. See [[Oscillator.baseType]]\n\t * @example\n\t * const omniOsc = new Tone.OmniOscillator(440, \"fmsquare4\");\n\t * console.log(omniOsc.sourceType, omniOsc.baseType, omniOsc.partialCount);\n\t */\n\tget baseType(): OscillatorType | \"pwm\" | \"pulse\" {\n\t\treturn this._oscillator.baseType;\n\t}\n\tset baseType(baseType) {\n\t\tif (!this._getOscType(this._oscillator, \"pulse\") &&\n\t\t\t!this._getOscType(this._oscillator, \"pwm\") &&\n\t\t\tbaseType !== \"pulse\" && baseType !== \"pwm\") {\n\t\t\tthis._oscillator.baseType = baseType;\n\t\t}\n\t}\n\n\t/**\n\t * The width of the oscillator when sourceType === \"pulse\".\n\t * See [[PWMOscillator.width]]\n\t */\n\tget width(): IsPulseOscillator<OscType, Signal<\"audioRange\">> {\n\t\tif (this._getOscType(this._oscillator, \"pulse\")) {\n\t\t\treturn this._oscillator.width as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPulseOscillator<OscType, Signal<\"audioRange\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget count(): IsFatOscillator<OscType, number> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.count as IsFatOscillator<OscType, number>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, number>;\n\t\t}\n\t}\n\tset count(count) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(count)) {\n\t\t\tthis._oscillator.count = count;\n\t\t}\n\t}\n\n\t/**\n\t * The detune spread between the oscillators when sourceType === \"fat\".\n\t * See [[FatOscillator.count]]\n\t */\n\tget spread(): IsFatOscillator<OscType, Cents> {\n\t\tif (this._getOscType(this._oscillator, \"fat\")) {\n\t\t\treturn this._oscillator.spread as IsFatOscillator<OscType, Cents>;\n\t\t} else {\n\t\t\treturn undefined as IsFatOscillator<OscType, Cents>;\n\t\t}\n\t}\n\tset spread(spread) {\n\t\tif (this._getOscType(this._oscillator, \"fat\") && isNumber(spread)) {\n\t\t\tthis._oscillator.spread = spread;\n\t\t}\n\t}\n\n\t/**\n\t * The type of the modulator oscillator. Only if the oscillator is set to \"am\" or \"fm\" types. \n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget modulationType(): IsAmOrFmOscillator<OscType, ToneOscillatorType> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.modulationType as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, ToneOscillatorType>;\n\t\t}\n\t}\n\tset modulationType(mType) {\n\t\tif ((this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) && isString(mType)) {\n\t\t\tthis._oscillator.modulationType = mType;\n\t\t}\n\t}\n\n\t/**\n\t * The modulation index when the sourceType === \"fm\"\n\t * See [[FMOscillator]].\n\t */\n\tget modulationIndex(): IsFMOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\")) {\n\t\t\treturn this._oscillator.modulationIndex as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsFMOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * See [[AMOscillator]] or [[FMOscillator]]\n\t */\n\tget harmonicity(): IsAmOrFmOscillator<OscType, Signal<\"positive\">> {\n\t\tif (this._getOscType(this._oscillator, \"fm\") || this._getOscType(this._oscillator, \"am\")) {\n\t\t\treturn this._oscillator.harmonicity as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t} else {\n\t\t\treturn undefined as IsAmOrFmOscillator<OscType, Signal<\"positive\">>;\n\t\t}\n\t}\n\n\t/**\n\t * The modulationFrequency Signal of the oscillator when sourceType === \"pwm\"\n\t * see [[PWMOscillator]]\n\t * @min 0.1\n\t * @max 5\n\t */\n\tget modulationFrequency(): IsPWMOscillator<OscType, Signal<\"frequency\">> {\n\t\tif (this._getOscType(this._oscillator, \"pwm\")) {\n\t\t\treturn this._oscillator.modulationFrequency as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t} else {\n\t\t\treturn undefined as IsPWMOscillator<OscType, Signal<\"frequency\">>;\n\t\t}\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.detune.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._oscillator.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass } from \"./TimeBase\";\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport var TimeClass = /*#__PURE__*/function (_TimeBaseClass) {\n  _inherits(TimeClass, _TimeBaseClass);\n  var _super = _createSuper(TimeClass);\n  function TimeClass() {\n    var _this;\n    _classCallCheck(this, TimeClass);\n    _this = _super.apply(this, arguments);\n    _this.name = \"TimeClass\";\n    return _this;\n  }\n  _createClass(TimeClass, [{\n    key: \"_getExpressions\",\n    value: function _getExpressions() {\n      var _this2 = this;\n      return Object.assign(_get(_getPrototypeOf(TimeClass.prototype), \"_getExpressions\", this).call(this), {\n        now: {\n          method: function method(capture) {\n            return _this2._now() + new _this2.constructor(_this2.context, capture).valueOf();\n          },\n          regexp: /^\\+(.+)/\n        },\n        quantize: {\n          method: function method(capture) {\n            var quantTo = new TimeClass(_this2.context, capture).valueOf();\n            return _this2._secondsToUnits(_this2.context.transport.nextSubdivision(quantTo));\n          },\n          regexp: /^@(.+)/\n        }\n      });\n    }\n    /**\n     * Quantize the time by the given subdivision. Optionally add a\n     * percentage which will move the time value towards the ideal\n     * quantized value by that percentage.\n     * @param  subdiv    The subdivision to quantize to\n     * @param  percent  Move the time value towards the quantized value by a percentage.\n     * @example\n     * Tone.Time(21).quantize(2); // returns 22\n     * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n     */\n  }, {\n    key: \"quantize\",\n    value: function quantize(subdiv) {\n      var percent = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      var subdivision = new this.constructor(this.context, subdiv).valueOf();\n      var value = this.valueOf();\n      var multiple = Math.round(value / subdivision);\n      var ideal = multiple * subdivision;\n      var diff = ideal - value;\n      return value + diff * percent;\n    }\n    //-------------------------------------\n    // CONVERSIONS\n    //-------------------------------------\n    /**\n     * Convert a Time to Notation. The notation values are will be the\n     * closest representation between 1m to 128th note.\n     * @return {Notation}\n     * @example\n     * // if the Transport is at 120bpm:\n     * Tone.Time(2).toNotation(); // returns \"1m\"\n     */\n  }, {\n    key: \"toNotation\",\n    value: function toNotation() {\n      var _this3 = this;\n      var time = this.toSeconds();\n      var testNotations = [\"1m\"];\n      for (var power = 1; power < 9; power++) {\n        var subdiv = Math.pow(2, power);\n        testNotations.push(subdiv + \"n.\");\n        testNotations.push(subdiv + \"n\");\n        testNotations.push(subdiv + \"t\");\n      }\n      testNotations.push(\"0\");\n      // find the closets notation representation\n      var closest = testNotations[0];\n      var closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n      testNotations.forEach(function (notation) {\n        var notationSeconds = new TimeClass(_this3.context, notation).toSeconds();\n        if (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n          closest = notation;\n          closestSeconds = notationSeconds;\n        }\n      });\n      return closest;\n    }\n    /**\n     * Return the time encoded as Bars:Beats:Sixteenths.\n     */\n  }, {\n    key: \"toBarsBeatsSixteenths\",\n    value: function toBarsBeatsSixteenths() {\n      var quarterTime = this._beatsToUnits(1);\n      var quarters = this.valueOf() / quarterTime;\n      quarters = parseFloat(quarters.toFixed(4));\n      var measures = Math.floor(quarters / this._getTimeSignature());\n      var sixteenths = quarters % 1 * 4;\n      quarters = Math.floor(quarters) % this._getTimeSignature();\n      var sixteenthString = sixteenths.toString();\n      if (sixteenthString.length > 3) {\n        // the additional parseFloat removes insignificant trailing zeroes\n        sixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n      }\n      var progress = [measures, quarters, sixteenths];\n      return progress.join(\":\");\n    }\n    /**\n     * Return the time in ticks.\n     */\n  }, {\n    key: \"toTicks\",\n    value: function toTicks() {\n      var quarterTime = this._beatsToUnits(1);\n      var quarters = this.valueOf() / quarterTime;\n      return Math.round(quarters * this._getPPQ());\n    }\n    /**\n     * Return the time in seconds.\n     */\n  }, {\n    key: \"toSeconds\",\n    value: function toSeconds() {\n      return this.valueOf();\n    }\n    /**\n     * Return the value as a midi note.\n     */\n  }, {\n    key: \"toMidi\",\n    value: function toMidi() {\n      return ftom(this.toFrequency());\n    }\n  }, {\n    key: \"_now\",\n    value: function _now() {\n      return this.context.now();\n    }\n  }]);\n  return TimeClass;\n}(TimeBaseClass);\n/**\n * Create a TimeClass from a time string or number. The time is computed against the\n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value, units) {\n  return new TimeClass(getContext(), value, units);\n}","map":{"version":3,"mappings":"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","names":["getContext","ftom","TimeBaseClass","TimeClass","Object","assign","now","method","capture","_now","constructor","context","valueOf","regexp","quantize","quantTo","_secondsToUnits","transport","nextSubdivision","subdiv","percent","subdivision","value","multiple","Math","round","ideal","diff","time","toSeconds","testNotations","power","pow","push","closest","closestSeconds","forEach","notationSeconds","notation","abs","quarterTime","_beatsToUnits","quarters","parseFloat","toFixed","measures","floor","_getTimeSignature","sixteenths","sixteenthString","toString","length","progress","join","_getPPQ","toFrequency","Time","units"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\type\\Time.ts"],"sourcesContent":["import { getContext } from \"../Global\";\nimport { ftom } from \"./Conversions\";\nimport { TimeBaseClass, TimeBaseUnit, TimeExpression, TimeValue } from \"./TimeBase\";\nimport { BarsBeatsSixteenths, MidiNote, Seconds, Subdivision, Ticks, Time } from \"./Units\";\n\n/**\n * TimeClass is a primitive type for encoding and decoding Time values.\n * TimeClass can be passed into the parameter of any method which takes time as an argument.\n * @param  val    The time value.\n * @param  units  The units of the value.\n * @example\n * const time = Tone.Time(\"4n\"); // a quarter note\n * @category Unit\n */\nexport class TimeClass<Type extends Seconds | Ticks = Seconds, Unit extends string = TimeBaseUnit>\n\textends TimeBaseClass<Type, Unit> {\n\n\treadonly name: string = \"TimeClass\";\n\n\tprotected _getExpressions(): TimeExpression<Type> {\n\t\treturn Object.assign(super._getExpressions(), {\n\t\t\tnow: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\treturn this._now() + new (this.constructor as typeof TimeClass)(this.context, capture).valueOf() as Type;\n\t\t\t\t},\n\t\t\t\tregexp: /^\\+(.+)/,\n\t\t\t},\n\t\t\tquantize: {\n\t\t\t\tmethod: (capture: string): Type => {\n\t\t\t\t\tconst quantTo = new TimeClass(this.context, capture).valueOf();\n\t\t\t\t\treturn this._secondsToUnits(this.context.transport.nextSubdivision(quantTo));\n\t\t\t\t},\n\t\t\t\tregexp: /^@(.+)/,\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * Quantize the time by the given subdivision. Optionally add a\n\t * percentage which will move the time value towards the ideal\n\t * quantized value by that percentage.\n\t * @param  subdiv    The subdivision to quantize to\n\t * @param  percent  Move the time value towards the quantized value by a percentage.\n\t * @example\n\t * Tone.Time(21).quantize(2); // returns 22\n\t * Tone.Time(0.6).quantize(\"4n\", 0.5); // returns 0.55\n\t */\n\tquantize(subdiv: Time, percent = 1): Type {\n\t\tconst subdivision = new (this.constructor as typeof TimeClass)(this.context, subdiv).valueOf();\n\t\tconst value = this.valueOf();\n\t\tconst multiple = Math.round(value / subdivision);\n\t\tconst ideal = multiple * subdivision;\n\t\tconst diff = ideal - value;\n\t\treturn value + diff * percent as Type;\n\t}\n\n\t//-------------------------------------\n\t// CONVERSIONS\n\t//-------------------------------------\n\t/**\n\t * Convert a Time to Notation. The notation values are will be the\n\t * closest representation between 1m to 128th note.\n\t * @return {Notation}\n\t * @example\n\t * // if the Transport is at 120bpm:\n\t * Tone.Time(2).toNotation(); // returns \"1m\"\n\t */\n\ttoNotation(): Subdivision {\n\t\tconst time = this.toSeconds();\n\t\tconst testNotations: Subdivision[] = [\"1m\"];\n\t\tfor (let power = 1; power < 9; power++) {\n\t\t\tconst subdiv = Math.pow(2, power);\n\t\t\ttestNotations.push(subdiv + \"n.\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"n\" as Subdivision);\n\t\t\ttestNotations.push(subdiv + \"t\" as Subdivision);\n\t\t}\n\t\ttestNotations.push(\"0\");\n\t\t// find the closets notation representation\n\t\tlet closest = testNotations[0];\n\t\tlet closestSeconds = new TimeClass(this.context, testNotations[0]).toSeconds();\n\t\ttestNotations.forEach(notation => {\n\t\t\tconst notationSeconds = new TimeClass(this.context, notation).toSeconds();\n\t\t\tif (Math.abs(notationSeconds - time) < Math.abs(closestSeconds - time)) {\n\t\t\t\tclosest = notation;\n\t\t\t\tclosestSeconds = notationSeconds;\n\t\t\t}\n\t\t});\n\t\treturn closest;\n\t}\n\n\t/**\n\t * Return the time encoded as Bars:Beats:Sixteenths.\n\t */\n\ttoBarsBeatsSixteenths(): BarsBeatsSixteenths {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tlet quarters = this.valueOf() / quarterTime;\n\t\tquarters = parseFloat(quarters.toFixed(4));\n\t\tconst measures = Math.floor(quarters / this._getTimeSignature());\n\t\tlet sixteenths = (quarters % 1) * 4;\n\t\tquarters = Math.floor(quarters) % this._getTimeSignature();\n\t\tconst sixteenthString = sixteenths.toString();\n\t\tif (sixteenthString.length > 3) {\n\t\t\t// the additional parseFloat removes insignificant trailing zeroes\n\t\t\tsixteenths = parseFloat(parseFloat(sixteenthString).toFixed(3));\n\t\t}\n\t\tconst progress = [measures, quarters, sixteenths];\n\t\treturn progress.join(\":\");\n\t}\n\n\t/**\n\t * Return the time in ticks.\n\t */\n\ttoTicks(): Ticks {\n\t\tconst quarterTime = this._beatsToUnits(1);\n\t\tconst quarters = this.valueOf() / quarterTime;\n\t\treturn Math.round(quarters * this._getPPQ());\n\t}\n\n\t/**\n\t * Return the time in seconds.\n\t */\n\ttoSeconds(): Seconds {\n\t\treturn this.valueOf();\n\t}\n\n\t/**\n\t * Return the value as a midi note.\n\t */\n\ttoMidi(): MidiNote {\n\t\treturn ftom(this.toFrequency());\n\t}\n\n\tprotected _now(): Type {\n\t\treturn this.context.now() as Type;\n\t}\n}\n\n/**\n * Create a TimeClass from a time string or number. The time is computed against the \n * global Tone.Context. To use a specific context, use [[TimeClass]]\n * @param value A value which represents time\n * @param units The value's units if they can't be inferred by the value.\n * @category Unit\n * @example\n * const time = Tone.Time(\"4n\").toSeconds();\n * console.log(time);\n * @example\n * const note = Tone.Time(1).toNotation();\n * console.log(note);\n * @example\n * const freq = Tone.Time(0.5).toFrequency();\n * console.log(freq);\n */\nexport function Time(value?: TimeValue, units?: TimeBaseUnit): TimeClass<Seconds> {\n\treturn new TimeClass(getContext(), value, units);\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
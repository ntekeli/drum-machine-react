{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Timeline } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport var StateTimeline = /*#__PURE__*/function (_Timeline) {\n  _inherits(StateTimeline, _Timeline);\n  var _super = _createSuper(StateTimeline);\n  function StateTimeline() {\n    var _this;\n    var initial = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : \"stopped\";\n    _classCallCheck(this, StateTimeline);\n    _this = _super.call(this);\n    _this.name = \"StateTimeline\";\n    _this._initial = initial;\n    _this.setStateAtTime(_this._initial, 0);\n    return _this;\n  }\n  /**\n   * Returns the scheduled state scheduled before or at\n   * the given time.\n   * @param  time  The time to query.\n   * @return  The name of the state input in setStateAtTime.\n   */\n  _createClass(StateTimeline, [{\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      var event = this.get(time);\n      if (event !== null) {\n        return event.state;\n      } else {\n        return this._initial;\n      }\n    }\n    /**\n     * Add a state to the timeline.\n     * @param  state The name of the state to set.\n     * @param  time  The time to query.\n     * @param options Any additional options that are needed in the timeline.\n     */\n  }, {\n    key: \"setStateAtTime\",\n    value: function setStateAtTime(state, time, options) {\n      assertRange(time, 0);\n      this.add(Object.assign({}, options, {\n        state: state,\n        time: time\n      }));\n      return this;\n    }\n    /**\n     * Return the event before the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check before\n     * @return  The event with the given state before the time\n     */\n  }, {\n    key: \"getLastState\",\n    value: function getLastState(state, time) {\n      // time = this.toSeconds(time);\n      var index = this._search(time);\n      for (var i = index; i >= 0; i--) {\n        var event = this._timeline[i];\n        if (event.state === state) {\n          return event;\n        }\n      }\n    }\n    /**\n     * Return the event after the time with the given state\n     * @param  state The state to look for\n     * @param  time  When to check from\n     * @return  The event with the given state after the time\n     */\n  }, {\n    key: \"getNextState\",\n    value: function getNextState(state, time) {\n      // time = this.toSeconds(time);\n      var index = this._search(time);\n      if (index !== -1) {\n        for (var i = index; i < this._timeline.length; i++) {\n          var event = this._timeline[i];\n          if (event.state === state) {\n            return event;\n          }\n        }\n      }\n    }\n  }]);\n  return StateTimeline;\n}(Timeline);","map":{"version":3,"mappings":";;;;AACA,SAASA,QAAQ,QAAuB,YAAY;AACpD,SAASC,WAAW,QAAQ,SAAS;AASrC;;;;AAIA,WAAaC,aAAiD;EAAA;EAAA;EAS7D,yBAA8C;IAAA;IAAA,IAAlCC,8EAAyB,SAAS;IAAA;IAC7C;IARQ,UAAI,GAAW,eAAe;IAStC,MAAKC,QAAQ,GAAGD,OAAO;IACvB,MAAKE,cAAc,CAAC,MAAKD,QAAQ,EAAE,CAAC,CAAC;IAAC;EACvC;EAEA;;;;;;EAAA;IAAA;IAAA,OAMA,wBAAeE,IAAa;MAC3B,IAAMC,KAAK,GAAG,IAAI,CAACC,GAAG,CAACF,IAAI,CAAC;MAC5B,IAAIC,KAAK,KAAK,IAAI,EAAE;QACnB,OAAOA,KAAK,CAACE,KAAK;OAClB,MAAM;QACN,OAAO,IAAI,CAACL,QAAQ;;IAEtB;IAEA;;;;;;EAAA;IAAA;IAAA,OAMA,wBAAeK,KAAoB,EAAEH,IAAa,EAAEI,OAA2B;MAC9ET,WAAW,CAACK,IAAI,EAAE,CAAC,CAAC;MACpB,IAAI,CAACK,GAAG,CAACC,MAAM,CAACC,MAAM,CAAC,EAAE,EAAEH,OAAO,EAAE;QACnCD,KAAK,EAALA,KAAK;QACLH,IAAI,EAAJA;OACA,CAAC,CAAC;MACH,OAAO,IAAI;IACZ;IAEA;;;;;;EAAA;IAAA;IAAA,OAMA,sBAAaG,KAAoB,EAAEH,IAAY;MAC9C;MACA,IAAMQ,KAAK,GAAG,IAAI,CAACC,OAAO,CAACT,IAAI,CAAC;MAChC,KAAK,IAAIU,CAAC,GAAGF,KAAK,EAAEE,CAAC,IAAI,CAAC,EAAEA,CAAC,EAAE,EAAE;QAChC,IAAMT,KAAK,GAAG,IAAI,CAACU,SAAS,CAACD,CAAC,CAAC;QAC/B,IAAIT,KAAK,CAACE,KAAK,KAAKA,KAAK,EAAE;UAC1B,OAAOF,KAAK;;;IAGf;IAEA;;;;;;EAAA;IAAA;IAAA,OAMA,sBAAaE,KAAoB,EAAEH,IAAY;MAC9C;MACA,IAAMQ,KAAK,GAAG,IAAI,CAACC,OAAO,CAACT,IAAI,CAAC;MAChC,IAAIQ,KAAK,KAAK,CAAC,CAAC,EAAE;QACjB,KAAK,IAAIE,CAAC,GAAGF,KAAK,EAAEE,CAAC,GAAG,IAAI,CAACC,SAAS,CAACC,MAAM,EAAEF,CAAC,EAAE,EAAE;UACnD,IAAMT,KAAK,GAAG,IAAI,CAACU,SAAS,CAACD,CAAC,CAAC;UAC/B,IAAIT,KAAK,CAACE,KAAK,KAAKA,KAAK,EAAE;YAC1B,OAAOF,KAAK;;;;IAIhB;EAAC;EAAA;AAAA,EA/EoEP,QAAgD","names":["Timeline","assertRange","StateTimeline","initial","_initial","setStateAtTime","time","event","get","state","options","add","Object","assign","index","_search","i","_timeline","length"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\util\\StateTimeline.ts"],"sourcesContent":["import { Seconds } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { assertRange } from \"./Debug\";\n\nexport type BasicPlaybackState = \"started\" | \"stopped\";\nexport type PlaybackState = BasicPlaybackState | \"paused\";\n\nexport interface StateTimelineEvent extends TimelineEvent {\n\tstate: PlaybackState;\n}\n\n/**\n * A Timeline State. Provides the methods: `setStateAtTime(\"state\", time)` and `getValueAtTime(time)`\n * @param initial The initial state of the StateTimeline.  Defaults to `undefined`\n */\nexport class StateTimeline<AdditionalOptions extends {} = {}> extends Timeline<StateTimelineEvent & AdditionalOptions> {\n\n\treadonly name: string = \"StateTimeline\";\n\n\t/**\n\t * The initial state\n\t */\n\tprivate _initial: PlaybackState;\n\n\tconstructor(initial: PlaybackState = \"stopped\") {\n\t\tsuper();\n\t\tthis._initial = initial;\n\t\tthis.setStateAtTime(this._initial, 0);\n\t}\n\n\t/**\n\t * Returns the scheduled state scheduled before or at\n\t * the given time.\n\t * @param  time  The time to query.\n\t * @return  The name of the state input in setStateAtTime.\n\t */\n\tgetValueAtTime(time: Seconds): PlaybackState {\n\t\tconst event = this.get(time);\n\t\tif (event !== null) {\n\t\t\treturn event.state;\n\t\t} else {\n\t\t\treturn this._initial;\n\t\t}\n\t}\n\n\t/**\n\t * Add a state to the timeline.\n\t * @param  state The name of the state to set.\n\t * @param  time  The time to query.\n\t * @param options Any additional options that are needed in the timeline.\n\t */\n\tsetStateAtTime(state: PlaybackState, time: Seconds, options?: AdditionalOptions): this {\n\t\tassertRange(time, 0);\n\t\tthis.add(Object.assign({}, options, {\n\t\t\tstate,\n\t\t\ttime,\n\t\t}));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Return the event before the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check before\n\t * @return  The event with the given state before the time\n\t */\n\tgetLastState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tfor (let i = index; i >= 0; i--) {\n\t\t\tconst event = this._timeline[i];\n\t\t\tif (event.state === state) {\n\t\t\t\treturn event;\n\t\t\t}\n\t\t}\n\t}\n\n\t/**\n\t * Return the event after the time with the given state\n\t * @param  state The state to look for\n\t * @param  time  When to check from\n\t * @return  The event with the given state after the time\n\t */\n\tgetNextState(state: PlaybackState, time: number): StateTimelineEvent & AdditionalOptions | undefined {\n\t\t// time = this.toSeconds(time);\n\t\tconst index = this._search(time);\n\t\tif (index !== -1) {\n\t\t\tfor (let i = index; i < this._timeline.length; i++) {\n\t\t\t\tconst event = this._timeline[i];\n\t\t\t\tif (event.state === state) {\n\t\t\t\t\treturn event;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
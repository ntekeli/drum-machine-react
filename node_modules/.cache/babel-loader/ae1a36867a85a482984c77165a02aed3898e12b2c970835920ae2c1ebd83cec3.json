{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport var FatOscillator = /*#__PURE__*/function (_Source) {\n  _inherits(FatOscillator, _Source);\n  var _super = _createSuper(FatOscillator);\n  function FatOscillator() {\n    var _this;\n    _classCallCheck(this, FatOscillator);\n    _this = _super.call(this, optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n    _this.name = \"FatOscillator\";\n    /**\n     * The array of oscillators\n     */\n    _this._oscillators = [];\n    var options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    _this._spread = options.spread;\n    _this._type = options.type;\n    _this._phase = options.phase;\n    _this._partials = options.partials;\n    _this._partialCount = options.partialCount;\n    // set the count initially\n    _this.count = options.count;\n    readOnly(_assertThisInitialized(_this), [\"frequency\", \"detune\"]);\n    return _this;\n  }\n  _createClass(FatOscillator, [{\n    key: \"_start\",\n    value:\n    /**\n     * start the oscillator\n     */\n    function _start(time) {\n      time = this.toSeconds(time);\n      this._forEach(function (osc) {\n        return osc.start(time);\n      });\n    }\n    /**\n     * stop the oscillator\n     */\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      time = this.toSeconds(time);\n      this._forEach(function (osc) {\n        return osc.stop(time);\n      });\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      this._forEach(function (osc) {\n        return osc.restart(time);\n      });\n    }\n    /**\n     * Iterate over all of the oscillators\n     */\n  }, {\n    key: \"_forEach\",\n    value: function _forEach(iterator) {\n      for (var i = 0; i < this._oscillators.length; i++) {\n        iterator(this._oscillators[i], i);\n      }\n    }\n    /**\n     * The type of the oscillator\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      this._type = type;\n      this._forEach(function (osc) {\n        return osc.type = type;\n      });\n    }\n    /**\n     * The detune spread between the oscillators. If \"count\" is\n     * set to 3 oscillators and the \"spread\" is set to 40,\n     * the three oscillators would be detuned like this: [-20, 0, 20]\n     * for a total detune spread of 40 cents.\n     * @example\n     * const fatOsc = new Tone.FatOscillator().toDestination().start();\n     * fatOsc.spread = 70;\n     */\n  }, {\n    key: \"spread\",\n    get: function get() {\n      return this._spread;\n    },\n    set: function set(spread) {\n      this._spread = spread;\n      if (this._oscillators.length > 1) {\n        var start = -spread / 2;\n        var step = spread / (this._oscillators.length - 1);\n        this._forEach(function (osc, i) {\n          return osc.detune.value = start + step * i;\n        });\n      }\n    }\n    /**\n     * The number of detuned oscillators. Must be an integer greater than 1.\n     * @example\n     * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n     * // use 4 sawtooth oscillators\n     * fatOsc.count = 4;\n     */\n  }, {\n    key: \"count\",\n    get: function get() {\n      return this._oscillators.length;\n    },\n    set: function set(count) {\n      var _this2 = this;\n      assertRange(count, 1);\n      if (this._oscillators.length !== count) {\n        // dispose the previous oscillators\n        this._forEach(function (osc) {\n          return osc.dispose();\n        });\n        this._oscillators = [];\n        for (var i = 0; i < count; i++) {\n          var osc = new Oscillator({\n            context: this.context,\n            volume: -6 - count * 1.1,\n            type: this._type,\n            phase: this._phase + i / count * 360,\n            partialCount: this._partialCount,\n            onstop: i === 0 ? function () {\n              return _this2.onstop(_this2);\n            } : noOp\n          });\n          if (this.type === \"custom\") {\n            osc.partials = this._partials;\n          }\n          this.frequency.connect(osc.frequency);\n          this.detune.connect(osc.detune);\n          osc.detune.overridden = false;\n          osc.connect(this.output);\n          this._oscillators[i] = osc;\n        }\n        // set the spread\n        this.spread = this._spread;\n        if (this.state === \"started\") {\n          this._forEach(function (osc) {\n            return osc.start();\n          });\n        }\n      }\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._phase;\n    },\n    set: function set(phase) {\n      var _this3 = this;\n      this._phase = phase;\n      this._forEach(function (osc, i) {\n        return osc.phase = _this3._phase + i / _this3.count * 360;\n      });\n    }\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._oscillators[0].baseType;\n    },\n    set: function set(baseType) {\n      this._forEach(function (osc) {\n        return osc.baseType = baseType;\n      });\n      this._type = this._oscillators[0].type;\n    }\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._oscillators[0].partials;\n    },\n    set: function set(partials) {\n      this._partials = partials;\n      this._partialCount = this._partials.length;\n      if (partials.length) {\n        this._type = \"custom\";\n        this._forEach(function (osc) {\n          return osc.partials = partials;\n        });\n      }\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._oscillators[0].partialCount;\n    },\n    set: function set(partialCount) {\n      this._partialCount = partialCount;\n      this._forEach(function (osc) {\n        return osc.partialCount = partialCount;\n      });\n      this._type = this._oscillators[0].type;\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", generateWaveform(this, length));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(FatOscillator.prototype), \"dispose\", this).call(this);\n      this.frequency.dispose();\n      this.detune.dispose();\n      this._forEach(function (osc) {\n        return osc.dispose();\n      });\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Oscillator.getDefaults(), {\n        count: 3,\n        spread: 20,\n        type: \"sawtooth\"\n      });\n    }\n  }]);\n  return FatOscillator;\n}(Source);","map":{"version":3,"mappings":"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","names":["optionsFromArguments","noOp","readOnly","Signal","Source","Oscillator","generateWaveform","assertRange","FatOscillator","getDefaults","arguments","options","frequency","context","units","value","detune","_spread","spread","_type","type","_phase","phase","_partials","partials","_partialCount","partialCount","count","time","toSeconds","_forEach","osc","start","stop","restart","iterator","i","_oscillators","length","step","dispose","volume","onstop","connect","overridden","output","state","baseType","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\oscillator\\FatOscillator.ts"],"sourcesContent":["import { Cents, Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { noOp, readOnly } from \"../../core/util/Interface\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFatConstructorOptions, FatOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { assertRange } from \"../../core/util/Debug\";\n\nexport { FatOscillatorOptions } from \"./OscillatorInterface\";\n\n/**\n * FatOscillator is an array of oscillators with detune spread between the oscillators\n * @example\n * const fatOsc = new Tone.FatOscillator(\"Ab3\", \"sawtooth\", 40).toDestination().start();\n * @category Source\n */\nexport class FatOscillator extends Source<FatOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FatOscillator\";\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The array of oscillators\n\t */\n\tprivate _oscillators: Oscillator[] = [];\n\n\t/**\n\t * The total spread of the oscillators\n\t */\n\tprivate _spread: Cents;\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * The phase of the oscillators\n\t */\n\tprivate _phase: Degrees;\n\n\t/**\n\t * The partials array\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to use\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * @param frequency The oscillator's frequency.\n\t * @param type The type of the oscillator.\n\t * @param spread The detune spread between the oscillators.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, spread?: Cents);\n\tconstructor(options?: Partial<FatConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]));\n\t\tconst options = optionsFromArguments(FatOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"spread\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\tthis.detune = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\n\t\tthis._spread = options.spread;\n\t\tthis._type = options.type;\n\t\tthis._phase = options.phase;\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\n\t\t// set the count initially\n\t\tthis.count = options.count;\n\n\t\treadOnly(this, [\"frequency\", \"detune\"]);\n\t}\n\n\tstatic getDefaults(): FatOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tcount: 3,\n\t\t\tspread: 20,\n\t\t\ttype: \"sawtooth\",\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.start(time));\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\ttime = this.toSeconds(time);\n\t\tthis._forEach(osc => osc.stop(time));\n\t}\n\n\tprotected _restart(time: Seconds): void {\n\t\tthis._forEach(osc => osc.restart(time));\n\t}\n\n\t/**\n\t * Iterate over all of the oscillators\n\t */\n\tprivate _forEach(iterator: (osc: Oscillator, index: number) => void): void {\n\t\tfor (let i = 0; i < this._oscillators.length; i++) {\n\t\t\titerator(this._oscillators[i], i);\n\t\t}\n\t}\n\n\t/**\n\t * The type of the oscillator\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._type = type;\n\t\tthis._forEach(osc => osc.type = type);\n\t}\n\n\t/**\n\t * The detune spread between the oscillators. If \"count\" is\n\t * set to 3 oscillators and the \"spread\" is set to 40,\n\t * the three oscillators would be detuned like this: [-20, 0, 20]\n\t * for a total detune spread of 40 cents.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator().toDestination().start();\n\t * fatOsc.spread = 70;\n\t */\n\tget spread(): Cents {\n\t\treturn this._spread;\n\t}\n\tset spread(spread: Cents) {\n\t\tthis._spread = spread;\n\t\tif (this._oscillators.length > 1) {\n\t\t\tconst start = -spread / 2;\n\t\t\tconst step = spread / (this._oscillators.length - 1);\n\t\t\tthis._forEach((osc, i) => osc.detune.value = start + step * i);\n\t\t}\n\t}\n\n\t/**\n\t * The number of detuned oscillators. Must be an integer greater than 1.\n\t * @example\n\t * const fatOsc = new Tone.FatOscillator(\"C#3\", \"sawtooth\").toDestination().start();\n\t * // use 4 sawtooth oscillators\n\t * fatOsc.count = 4;\n\t */\n\tget count(): number {\n\t\treturn this._oscillators.length;\n\t}\n\tset count(count: number) {\n\t\tassertRange(count, 1);\n\t\tif (this._oscillators.length !== count) {\n\t\t\t// dispose the previous oscillators\n\t\t\tthis._forEach(osc => osc.dispose());\n\t\t\tthis._oscillators = [];\n\t\t\tfor (let i = 0; i < count; i++) {\n\t\t\t\tconst osc = new Oscillator({\n\t\t\t\t\tcontext: this.context,\n\t\t\t\t\tvolume: -6 - count * 1.1,\n\t\t\t\t\ttype: this._type as NonCustomOscillatorType,\n\t\t\t\t\tphase: this._phase + (i / count) * 360,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tonstop: i === 0 ? () => this.onstop(this) : noOp,\n\t\t\t\t});\n\t\t\t\tif (this.type === \"custom\") {\n\t\t\t\t\tosc.partials = this._partials;\n\t\t\t\t}\n\t\t\t\tthis.frequency.connect(osc.frequency);\n\t\t\t\tthis.detune.connect(osc.detune);\n\t\t\t\tosc.detune.overridden = false;\n\t\t\t\tosc.connect(this.output);\n\t\t\t\tthis._oscillators[i] = osc;\n\t\t\t}\n\t\t\t// set the spread\n\t\t\tthis.spread = this._spread;\n\t\t\tif (this.state === \"started\") {\n\t\t\t\tthis._forEach(osc => osc.start());\n\t\t\t}\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._phase = phase;\n\t\tthis._forEach((osc, i) => osc.phase = this._phase + (i / this.count) * 360);\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._oscillators[0].baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._forEach(osc => osc.baseType = baseType);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._oscillators[0].partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis._type = \"custom\";\n\t\t\tthis._forEach(osc => osc.partials = partials);\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._oscillators[0].partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._partialCount = partialCount;\n\t\tthis._forEach(osc => osc.partialCount = partialCount);\n\t\tthis._type = this._oscillators[0].type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\tthis._forEach(osc => osc.dispose());\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
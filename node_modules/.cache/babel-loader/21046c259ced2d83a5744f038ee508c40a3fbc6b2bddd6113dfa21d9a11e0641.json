{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Tone } from \"../Tone\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport var Timeline = /*#__PURE__*/function (_Tone) {\n  _inherits(Timeline, _Tone);\n  var _super = _createSuper(Timeline);\n  function Timeline() {\n    var _this;\n    _classCallCheck(this, Timeline);\n    _this = _super.call(this);\n    _this.name = \"Timeline\";\n    /**\n     * The array of scheduled timeline events\n     */\n    _this._timeline = [];\n    var options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n    _this.memory = options.memory;\n    _this.increasing = options.increasing;\n    return _this;\n  }\n  _createClass(Timeline, [{\n    key: \"length\",\n    get:\n    /**\n     * The number of items in the timeline.\n     */\n    function get() {\n      return this._timeline.length;\n    }\n    /**\n     * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n     * @param event  The event object to insert into the timeline.\n     */\n  }, {\n    key: \"add\",\n    value: function add(event) {\n      // the event needs to have a time attribute\n      assert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n      event.time = event.time.valueOf();\n      if (this.increasing && this.length) {\n        var lastValue = this._timeline[this.length - 1];\n        assert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n        this._timeline.push(event);\n      } else {\n        var index = this._search(event.time);\n        this._timeline.splice(index + 1, 0, event);\n      }\n      // if the length is more than the memory, remove the previous ones\n      if (this.length > this.memory) {\n        var diff = this.length - this.memory;\n        this._timeline.splice(0, diff);\n      }\n      return this;\n    }\n    /**\n     * Remove an event from the timeline.\n     * @param  {Object}  event  The event object to remove from the list.\n     * @returns {Timeline} this\n     */\n  }, {\n    key: \"remove\",\n    value: function remove(event) {\n      var index = this._timeline.indexOf(event);\n      if (index !== -1) {\n        this._timeline.splice(index, 1);\n      }\n      return this;\n    }\n    /**\n     * Get the nearest event whose time is less than or equal to the given time.\n     * @param  time  The time to query.\n     */\n  }, {\n    key: \"get\",\n    value: function get(time) {\n      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n      var index = this._search(time, param);\n      if (index !== -1) {\n        return this._timeline[index];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Return the first event in the timeline without removing it\n     * @returns {Object} The first event object\n     */\n  }, {\n    key: \"peek\",\n    value: function peek() {\n      return this._timeline[0];\n    }\n    /**\n     * Return the first event in the timeline and remove it\n     */\n  }, {\n    key: \"shift\",\n    value: function shift() {\n      return this._timeline.shift();\n    }\n    /**\n     * Get the event which is scheduled after the given time.\n     * @param  time  The time to query.\n     */\n  }, {\n    key: \"getAfter\",\n    value: function getAfter(time) {\n      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n      var index = this._search(time, param);\n      if (index + 1 < this._timeline.length) {\n        return this._timeline[index + 1];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Get the event before the event at the given time.\n     * @param  time  The time to query.\n     */\n  }, {\n    key: \"getBefore\",\n    value: function getBefore(time) {\n      var len = this._timeline.length;\n      // if it's after the last item, return the last item\n      if (len > 0 && this._timeline[len - 1].time < time) {\n        return this._timeline[len - 1];\n      }\n      var index = this._search(time);\n      if (index - 1 >= 0) {\n        return this._timeline[index - 1];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Cancel events at and after the given time\n     * @param  after  The time to query.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      if (this._timeline.length > 1) {\n        var index = this._search(after);\n        if (index >= 0) {\n          if (EQ(this._timeline[index].time, after)) {\n            // get the first item with that time\n            for (var i = index; i >= 0; i--) {\n              if (EQ(this._timeline[i].time, after)) {\n                index = i;\n              } else {\n                break;\n              }\n            }\n            this._timeline = this._timeline.slice(0, index);\n          } else {\n            this._timeline = this._timeline.slice(0, index + 1);\n          }\n        } else {\n          this._timeline = [];\n        }\n      } else if (this._timeline.length === 1) {\n        // the first item's time\n        if (GTE(this._timeline[0].time, after)) {\n          this._timeline = [];\n        }\n      }\n      return this;\n    }\n    /**\n     * Cancel events before or equal to the given time.\n     * @param  time  The time to cancel before.\n     */\n  }, {\n    key: \"cancelBefore\",\n    value: function cancelBefore(time) {\n      var index = this._search(time);\n      if (index >= 0) {\n        this._timeline = this._timeline.slice(index + 1);\n      }\n      return this;\n    }\n    /**\n     * Returns the previous event if there is one. null otherwise\n     * @param  event The event to find the previous one of\n     * @return The event right before the given event\n     */\n  }, {\n    key: \"previousEvent\",\n    value: function previousEvent(event) {\n      var index = this._timeline.indexOf(event);\n      if (index > 0) {\n        return this._timeline[index - 1];\n      } else {\n        return null;\n      }\n    }\n    /**\n     * Does a binary search on the timeline array and returns the\n     * nearest event index whose time is after or equal to the given time.\n     * If a time is searched before the first index in the timeline, -1 is returned.\n     * If the time is after the end, the index of the last item is returned.\n     */\n  }, {\n    key: \"_search\",\n    value: function _search(time) {\n      var param = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : \"time\";\n      if (this._timeline.length === 0) {\n        return -1;\n      }\n      var beginning = 0;\n      var len = this._timeline.length;\n      var end = len;\n      if (len > 0 && this._timeline[len - 1][param] <= time) {\n        return len - 1;\n      }\n      while (beginning < end) {\n        // calculate the midpoint for roughly equal partition\n        var midPoint = Math.floor(beginning + (end - beginning) / 2);\n        var event = this._timeline[midPoint];\n        var nextEvent = this._timeline[midPoint + 1];\n        if (EQ(event[param], time)) {\n          // choose the last one that has the same time\n          for (var i = midPoint; i < this._timeline.length; i++) {\n            var testEvent = this._timeline[i];\n            if (EQ(testEvent[param], time)) {\n              midPoint = i;\n            } else {\n              break;\n            }\n          }\n          return midPoint;\n        } else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n          return midPoint;\n        } else if (GT(event[param], time)) {\n          // search lower\n          end = midPoint;\n        } else {\n          // search upper\n          beginning = midPoint + 1;\n        }\n      }\n      return -1;\n    }\n    /**\n     * Internal iterator. Applies extra safety checks for\n     * removing items from the array.\n     */\n  }, {\n    key: \"_iterate\",\n    value: function _iterate(callback) {\n      var lowerBound = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var upperBound = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : this._timeline.length - 1;\n      this._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n    }\n    /**\n     * Iterate over everything in the array\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEach\",\n    value: function forEach(callback) {\n      this._iterate(callback);\n      return this;\n    }\n    /**\n     * Iterate over everything in the array at or before the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachBefore\",\n    value: function forEachBefore(time, callback) {\n      // iterate over the items in reverse so that removing an item doesn't break things\n      var upperBound = this._search(time);\n      if (upperBound !== -1) {\n        this._iterate(callback, 0, upperBound);\n      }\n      return this;\n    }\n    /**\n     * Iterate over everything in the array after the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachAfter\",\n    value: function forEachAfter(time, callback) {\n      // iterate over the items in reverse so that removing an item doesn't break things\n      var lowerBound = this._search(time);\n      this._iterate(callback, lowerBound + 1);\n      return this;\n    }\n    /**\n     * Iterate over everything in the array between the startTime and endTime.\n     * The timerange is inclusive of the startTime, but exclusive of the endTime.\n     * range = [startTime, endTime).\n     * @param  startTime The time to check if items are before\n     * @param  endTime The end of the test interval.\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachBetween\",\n    value: function forEachBetween(startTime, endTime, callback) {\n      var lowerBound = this._search(startTime);\n      var upperBound = this._search(endTime);\n      if (lowerBound !== -1 && upperBound !== -1) {\n        if (this._timeline[lowerBound].time !== startTime) {\n          lowerBound += 1;\n        }\n        // exclusive of the end time\n        if (this._timeline[upperBound].time === endTime) {\n          upperBound -= 1;\n        }\n        this._iterate(callback, lowerBound, upperBound);\n      } else if (lowerBound === -1) {\n        this._iterate(callback, 0, upperBound);\n      }\n      return this;\n    }\n    /**\n     * Iterate over everything in the array at or after the given time. Similar to\n     * forEachAfter, but includes the item(s) at the given time.\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachFrom\",\n    value: function forEachFrom(time, callback) {\n      // iterate over the items in reverse so that removing an item doesn't break things\n      var lowerBound = this._search(time);\n      // work backwards until the event time is less than time\n      while (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n        lowerBound--;\n      }\n      this._iterate(callback, lowerBound + 1);\n      return this;\n    }\n    /**\n     * Iterate over everything in the array at the given time\n     * @param  time The time to check if items are before\n     * @param  callback The callback to invoke with every item\n     */\n  }, {\n    key: \"forEachAtTime\",\n    value: function forEachAtTime(time, callback) {\n      // iterate over the items in reverse so that removing an item doesn't break things\n      var upperBound = this._search(time);\n      if (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n        var lowerBound = upperBound;\n        for (var i = upperBound; i >= 0; i--) {\n          if (EQ(this._timeline[i].time, time)) {\n            lowerBound = i;\n          } else {\n            break;\n          }\n        }\n        this._iterate(function (event) {\n          callback(event);\n        }, lowerBound, upperBound);\n      }\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Timeline.prototype), \"dispose\", this).call(this);\n      this._timeline = [];\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        memory: Infinity,\n        increasing: false\n      };\n    }\n  }]);\n  return Timeline;\n}(Tone);","map":{"version":3,"mappings":"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","names":["Tone","optionsFromArguments","assert","EQ","GT","GTE","LT","Timeline","options","getDefaults","arguments","memory","increasing","_timeline","length","event","Reflect","has","time","valueOf","lastValue","push","index","_search","splice","diff","indexOf","param","shift","len","after","i","slice","beginning","end","midPoint","Math","floor","nextEvent","testEvent","callback","lowerBound","upperBound","forEach","_iterate","startTime","endTime","Infinity"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\util\\Timeline.ts"],"sourcesContent":["import { Tone } from \"../Tone\";\nimport { Seconds } from \"../type/Units\";\nimport { optionsFromArguments } from \"./Defaults\";\nimport { assert } from \"./Debug\";\nimport { EQ, GT, GTE, LT } from \"./Math\";\n\ntype TimelineSearchParam = \"ticks\" | \"time\";\n\n/**\n * The options object for Timeline\n */\ninterface TimelineOptions {\n\tmemory: number;\n\tincreasing: boolean;\n}\n\n/**\n * An event must have a time number\n */\nexport interface TimelineEvent {\n\ttime: number;\n}\n\n/**\n * A Timeline class for scheduling and maintaining state\n * along a timeline. All events must have a \"time\" property.\n * Internally, events are stored in time order for fast\n * retrieval.\n */\nexport class Timeline<GenericEvent extends TimelineEvent> extends Tone {\n\n\treadonly name: string = \"Timeline\";\n\n\t/**\n\t * The memory of the timeline, i.e.\n\t * how many events in the past it will retain\n\t */\n\tmemory: number;\n\n\t/**\n\t * The array of scheduled timeline events\n\t */\n\tprotected _timeline: GenericEvent[] = [];\n\n\t/**\n\t * If the time value must always be greater than or equal to the last \n\t * element on the list. \n\t */\n\tincreasing: boolean;\n\n\t/**\n\t * @param memory The number of previous events that are retained.\n\t */\n\tconstructor(memory?: number);\n\tconstructor(options?: Partial<TimelineOptions>);\n\tconstructor() {\n\t\tsuper();\n\t\tconst options = optionsFromArguments(Timeline.getDefaults(), arguments, [\"memory\"]);\n\n\t\tthis.memory = options.memory;\n\t\tthis.increasing = options.increasing;\n\t}\n\n\tstatic getDefaults(): TimelineOptions {\n\t\treturn {\n\t\t\tmemory: Infinity,\n\t\t\tincreasing: false,\n\t\t};\n\t}\n\n\t/**\n\t * The number of items in the timeline.\n\t */\n\tget length(): number {\n\t\treturn this._timeline.length;\n\t}\n\n\t/**\n\t * Insert an event object onto the timeline. Events must have a \"time\" attribute.\n\t * @param event  The event object to insert into the timeline.\n\t */\n\tadd(event: GenericEvent): this {\n\t\t// the event needs to have a time attribute\n\t\tassert(Reflect.has(event, \"time\"), \"Timeline: events must have a time attribute\");\n\t\tevent.time = event.time.valueOf();\n\t\tif (this.increasing && this.length) {\n\t\t\tconst lastValue = this._timeline[this.length - 1] as GenericEvent;\n\t\t\tassert(GTE(event.time, lastValue.time), \"The time must be greater than or equal to the last scheduled time\");\n\t\t\tthis._timeline.push(event);\n\t\t} else {\n\t\t\tconst index = this._search(event.time);\n\t\t\tthis._timeline.splice(index + 1, 0, event);\n\t\t}\n\t\t// if the length is more than the memory, remove the previous ones\n\t\tif (this.length > this.memory) {\n\t\t\tconst diff = this.length - this.memory;\n\t\t\tthis._timeline.splice(0, diff);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove an event from the timeline.\n\t * @param  {Object}  event  The event object to remove from the list.\n\t * @returns {Timeline} this\n\t */\n\tremove(event: GenericEvent): this {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index !== -1) {\n\t\t\tthis._timeline.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the nearest event whose time is less than or equal to the given time.\n\t * @param  time  The time to query.\n\t */\n\tget(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index !== -1) {\n\t\t\treturn this._timeline[index];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Return the first event in the timeline without removing it\n\t * @returns {Object} The first event object\n\t */\n\tpeek(): GenericEvent | undefined {\n\t\treturn this._timeline[0];\n\t}\n\n\t/**\n\t * Return the first event in the timeline and remove it\n\t */\n\tshift(): GenericEvent | undefined {\n\t\treturn this._timeline.shift();\n\t}\n\n\t/**\n\t * Get the event which is scheduled after the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetAfter(time: number, param: TimelineSearchParam = \"time\"): GenericEvent | null {\n\t\tconst index = this._search(time, param);\n\t\tif (index + 1 < this._timeline.length) {\n\t\t\treturn this._timeline[index + 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Get the event before the event at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetBefore(time: number): GenericEvent | null {\n\t\tconst len = this._timeline.length;\n\t\t// if it's after the last item, return the last item\n\t\tif (len > 0 && this._timeline[len - 1].time < time) {\n\t\t\treturn this._timeline[len - 1];\n\t\t}\n\t\tconst index = this._search(time);\n\t\tif (index - 1 >= 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Cancel events at and after the given time\n\t * @param  after  The time to query.\n\t */\n\tcancel(after: number): this {\n\t\tif (this._timeline.length > 1) {\n\t\t\tlet index = this._search(after);\n\t\t\tif (index >= 0) {\n\t\t\t\tif (EQ(this._timeline[index].time, after)) {\n\t\t\t\t\t// get the first item with that time\n\t\t\t\t\tfor (let i = index; i >= 0; i--) {\n\t\t\t\t\t\tif (EQ(this._timeline[i].time, after)) {\n\t\t\t\t\t\t\tindex = i;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tbreak;\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index);\n\t\t\t\t} else {\n\t\t\t\t\tthis._timeline = this._timeline.slice(0, index + 1);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t} else if (this._timeline.length === 1) {\n\t\t\t// the first item's time\n\t\t\tif (GTE(this._timeline[0].time, after)) {\n\t\t\t\tthis._timeline = [];\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events before or equal to the given time.\n\t * @param  time  The time to cancel before.\n\t */\n\tcancelBefore(time: number): this {\n\t\tconst index = this._search(time);\n\t\tif (index >= 0) {\n\t\t\tthis._timeline = this._timeline.slice(index + 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the previous event if there is one. null otherwise\n\t * @param  event The event to find the previous one of\n\t * @return The event right before the given event\n\t */\n\tpreviousEvent(event: GenericEvent): GenericEvent | null {\n\t\tconst index = this._timeline.indexOf(event);\n\t\tif (index > 0) {\n\t\t\treturn this._timeline[index - 1];\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Does a binary search on the timeline array and returns the\n\t * nearest event index whose time is after or equal to the given time.\n\t * If a time is searched before the first index in the timeline, -1 is returned.\n\t * If the time is after the end, the index of the last item is returned.\n\t */\n\tprotected _search(time: number, param: TimelineSearchParam = \"time\"): number {\n\t\tif (this._timeline.length === 0) {\n\t\t\treturn -1;\n\t\t}\n\t\tlet beginning = 0;\n\t\tconst len = this._timeline.length;\n\t\tlet end = len;\n\t\tif (len > 0 && this._timeline[len - 1][param] <= time) {\n\t\t\treturn len - 1;\n\t\t}\n\t\twhile (beginning < end) {\n\t\t\t// calculate the midpoint for roughly equal partition\n\t\t\tlet midPoint = Math.floor(beginning + (end - beginning) / 2);\n\t\t\tconst event = this._timeline[midPoint];\n\t\t\tconst nextEvent = this._timeline[midPoint + 1];\n\t\t\tif (EQ(event[param], time)) {\n\t\t\t\t// choose the last one that has the same time\n\t\t\t\tfor (let i = midPoint; i < this._timeline.length; i++) {\n\t\t\t\t\tconst testEvent = this._timeline[i];\n\t\t\t\t\tif (EQ(testEvent[param], time)) {\n\t\t\t\t\t\tmidPoint = i;\n\t\t\t\t\t} else {\n\t\t\t\t\t\tbreak;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn midPoint;\n\t\t\t} else if (LT(event[param], time) && GT(nextEvent[param], time)) {\n\t\t\t\treturn midPoint;\n\t\t\t} else if (GT(event[param], time)) {\n\t\t\t\t// search lower\n\t\t\t\tend = midPoint;\n\t\t\t} else {\n\t\t\t\t// search upper\n\t\t\t\tbeginning = midPoint + 1;\n\t\t\t}\n\t\t}\n\t\treturn -1;\n\t}\n\n\t/**\n\t * Internal iterator. Applies extra safety checks for\n\t * removing items from the array.\n\t */\n\tprivate _iterate(\n\t\tcallback: (event: GenericEvent) => void,\n\t\tlowerBound = 0, upperBound = this._timeline.length - 1,\n\t): void {\n\t\tthis._timeline.slice(lowerBound, upperBound + 1).forEach(callback);\n\t}\n\n\t/**\n\t * Iterate over everything in the array\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEach(callback: (event: GenericEvent) => void): this {\n\t\tthis._iterate(callback);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or before the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBefore(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array after the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAfter(time: Seconds, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst lowerBound = this._search(time);\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array between the startTime and endTime.\n\t * The timerange is inclusive of the startTime, but exclusive of the endTime.\n\t * range = [startTime, endTime).\n\t * @param  startTime The time to check if items are before\n\t * @param  endTime The end of the test interval.\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachBetween(startTime: number, endTime: number, callback: (event: GenericEvent) => void): this {\n\t\tlet lowerBound = this._search(startTime);\n\t\tlet upperBound = this._search(endTime);\n\t\tif (lowerBound !== -1 && upperBound !== -1) {\n\t\t\tif (this._timeline[lowerBound].time !== startTime) {\n\t\t\t\tlowerBound += 1;\n\t\t\t}\n\t\t\t// exclusive of the end time\n\t\t\tif (this._timeline[upperBound].time === endTime) {\n\t\t\t\tupperBound -= 1;\n\t\t\t}\n\t\t\tthis._iterate(callback, lowerBound, upperBound);\n\t\t} else if (lowerBound === -1) {\n\t\t\tthis._iterate(callback, 0, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at or after the given time. Similar to\n\t * forEachAfter, but includes the item(s) at the given time.\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachFrom(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tlet lowerBound = this._search(time);\n\t\t// work backwards until the event time is less than time\n\t\twhile (lowerBound >= 0 && this._timeline[lowerBound].time >= time) {\n\t\t\tlowerBound--;\n\t\t}\n\t\tthis._iterate(callback, lowerBound + 1);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over everything in the array at the given time\n\t * @param  time The time to check if items are before\n\t * @param  callback The callback to invoke with every item\n\t */\n\tforEachAtTime(time: number, callback: (event: GenericEvent) => void): this {\n\t\t// iterate over the items in reverse so that removing an item doesn't break things\n\t\tconst upperBound = this._search(time);\n\t\tif (upperBound !== -1 && EQ(this._timeline[upperBound].time, time)) {\n\t\t\tlet lowerBound = upperBound;\n\t\t\tfor (let i = upperBound; i >= 0; i--) {\n\t\t\t\tif (EQ(this._timeline[i].time, time)) {\n\t\t\t\t\tlowerBound = i;\n\t\t\t\t} else {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._iterate(event => {\n\t\t\t\tcallback(event);\n\t\t\t}, lowerBound, upperBound);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._timeline = [];\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport { generateWaveform } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport var FMOscillator = /*#__PURE__*/function (_Source) {\n  _inherits(FMOscillator, _Source);\n  var _super = _createSuper(FMOscillator);\n  function FMOscillator() {\n    var _this;\n    _classCallCheck(this, FMOscillator);\n    _this = _super.call(this, optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n    _this.name = \"FMOscillator\";\n    /**\n     * the node where the modulation happens\n     */\n    _this._modulationNode = new Gain({\n      context: _this.context,\n      gain: 0\n    });\n    var options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n    _this._carrier = new Oscillator({\n      context: _this.context,\n      detune: options.detune,\n      frequency: 0,\n      onstop: function onstop() {\n        return _this.onstop(_assertThisInitialized(_this));\n      },\n      phase: options.phase,\n      type: options.type\n    });\n    _this.detune = _this._carrier.detune;\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    _this._modulator = new Oscillator({\n      context: _this.context,\n      phase: options.phase,\n      type: options.modulationType\n    });\n    _this.harmonicity = new Multiply({\n      context: _this.context,\n      units: \"positive\",\n      value: options.harmonicity\n    });\n    _this.modulationIndex = new Multiply({\n      context: _this.context,\n      units: \"positive\",\n      value: options.modulationIndex\n    });\n    // connections\n    _this.frequency.connect(_this._carrier.frequency);\n    _this.frequency.chain(_this.harmonicity, _this._modulator.frequency);\n    _this.frequency.chain(_this.modulationIndex, _this._modulationNode);\n    _this._modulator.connect(_this._modulationNode.gain);\n    _this._modulationNode.connect(_this._carrier.frequency);\n    _this._carrier.connect(_this.output);\n    _this.detune.connect(_this._modulator.detune);\n    readOnly(_assertThisInitialized(_this), [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n    return _this;\n  }\n  _createClass(FMOscillator, [{\n    key: \"_start\",\n    value:\n    /**\n     * start the oscillator\n     */\n    function _start(time) {\n      this._modulator.start(time);\n      this._carrier.start(time);\n    }\n    /**\n     * stop the oscillator\n     */\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      this._modulator.stop(time);\n      this._carrier.stop(time);\n    }\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      this._modulator.restart(time);\n      this._carrier.restart(time);\n      return this;\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._carrier.type;\n    },\n    set: function set(type) {\n      this._carrier.type = type;\n    }\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._carrier.baseType;\n    },\n    set: function set(baseType) {\n      this._carrier.baseType = baseType;\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._carrier.partialCount;\n    },\n    set: function set(partialCount) {\n      this._carrier.partialCount = partialCount;\n    }\n    /**\n     * The type of the modulator oscillator\n     */\n  }, {\n    key: \"modulationType\",\n    get: function get() {\n      return this._modulator.type;\n    },\n    set: function set(type) {\n      this._modulator.type = type;\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._carrier.phase;\n    },\n    set: function set(phase) {\n      this._carrier.phase = phase;\n      this._modulator.phase = phase;\n    }\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._carrier.partials;\n    },\n    set: function set(partials) {\n      this._carrier.partials = partials;\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", generateWaveform(this, length));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(FMOscillator.prototype), \"dispose\", this).call(this);\n      this.frequency.dispose();\n      this.harmonicity.dispose();\n      this._carrier.dispose();\n      this._modulator.dispose();\n      this._modulationNode.dispose();\n      this.modulationIndex.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Oscillator.getDefaults(), {\n        harmonicity: 1,\n        modulationIndex: 2,\n        modulationType: \"square\"\n      });\n    }\n  }]);\n  return FMOscillator;\n}(Source);","map":{"version":3,"mappings":"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","names":["Gain","optionsFromArguments","readOnly","Multiply","Signal","Source","Oscillator","generateWaveform","FMOscillator","getDefaults","arguments","context","gain","options","_carrier","detune","frequency","onstop","phase","type","units","value","_modulator","modulationType","harmonicity","modulationIndex","connect","chain","_modulationNode","output","time","start","stop","restart","baseType","partialCount","partials","length","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\oscillator\\FMOscillator.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Degrees, Frequency, Seconds, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { Multiply } from \"../../signal/Multiply\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { Oscillator } from \"./Oscillator\";\nimport {\n\tFMConstructorOptions, FMOscillatorOptions,\n\tgenerateWaveform, NonCustomOscillatorType, ToneOscillatorInterface, ToneOscillatorType\n} from \"./OscillatorInterface\";\n\nexport { FMOscillatorOptions } from \"./OscillatorInterface\";\n/**\n * FMOscillator implements a frequency modulation synthesis\n * ```\n *                                              +-------------+\n * +---------------+        +-------------+     | Carrier Osc |\n * | Modulator Osc +>-------> GainNode    |     |             +--->Output\n * +---------------+        |             +>----> frequency   |\n *                       +--> gain        |     +-------------+\n *                       |  +-------------+\n * +-----------------+   |\n * | modulationIndex +>--+\n * +-----------------+\n * ```\n *\n * @example\n * return Tone.Offline(() => {\n * \tconst fmOsc = new Tone.FMOscillator({\n * \t\tfrequency: 200,\n * \t\ttype: \"square\",\n * \t\tmodulationType: \"triangle\",\n * \t\tharmonicity: 0.2,\n * \t\tmodulationIndex: 3\n * \t}).toDestination().start();\n * }, 0.1, 1);\n * @category Source\n */\nexport class FMOscillator extends Source<FMOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"FMOscillator\";\n\n\t/**\n\t * The carrier oscillator\n\t */\n\tprivate _carrier: Oscillator;\n\n\treadonly frequency: Signal<\"frequency\">;\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The modulating oscillator\n\t */\n\tprivate _modulator: Oscillator;\n\n\t/**\n\t * Harmonicity is the frequency ratio between the carrier and the modulator oscillators.\n\t * A harmonicity of 1 gives both oscillators the same frequency.\n\t * Harmonicity = 2 means a change of an octave.\n\t * @example\n\t * const fmOsc = new Tone.FMOscillator(\"D2\").toDestination().start();\n\t * // pitch the modulator an octave below carrier\n\t * fmOsc.harmonicity.value = 0.5;\n\t */\n\treadonly harmonicity: Signal<\"positive\">;\n\n\t/**\n\t * The modulation index which is in essence the depth or amount of the modulation. In other terms it is the\n\t * ratio of the frequency of the modulating signal (mf) to the amplitude of the\n\t * modulating signal (ma) -- as in ma/mf.\n\t */\n\treadonly modulationIndex: Signal<\"positive\">;\n\n\t/**\n\t * the node where the modulation happens\n\t */\n\tprivate _modulationNode: Gain = new Gain({\n\t\tcontext: this.context,\n\t\tgain: 0,\n\t});\n\n\t/**\n\t * @param frequency The starting frequency of the oscillator.\n\t * @param type The type of the carrier oscillator.\n\t * @param modulationType The type of the modulator oscillator.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType, modulationType?: ToneOscillatorType);\n\tconstructor(options?: Partial<FMConstructorOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]));\n\t\tconst options = optionsFromArguments(FMOscillator.getDefaults(), arguments, [\"frequency\", \"type\", \"modulationType\"]);\n\n\t\tthis._carrier = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tfrequency: 0,\n\t\t\tonstop: () => this.onstop(this),\n\t\t\tphase: options.phase,\n\t\t\ttype: options.type,\n\t\t} as OscillatorOptions);\n\n\t\tthis.detune = this._carrier.detune;\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\n\t\tthis._modulator = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: options.phase,\n\t\t\ttype: options.modulationType,\n\t\t} as OscillatorOptions);\n\n\t\tthis.harmonicity = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.harmonicity,\n\t\t});\n\n\t\tthis.modulationIndex = new Multiply({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"positive\",\n\t\t\tvalue: options.modulationIndex,\n\t\t});\n\n\t\t// connections\n\t\tthis.frequency.connect(this._carrier.frequency);\n\t\tthis.frequency.chain(this.harmonicity, this._modulator.frequency);\n\t\tthis.frequency.chain(this.modulationIndex, this._modulationNode);\n\t\tthis._modulator.connect(this._modulationNode.gain);\n\t\tthis._modulationNode.connect(this._carrier.frequency);\n\t\tthis._carrier.connect(this.output);\n\t\tthis.detune.connect(this._modulator.detune);\n\n\t\treadOnly(this, [\"modulationIndex\", \"frequency\", \"detune\", \"harmonicity\"]);\n\t}\n\n\tstatic getDefaults(): FMOscillatorOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tharmonicity: 1,\n\t\t\tmodulationIndex: 2,\n\t\t\tmodulationType: \"square\" as NonCustomOscillatorType,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time: Time): void {\n\t\tthis._modulator.start(time);\n\t\tthis._carrier.start(time);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time: Time): void {\n\t\tthis._modulator.stop(time);\n\t\tthis._carrier.stop(time);\n\t}\n\n\tprotected _restart(time: Seconds): this {\n\t\tthis._modulator.restart(time);\n\t\tthis._carrier.restart(time);\n\t\treturn this;\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._carrier.type;\n\t}\n\tset type(type: ToneOscillatorType) {\n\t\tthis._carrier.type = type;\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn this._carrier.baseType;\n\t}\n\tset baseType(baseType: OscillatorType) {\n\t\tthis._carrier.baseType = baseType;\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._carrier.partialCount;\n\t}\n\tset partialCount(partialCount: number) {\n\t\tthis._carrier.partialCount = partialCount;\n\t}\n\n\t/**\n\t * The type of the modulator oscillator\n\t */\n\tget modulationType(): ToneOscillatorType {\n\t\treturn this._modulator.type;\n\t}\n\tset modulationType(type: ToneOscillatorType) {\n\t\tthis._modulator.type = type;\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._carrier.phase;\n\t}\n\tset phase(phase: Degrees) {\n\t\tthis._carrier.phase = phase;\n\t\tthis._modulator.phase = phase;\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._carrier.partials;\n\t}\n\tset partials(partials: number[]) {\n\t\tthis._carrier.partials = partials;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis.harmonicity.dispose();\n\t\tthis._carrier.dispose();\n\t\tthis._modulator.dispose();\n\t\tthis._modulationNode.dispose();\n\t\tthis.modulationIndex.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect } from \"./Effect\";\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport var Distortion = /*#__PURE__*/function (_Effect) {\n  _inherits(Distortion, _Effect);\n  var _super = _createSuper(Distortion);\n  function Distortion() {\n    var _this;\n    _classCallCheck(this, Distortion);\n    _this = _super.call(this, optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n    _this.name = \"Distortion\";\n    var options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n    _this._shaper = new WaveShaper({\n      context: _this.context,\n      length: 4096\n    });\n    _this._distortion = options.distortion;\n    _this.connectEffect(_this._shaper);\n    _this.distortion = options.distortion;\n    _this.oversample = options.oversample;\n    return _this;\n  }\n  _createClass(Distortion, [{\n    key: \"distortion\",\n    get:\n    /**\n     * The amount of distortion. Nominal range is between 0 and 1.\n     */\n    function get() {\n      return this._distortion;\n    },\n    set: function set(amount) {\n      this._distortion = amount;\n      var k = amount * 100;\n      var deg = Math.PI / 180;\n      this._shaper.setMap(function (x) {\n        if (Math.abs(x) < 0.001) {\n          // should output 0 when input is 0\n          return 0;\n        } else {\n          return (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n        }\n      });\n    }\n    /**\n     * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n     */\n  }, {\n    key: \"oversample\",\n    get: function get() {\n      return this._shaper.oversample;\n    },\n    set: function set(oversampling) {\n      this._shaper.oversample = oversampling;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Distortion.prototype), \"dispose\", this).call(this);\n      this._shaper.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Effect.getDefaults(), {\n        distortion: 0.4,\n        oversample: \"none\"\n      });\n    }\n  }]);\n  return Distortion;\n}(Effect);","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,UAAU,QAAQ,sBAAsB;AACjD,SAASC,MAAM,QAAuB,UAAU;AAOhD;;;;;;;;;;AAUA,WAAaC,UAAW;EAAA;EAAA;EAmBvB;IAAA;IAAA;IAEC,0BAAMH,oBAAoB,CAACG,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,YAAY,CAAC,CAAC;IAnBvE,UAAI,GAAW,YAAY;IAoBnC,IAAMC,OAAO,GAAGN,oBAAoB,CAACG,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,YAAY,CAAC,CAAC;IAEzF,MAAKE,OAAO,GAAG,IAAIN,UAAU,CAAC;MAC7BO,OAAO,EAAE,MAAKA,OAAO;MACrBC,MAAM,EAAE;KACR,CAAC;IAEF,MAAKC,WAAW,GAAGJ,OAAO,CAACK,UAAU;IAErC,MAAKC,aAAa,CAAC,MAAKL,OAAO,CAAC;IAChC,MAAKI,UAAU,GAAGL,OAAO,CAACK,UAAU;IACpC,MAAKE,UAAU,GAAGP,OAAO,CAACO,UAAU;IAAC;EACtC;EAAC;IAAA;IAAA;IASD;;;IAGA,eAAc;MACb,OAAO,IAAI,CAACH,WAAW;IACxB,CAAC;IAAA,KACD,aAAeI,MAAM;MACpB,IAAI,CAACJ,WAAW,GAAGI,MAAM;MACzB,IAAMC,CAAC,GAAGD,MAAM,GAAG,GAAG;MACtB,IAAME,GAAG,GAAGC,IAAI,CAACC,EAAE,GAAG,GAAG;MACzB,IAAI,CAACX,OAAO,CAACY,MAAM,CAAC,UAACC,CAAC,EAAI;QACzB,IAAIH,IAAI,CAACI,GAAG,CAACD,CAAC,CAAC,GAAG,KAAK,EAAE;UACxB;UACA,OAAO,CAAC;SACR,MAAM;UACN,OAAO,CAAC,CAAC,GAAGL,CAAC,IAAIK,CAAC,GAAG,EAAE,GAAGJ,GAAG,IAAIC,IAAI,CAACC,EAAE,GAAGH,CAAC,GAAGE,IAAI,CAACI,GAAG,CAACD,CAAC,CAAC,CAAC;;MAE7D,CAAC,CAAC;IACH;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAc;MACb,OAAO,IAAI,CAACb,OAAO,CAACM,UAAU;IAC/B,CAAC;IAAA,KACD,aAAeS,YAAY;MAC1B,IAAI,CAACf,OAAO,CAACM,UAAU,GAAGS,YAAY;IACvC;EAAC;IAAA;IAAA,OAED,mBAAO;MACN;MACA,IAAI,CAACf,OAAO,CAACgB,OAAO,EAAE;MACtB,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAzCD,uBAAkB;MACjB,OAAOC,MAAM,CAACC,MAAM,CAACvB,MAAM,CAACE,WAAW,EAAE,EAAE;QAC1CO,UAAU,EAAE,GAAG;QACfE,UAAU,EAAE;OACZ,CAAC;IACH;EAAC;EAAA;AAAA,EAzC8BX,MAAyB","names":["optionsFromArguments","WaveShaper","Effect","Distortion","getDefaults","arguments","options","_shaper","context","length","_distortion","distortion","connectEffect","oversample","amount","k","deg","Math","PI","setMap","x","abs","oversampling","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\effect\\Distortion.ts"],"sourcesContent":["import { optionsFromArguments } from \"../core/util/Defaults\";\nimport { WaveShaper } from \"../signal/WaveShaper\";\nimport { Effect, EffectOptions } from \"./Effect\";\n\nexport interface DistortionOptions extends EffectOptions {\n\tdistortion: number;\n\toversample: OverSampleType;\n}\n\n/**\n * A simple distortion effect using Tone.WaveShaper.\n * Algorithm from [this stackoverflow answer](http://stackoverflow.com/a/22313408).\n *\n * @example\n * const dist = new Tone.Distortion(0.8).toDestination();\n * const fm = new Tone.FMSynth().connect(dist);\n * fm.triggerAttackRelease(\"A1\", \"8n\");\n * @category Effect\n */\nexport class Distortion extends Effect<DistortionOptions> {\n\n\treadonly name: string = \"Distortion\";\n\n\t/**\n\t * The waveshaper which does the distortion\n\t */\n\tprivate _shaper: WaveShaper;\n\n\t/**\n\t * Stores the distortion value\n\t */\n\tprivate _distortion: number;\n\n\t/**\n\t * @param distortion The amount of distortion (nominal range of 0-1)\n\t */\n\tconstructor(distortion?: number);\n\tconstructor(options?: Partial<DistortionOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]));\n\t\tconst options = optionsFromArguments(Distortion.getDefaults(), arguments, [\"distortion\"]);\n\n\t\tthis._shaper = new WaveShaper({\n\t\t\tcontext: this.context,\n\t\t\tlength: 4096,\n\t\t});\n\n\t\tthis._distortion = options.distortion;\n\n\t\tthis.connectEffect(this._shaper);\n\t\tthis.distortion = options.distortion;\n\t\tthis.oversample = options.oversample;\n\t}\n\n\tstatic getDefaults(): DistortionOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tdistortion: 0.4,\n\t\t\toversample: \"none\" as OverSampleType,\n\t\t});\n\t}\n\n\t/**\n\t * The amount of distortion. Nominal range is between 0 and 1.\n\t */\n\tget distortion(): number {\n\t\treturn this._distortion;\n\t}\n\tset distortion(amount) {\n\t\tthis._distortion = amount;\n\t\tconst k = amount * 100;\n\t\tconst deg = Math.PI / 180;\n\t\tthis._shaper.setMap((x) => {\n\t\t\tif (Math.abs(x) < 0.001) {\n\t\t\t\t// should output 0 when input is 0\n\t\t\t\treturn 0;\n\t\t\t} else {\n\t\t\t\treturn (3 + k) * x * 20 * deg / (Math.PI + k * Math.abs(x));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * The oversampling of the effect. Can either be \"none\", \"2x\" or \"4x\".\n\t */\n\tget oversample(): OverSampleType {\n\t\treturn this._shaper.oversample;\n\t}\n\tset oversample(oversampling) {\n\t\tthis._shaper.oversample = oversampling;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._shaper.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
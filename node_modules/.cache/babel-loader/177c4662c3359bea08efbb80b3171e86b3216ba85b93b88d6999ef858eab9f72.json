{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Param } from \"../context/Param\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport var TickParam = /*#__PURE__*/function (_Param) {\n  _inherits(TickParam, _Param);\n  var _super = _createSuper(TickParam);\n  function TickParam() {\n    var _this;\n    _classCallCheck(this, TickParam);\n    _this = _super.call(this, optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n    _this.name = \"TickParam\";\n    /**\n     * The timeline which tracks all of the automations.\n     */\n    _this._events = new Timeline(Infinity);\n    /**\n     * The internal holder for the multiplier value\n     */\n    _this._multiplier = 1;\n    var options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n    // set the multiplier\n    _this._multiplier = options.multiplier;\n    // clear the ticks from the beginning\n    _this._events.cancel(0);\n    // set an initial event\n    _this._events.add({\n      ticks: 0,\n      time: 0,\n      type: \"setValueAtTime\",\n      value: _this._fromType(options.value)\n    });\n    _this.setValueAtTime(options.value, 0);\n    return _this;\n  }\n  _createClass(TickParam, [{\n    key: \"setTargetAtTime\",\n    value: function setTargetAtTime(value, time, constant) {\n      // approximate it with multiple linear ramps\n      time = this.toSeconds(time);\n      this.setRampPoint(time);\n      var computedValue = this._fromType(value);\n      // start from previously scheduled value\n      var prevEvent = this._events.get(time);\n      var segments = Math.round(Math.max(1 / constant, 1));\n      for (var i = 0; i <= segments; i++) {\n        var segTime = constant * i + time;\n        var rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n        this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n      }\n      return this;\n    }\n  }, {\n    key: \"setValueAtTime\",\n    value: function setValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n      _get(_getPrototypeOf(TickParam.prototype), \"setValueAtTime\", this).call(this, value, time);\n      var event = this._events.get(computedTime);\n      var previousEvent = this._events.previousEvent(event);\n      var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n      event.ticks = Math.max(ticksUntilTime, 0);\n      return this;\n    }\n  }, {\n    key: \"linearRampToValueAtTime\",\n    value: function linearRampToValueAtTime(value, time) {\n      var computedTime = this.toSeconds(time);\n      _get(_getPrototypeOf(TickParam.prototype), \"linearRampToValueAtTime\", this).call(this, value, time);\n      var event = this._events.get(computedTime);\n      var previousEvent = this._events.previousEvent(event);\n      var ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n      event.ticks = Math.max(ticksUntilTime, 0);\n      return this;\n    }\n  }, {\n    key: \"exponentialRampToValueAtTime\",\n    value: function exponentialRampToValueAtTime(value, time) {\n      // aproximate it with multiple linear ramps\n      time = this.toSeconds(time);\n      var computedVal = this._fromType(value);\n      // start from previously scheduled value\n      var prevEvent = this._events.get(time);\n      // approx 10 segments per second\n      var segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n      var segmentDur = (time - prevEvent.time) / segments;\n      for (var i = 0; i <= segments; i++) {\n        var segTime = segmentDur * i + prevEvent.time;\n        var rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n        this.linearRampToValueAtTime(this._toType(rampVal), segTime);\n      }\n      return this;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  event The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n  }, {\n    key: \"_getTicksUntilEvent\",\n    value: function _getTicksUntilEvent(event, time) {\n      if (event === null) {\n        event = {\n          ticks: 0,\n          time: 0,\n          type: \"setValueAtTime\",\n          value: 0\n        };\n      } else if (isUndef(event.ticks)) {\n        var previousEvent = this._events.previousEvent(event);\n        event.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n      }\n      var val0 = this._fromType(this.getValueAtTime(event.time));\n      var val1 = this._fromType(this.getValueAtTime(time));\n      // if it's right on the line, take the previous value\n      var onTheLineEvent = this._events.get(time);\n      if (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n        val1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n      }\n      return 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n    }\n    /**\n     * Returns the tick value at the time. Takes into account\n     * any automation curves scheduled on the signal.\n     * @param  time The time to get the tick count at\n     * @return The number of ticks which have elapsed at the time given any automations.\n     */\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var computedTime = this.toSeconds(time);\n      var event = this._events.get(computedTime);\n      return Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n    }\n    /**\n     * Return the elapsed time of the number of ticks from the given time\n     * @param ticks The number of ticks to calculate\n     * @param  time The time to get the next tick from\n     * @return The duration of the number of ticks from the given time in seconds\n     */\n  }, {\n    key: \"getDurationOfTicks\",\n    value: function getDurationOfTicks(ticks, time) {\n      var computedTime = this.toSeconds(time);\n      var currentTick = this.getTicksAtTime(time);\n      return this.getTimeOfTick(currentTick + ticks) - computedTime;\n    }\n    /**\n     * Given a tick, returns the time that tick occurs at.\n     * @return The time that the tick occurs.\n     */\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = this._events.get(tick, \"ticks\");\n      var after = this._events.getAfter(tick, \"ticks\");\n      if (before && before.ticks === tick) {\n        return before.time;\n      } else if (before && after && after.type === \"linearRampToValueAtTime\" && before.value !== after.value) {\n        var val0 = this._fromType(this.getValueAtTime(before.time));\n        var val1 = this._fromType(this.getValueAtTime(after.time));\n        var delta = (val1 - val0) / (after.time - before.time);\n        var k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n        var sol1 = (-val0 + k) / delta;\n        var sol2 = (-val0 - k) / delta;\n        return (sol1 > 0 ? sol1 : sol2) + before.time;\n      } else if (before) {\n        if (before.value === 0) {\n          return Infinity;\n        } else {\n          return before.time + (tick - before.ticks) / before.value;\n        }\n      } else {\n        return tick / this._initialValue;\n      }\n    }\n    /**\n     * Convert some number of ticks their the duration in seconds accounting\n     * for any automation curves starting at the given time.\n     * @param  ticks The number of ticks to convert to seconds.\n     * @param  when  When along the automation timeline to convert the ticks.\n     * @return The duration in seconds of the ticks.\n     */\n  }, {\n    key: \"ticksToTime\",\n    value: function ticksToTime(ticks, when) {\n      return this.getDurationOfTicks(ticks, when);\n    }\n    /**\n     * The inverse of [[ticksToTime]]. Convert a duration in\n     * seconds to the corresponding number of ticks accounting for any\n     * automation curves starting at the given time.\n     * @param  duration The time interval to convert to ticks.\n     * @param  when When along the automation timeline to convert the ticks.\n     * @return The duration in ticks.\n     */\n  }, {\n    key: \"timeToTicks\",\n    value: function timeToTicks(duration, when) {\n      var computedTime = this.toSeconds(when);\n      var computedDuration = this.toSeconds(duration);\n      var startTicks = this.getTicksAtTime(computedTime);\n      var endTicks = this.getTicksAtTime(computedTime + computedDuration);\n      return endTicks - startTicks;\n    }\n    /**\n     * Convert from the type when the unit value is BPM\n     */\n  }, {\n    key: \"_fromType\",\n    value: function _fromType(val) {\n      if (this.units === \"bpm\" && this.multiplier) {\n        return 1 / (60 / val / this.multiplier);\n      } else {\n        return _get(_getPrototypeOf(TickParam.prototype), \"_fromType\", this).call(this, val);\n      }\n    }\n    /**\n     * Special case of type conversion where the units === \"bpm\"\n     */\n  }, {\n    key: \"_toType\",\n    value: function _toType(val) {\n      if (this.units === \"bpm\" && this.multiplier) {\n        return val / this.multiplier * 60;\n      } else {\n        return _get(_getPrototypeOf(TickParam.prototype), \"_toType\", this).call(this, val);\n      }\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n  }, {\n    key: \"multiplier\",\n    get: function get() {\n      return this._multiplier;\n    },\n    set: function set(m) {\n      // get and reset the current value with the new multiplier\n      // might be necessary to clear all the previous values\n      var currentVal = this.value;\n      this._multiplier = m;\n      this.cancelScheduledValues(0);\n      this.setValueAtTime(currentVal, 0);\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Param.getDefaults(), {\n        multiplier: 1,\n        units: \"hertz\",\n        value: 1\n      });\n    }\n  }]);\n  return TickParam;\n}(Param);","map":{"version":3,"mappings":"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","names":["Param","optionsFromArguments","Timeline","isUndef","TickParam","getDefaults","arguments","Infinity","options","_multiplier","multiplier","_events","cancel","add","ticks","time","type","value","_fromType","setValueAtTime","constant","toSeconds","setRampPoint","computedValue","prevEvent","get","segments","Math","round","max","i","segTime","rampVal","_exponentialApproach","linearRampToValueAtTime","_toType","computedTime","event","previousEvent","ticksUntilTime","_getTicksUntilEvent","computedVal","segmentDur","_exponentialInterpolate","val0","getValueAtTime","val1","onTheLineEvent","sampleTime","currentTick","getTicksAtTime","getTimeOfTick","tick","before","after","getAfter","delta","k","sqrt","pow","sol1","sol2","_initialValue","when","getDurationOfTicks","duration","computedDuration","startTicks","endTicks","val","units","m","currentVal","cancelScheduledValues","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\TickParam.ts"],"sourcesContent":["import { AutomationEvent, Param, ParamOptions } from \"../context/Param\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isUndef } from \"../util/TypeCheck\";\n\ntype TickAutomationEvent = AutomationEvent & {\n\tticks: number;\n};\n\ninterface TickParamOptions<TypeName extends UnitName> extends ParamOptions<TypeName> {\n\tmultiplier: number;\n}\n\n/**\n * A Param class just for computing ticks. Similar to the [[Param]] class,\n * but offers conversion to BPM values as well as ability to compute tick\n * duration and elapsed ticks\n */\nexport class TickParam<TypeName extends \"hertz\" | \"bpm\"> extends Param<TypeName> {\n\n\treadonly name: string = \"TickParam\";\n\n\t/**\n\t * The timeline which tracks all of the automations.\n\t */\n\tprotected _events: Timeline<TickAutomationEvent> = new Timeline(Infinity);\n\n\t/**\n\t * The internal holder for the multiplier value\n\t */\n\tprivate _multiplier = 1;\n\n\t/**\n\t * @param param The AudioParam to wrap\n\t * @param units The unit name\n\t * @param convert Whether or not to convert the value to the target units\n\t */\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: number);\n\tconstructor(options: Partial<TickParamOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickParam.getDefaults(), arguments, [\"value\"]);\n\n\t\t// set the multiplier\n\t\tthis._multiplier = options.multiplier;\n\n\t\t// clear the ticks from the beginning\n\t\tthis._events.cancel(0);\n\t\t// set an initial event\n\t\tthis._events.add({\n\t\t\tticks: 0,\n\t\t\ttime: 0,\n\t\t\ttype: \"setValueAtTime\",\n\t\t\tvalue: this._fromType(options.value),\n\t\t});\n\t\tthis.setValueAtTime(options.value, 0);\n\t}\n\n\tstatic getDefaults(): TickParamOptions<any> {\n\t\treturn Object.assign(Param.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tsetTargetAtTime(value: UnitMap[TypeName], time: Time, constant: number): this {\n\t\t// approximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tthis.setRampPoint(time);\n\t\tconst computedValue = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\tconst segments = Math.round(Math.max(1 / constant, 1));\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = constant * i + time;\n\t\t\tconst rampVal = this._exponentialApproach(prevEvent.time, prevEvent.value, computedValue, constant, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\tsetValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.setValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\tlinearRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tsuper.linearRampToValueAtTime(value, time);\n\t\tconst event = this._events.get(computedTime) as TickAutomationEvent;\n\t\tconst previousEvent = this._events.previousEvent(event);\n\t\tconst ticksUntilTime = this._getTicksUntilEvent(previousEvent, computedTime);\n\t\tevent.ticks = Math.max(ticksUntilTime, 0);\n\t\treturn this;\n\t}\n\n\texponentialRampToValueAtTime(value: UnitMap[TypeName], time: Time): this {\n\t\t// aproximate it with multiple linear ramps\n\t\ttime = this.toSeconds(time);\n\t\tconst computedVal = this._fromType(value);\n\n\t\t// start from previously scheduled value\n\t\tconst prevEvent = this._events.get(time) as TickAutomationEvent;\n\t\t// approx 10 segments per second\n\t\tconst segments = Math.round(Math.max((time - prevEvent.time) * 10, 1));\n\t\tconst segmentDur = ((time - prevEvent.time) / segments);\n\t\tfor (let i = 0; i <= segments; i++) {\n\t\t\tconst segTime = segmentDur * i + prevEvent.time;\n\t\t\tconst rampVal = this._exponentialInterpolate(prevEvent.time, prevEvent.value, time, computedVal, segTime);\n\t\t\tthis.linearRampToValueAtTime(this._toType(rampVal), segTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  event The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tprivate _getTicksUntilEvent(event: TickAutomationEvent | null, time: number): Ticks {\n\t\tif (event === null) {\n\t\t\tevent = {\n\t\t\t\tticks: 0,\n\t\t\t\ttime: 0,\n\t\t\t\ttype: \"setValueAtTime\",\n\t\t\t\tvalue: 0,\n\t\t\t};\n\t\t} else if (isUndef(event.ticks)) {\n\t\t\tconst previousEvent = this._events.previousEvent(event);\n\t\t\tevent.ticks = this._getTicksUntilEvent(previousEvent, event.time);\n\t\t}\n\t\tconst val0 = this._fromType(this.getValueAtTime(event.time));\n\t\tlet val1 = this._fromType(this.getValueAtTime(time));\n\t\t// if it's right on the line, take the previous value\n\t\tconst onTheLineEvent = this._events.get(time);\n\t\tif (onTheLineEvent && onTheLineEvent.time === time && onTheLineEvent.type === \"setValueAtTime\") {\n\t\t\tval1 = this._fromType(this.getValueAtTime(time - this.sampleTime));\n\t\t}\n\t\treturn 0.5 * (time - event.time) * (val0 + val1) + event.ticks;\n\t}\n\n\t/**\n\t * Returns the tick value at the time. Takes into account\n\t * any automation curves scheduled on the signal.\n\t * @param  time The time to get the tick count at\n\t * @return The number of ticks which have elapsed at the time given any automations.\n\t */\n\tgetTicksAtTime(time: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst event = this._events.get(computedTime);\n\t\treturn Math.max(this._getTicksUntilEvent(event, computedTime), 0);\n\t}\n\n\t/**\n\t * Return the elapsed time of the number of ticks from the given time\n\t * @param ticks The number of ticks to calculate\n\t * @param  time The time to get the next tick from\n\t * @return The duration of the number of ticks from the given time in seconds\n\t */\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst currentTick = this.getTicksAtTime(time);\n\t\treturn this.getTimeOfTick(currentTick + ticks) - computedTime;\n\t}\n\n\t/**\n\t * Given a tick, returns the time that tick occurs at.\n\t * @return The time that the tick occurs.\n\t */\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\tconst before = this._events.get(tick, \"ticks\");\n\t\tconst after = this._events.getAfter(tick, \"ticks\");\n\t\tif (before && before.ticks === tick) {\n\t\t\treturn before.time;\n\t\t} else if (before && after &&\n\t\t\tafter.type === \"linearRampToValueAtTime\" &&\n\t\t\tbefore.value !== after.value) {\n\t\t\tconst val0 = this._fromType(this.getValueAtTime(before.time));\n\t\t\tconst val1 = this._fromType(this.getValueAtTime(after.time));\n\t\t\tconst delta = (val1 - val0) / (after.time - before.time);\n\t\t\tconst k = Math.sqrt(Math.pow(val0, 2) - 2 * delta * (before.ticks - tick));\n\t\t\tconst sol1 = (-val0 + k) / delta;\n\t\t\tconst sol2 = (-val0 - k) / delta;\n\t\t\treturn (sol1 > 0 ? sol1 : sol2) + before.time;\n\t\t} else if (before) {\n\t\t\tif (before.value === 0) {\n\t\t\t\treturn Infinity;\n\t\t\t} else {\n\t\t\t\treturn before.time + (tick - before.ticks) / before.value;\n\t\t\t}\n\t\t} else {\n\t\t\treturn tick / this._initialValue;\n\t\t}\n\t}\n\n\t/**\n\t * Convert some number of ticks their the duration in seconds accounting\n\t * for any automation curves starting at the given time.\n\t * @param  ticks The number of ticks to convert to seconds.\n\t * @param  when  When along the automation timeline to convert the ticks.\n\t * @return The duration in seconds of the ticks.\n\t */\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this.getDurationOfTicks(ticks, when);\n\t}\n\n\t/**\n\t * The inverse of [[ticksToTime]]. Convert a duration in\n\t * seconds to the corresponding number of ticks accounting for any\n\t * automation curves starting at the given time.\n\t * @param  duration The time interval to convert to ticks.\n\t * @param  when When along the automation timeline to convert the ticks.\n\t * @return The duration in ticks.\n\t */\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(when);\n\t\tconst computedDuration = this.toSeconds(duration);\n\t\tconst startTicks = this.getTicksAtTime(computedTime);\n\t\tconst endTicks = this.getTicksAtTime(computedTime + computedDuration);\n\t\treturn endTicks - startTicks;\n\t}\n\n\t/**\n\t * Convert from the type when the unit value is BPM\n\t */\n\tprotected _fromType(val: UnitMap[TypeName]): number {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn 1 / (60 / val / this.multiplier);\n\t\t} else {\n\t\t\treturn super._fromType(val);\n\t\t}\n\t}\n\n\t/**\n\t * Special case of type conversion where the units === \"bpm\"\n\t */\n\tprotected _toType(val: number): UnitMap[TypeName] {\n\t\tif (this.units === \"bpm\" && this.multiplier) {\n\t\t\treturn (val / this.multiplier) * 60 as UnitMap[TypeName];\n\t\t} else {\n\t\t\treturn super._toType(val);\n\t\t}\n\t}\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\t// get and reset the current value with the new multiplier\n\t\t// might be necessary to clear all the previous values\n\t\tconst currentVal = this.value;\n\t\tthis._multiplier = m;\n\t\tthis.cancelScheduledValues(0);\n\t\tthis.setValueAtTime(currentVal, 0);\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
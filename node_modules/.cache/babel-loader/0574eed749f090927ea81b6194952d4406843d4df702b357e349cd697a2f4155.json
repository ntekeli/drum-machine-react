{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Loop } from \"./Loop\";\nimport { PatternGenerator } from \"./PatternGenerator\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns.\n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport var Pattern = /*#__PURE__*/function (_Loop) {\n  _inherits(Pattern, _Loop);\n  var _super = _createSuper(Pattern);\n  function Pattern() {\n    var _this;\n    _classCallCheck(this, Pattern);\n    _this = _super.call(this, optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n    _this.name = \"Pattern\";\n    var options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n    _this.callback = options.callback;\n    _this._values = options.values;\n    _this._pattern = PatternGenerator(options.values, options.pattern);\n    _this._type = options.pattern;\n    return _this;\n  }\n  _createClass(Pattern, [{\n    key: \"_tick\",\n    value:\n    /**\n     * Internal function called when the notes should be called\n     */\n    function _tick(time) {\n      var value = this._pattern.next();\n      this._value = value.value;\n      this.callback(time, this._value);\n    }\n    /**\n     * The array of events.\n     */\n  }, {\n    key: \"values\",\n    get: function get() {\n      return this._values;\n    },\n    set: function set(val) {\n      this._values = val;\n      // reset the pattern\n      this.pattern = this._type;\n    }\n    /**\n     * The current value of the pattern.\n     */\n  }, {\n    key: \"value\",\n    get: function get() {\n      return this._value;\n    }\n    /**\n     * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n     */\n  }, {\n    key: \"pattern\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(pattern) {\n      this._type = pattern;\n      this._pattern = PatternGenerator(this._values, this._type);\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Loop.getDefaults(), {\n        pattern: \"up\",\n        values: [],\n        callback: noOp\n      });\n    }\n  }]);\n  return Pattern;\n}(Loop);","map":{"version":3,"mappings":";;;;AAAA,SAASA,IAAI,QAAqB,QAAQ;AAC1C,SAASC,gBAAgB,QAAqB,oBAAoB;AAElE,SAASC,oBAAoB,QAAQ,uBAAuB;AAE5D,SAASC,IAAI,QAAQ,wBAAwB;AAQ7C;;;;;;;;;AASA,WAAaC,OAAmB;EAAA;EAAA;EAwC/B;IAAA;IAAA;IAEC,0BAAMF,oBAAoB,CAACE,OAAO,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,UAAU,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IAxCvF,UAAI,GAAW,SAAS;IAyChC,IAAMC,OAAO,GAAGL,oBAAoB,CAACE,OAAO,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,UAAU,EAAE,QAAQ,EAAE,SAAS,CAAC,CAAC;IAEzG,MAAKE,QAAQ,GAAGD,OAAO,CAACC,QAAQ;IAChC,MAAKC,OAAO,GAAGF,OAAO,CAACG,MAAM;IAC7B,MAAKC,QAAQ,GAAGV,gBAAgB,CAACM,OAAO,CAACG,MAAM,EAAEH,OAAO,CAACK,OAAO,CAAC;IACjE,MAAKC,KAAK,GAAGN,OAAO,CAACK,OAAO;IAAC;EAC9B;EAAC;IAAA;IAAA;IAUD;;;IAGU,eAAME,IAAa;MAC5B,IAAMC,KAAK,GAAG,IAAI,CAACJ,QAAQ,CAACK,IAAI,EAA+B;MAC/D,IAAI,CAACC,MAAM,GAAGF,KAAK,CAACA,KAAK;MACzB,IAAI,CAACP,QAAQ,CAACM,IAAI,EAAE,IAAI,CAACG,MAAM,CAAC;IACjC;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAU;MACT,OAAO,IAAI,CAACR,OAAO;IACpB,CAAC;IAAA,KACD,aAAWS,GAAG;MACb,IAAI,CAACT,OAAO,GAAGS,GAAG;MAClB;MACA,IAAI,CAACN,OAAO,GAAG,IAAI,CAACC,KAAK;IAC1B;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAS;MACR,OAAO,IAAI,CAACI,MAAM;IACnB;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAW;MACV,OAAO,IAAI,CAACJ,KAAK;IAClB,CAAC;IAAA,KACD,aAAYD,OAAO;MAClB,IAAI,CAACC,KAAK,GAAGD,OAAO;MACpB,IAAI,CAACD,QAAQ,GAAGV,gBAAgB,CAAC,IAAI,CAACQ,OAAO,EAAE,IAAI,CAACI,KAAK,CAAC;IAC3D;EAAC;IAAA;IAAA,OA7CD,uBAAkB;MACjB,OAAOM,MAAM,CAACC,MAAM,CAACpB,IAAI,CAACK,WAAW,EAAE,EAAE;QACxCO,OAAO,EAAE,IAAY;QACrBF,MAAM,EAAE,EAAE;QACVF,QAAQ,EAAEL;OACV,CAAC;IACH;EAAC;EAAA;AAAA,EAzDsCH,IAA+B","names":["Loop","PatternGenerator","optionsFromArguments","noOp","Pattern","getDefaults","arguments","options","callback","_values","values","_pattern","pattern","_type","time","value","next","_value","val","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\event\\Pattern.ts"],"sourcesContent":["import { Loop, LoopOptions } from \"./Loop\";\nimport { PatternGenerator, PatternName } from \"./PatternGenerator\";\nimport { ToneEventCallback } from \"./ToneEvent\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Seconds } from \"../core/type/Units\";\nimport { noOp } from \"../core/util/Interface\";\n\nexport interface PatternOptions<ValueType> extends LoopOptions {\n\tpattern: PatternName;\n\tvalues: ValueType[];\n\tcallback: (time: Seconds, value?: ValueType) => void;\n}\n\n/**\n * Pattern arpeggiates between the given notes\n * in a number of patterns. \n * @example\n * const pattern = new Tone.Pattern((time, note) => {\n * \t// the order of the notes passed in depends on the pattern\n * }, [\"C2\", \"D4\", \"E5\", \"A6\"], \"upDown\");\n * @category Event\n */\nexport class Pattern<ValueType> extends Loop<PatternOptions<ValueType>> {\n\n\treadonly name: string = \"Pattern\";\n\n\t/**\n\t * The pattern generator function\n\t */\n\tprivate _pattern: Iterator<ValueType>;\n\n\t/**\n\t * The current value\n\t */\n\tprivate _value?: ValueType;\n\n\t/**\n\t * Hold the pattern type\n\t */\n\tprivate _type: PatternName;\n\n\t/**\n\t * Hold the values\n\t */\n\tprivate _values: ValueType[];\n\n\t/**\n\t * The callback to be invoked at a regular interval\n\t */\n\tcallback: (time: Seconds, value?: ValueType) => void;\n\n\t/**\n\t * @param  callback The callback to invoke with the event.\n\t * @param  values The values to arpeggiate over.\n\t * @param  pattern  The name of the pattern\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tvalues?: ValueType[],\n\t\tpattern?: PatternName,\n\t);\n\tconstructor(options?: Partial<PatternOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]));\n\t\tconst options = optionsFromArguments(Pattern.getDefaults(), arguments, [\"callback\", \"values\", \"pattern\"]);\n\n\t\tthis.callback = options.callback;\n\t\tthis._values = options.values;\n\t\tthis._pattern = PatternGenerator(options.values, options.pattern);\n\t\tthis._type = options.pattern;\n\t}\n\n\tstatic getDefaults(): PatternOptions<any> {\n\t\treturn Object.assign(Loop.getDefaults(), {\n\t\t\tpattern: \"up\" as \"up\",\n\t\t\tvalues: [],\n\t\t\tcallback: noOp,\n\t\t});\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tconst value = this._pattern.next() as IteratorResult<ValueType>;\n\t\tthis._value = value.value;\n\t\tthis.callback(time, this._value);\n\t}\n\n\t/**\n\t * The array of events.\n\t */\n\tget values(): ValueType[] {\n\t\treturn this._values;\n\t}\n\tset values(val) {\n\t\tthis._values = val;\n\t\t// reset the pattern\n\t\tthis.pattern = this._type;\n\t}\n\n\t/**\n\t * The current value of the pattern.\n\t */\n\tget value(): ValueType | undefined {\n\t\treturn this._value;\n\t}\n\n\t/**\n\t * The pattern type. See Tone.CtrlPattern for the full list of patterns.\n\t */\n\tget pattern(): PatternName {\n\t\treturn this._type;\n\t}\n\tset pattern(pattern) {\n\t\tthis._type = pattern;\n\t\tthis._pattern = PatternGenerator(this._values, this._type);\n\t}\n}\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
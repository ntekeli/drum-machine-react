{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n/**\n * Base class for sources.\n * start/stop of this.context.transport.\n *\n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport var Source = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Source, _ToneAudioNode);\n  var _super = _createSuper(Source);\n  function Source(options) {\n    var _this;\n    _classCallCheck(this, Source);\n    _this = _super.call(this, options);\n    /**\n     * Sources have no inputs\n     */\n    _this.input = undefined;\n    /**\n     * Keep track of the scheduled state.\n     */\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The synced `start` callback function from the transport\n     */\n    _this._synced = false;\n    /**\n     * Keep track of all of the scheduled event ids\n     */\n    _this._scheduled = [];\n    /**\n     * Placeholder functions for syncing/unsyncing to transport\n     */\n    _this._syncedStart = noOp;\n    _this._syncedStop = noOp;\n    _this._state.memory = 100;\n    _this._state.increasing = true;\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      mute: options.mute,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.onstop = options.onstop;\n    return _this;\n  }\n  _createClass(Source, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     * @example\n     * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n     * \tplayer.start();\n     * \tconsole.log(player.state);\n     * }).toDestination();\n     */\n    function get() {\n      if (this._synced) {\n        if (this.context.transport.state === \"started\") {\n          return this._state.getValueAtTime(this.context.transport.seconds);\n        } else {\n          return \"stopped\";\n        }\n      } else {\n        return this._state.getValueAtTime(this.now());\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * // mute the output\n     * osc.mute = true;\n     */\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n    /**\n     * Ensure that the scheduled time is not before the current time.\n     * Should only be used when scheduled unsynced.\n     */\n  }, {\n    key: \"_clampToCurrentTime\",\n    value: function _clampToCurrentTime(time) {\n      if (this._synced) {\n        return time;\n      } else {\n        return Math.max(time, this.context.currentTime);\n      }\n    }\n    /**\n     * Start the source at the specified time. If no time is given,\n     * start the source now.\n     * @param  time When the source should be started.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset, duration) {\n      var _this2 = this;\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime);\n      // if it's started, stop it and restart it\n      if (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n        // time should be strictly greater than the previous start time\n        assert(GT(computedTime, this._state.get(computedTime).time), \"Start time must be strictly greater than previous start time\");\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"started\", computedTime);\n        this.log(\"restart\", computedTime);\n        this.restart(computedTime, offset, duration);\n      } else {\n        this.log(\"start\", computedTime);\n        this._state.setStateAtTime(\"started\", computedTime);\n        if (this._synced) {\n          // add the offset time to the event\n          var event = this._state.get(computedTime);\n          if (event) {\n            event.offset = this.toSeconds(defaultArg(offset, 0));\n            event.duration = duration ? this.toSeconds(duration) : undefined;\n          }\n          var sched = this.context.transport.schedule(function (t) {\n            _this2._start(t, offset, duration);\n          }, computedTime);\n          this._scheduled.push(sched);\n          // if the transport is already started\n          // and the time is greater than where the transport is\n          if (this.context.transport.state === \"started\" && this.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n            this._syncedStart(this.now(), this.context.transport.seconds);\n          }\n        } else {\n          assertContextRunning(this.context);\n          this._start(computedTime, offset, duration);\n        }\n      }\n      return this;\n    }\n    /**\n     * Stop the source at the specified time. If no time is given,\n     * stop the source now.\n     * @param  time When the source should be stopped.\n     * @example\n     * const source = new Tone.Oscillator().toDestination();\n     * source.start();\n     * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n      computedTime = this._clampToCurrentTime(computedTime);\n      if (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n        this.log(\"stop\", computedTime);\n        if (!this._synced) {\n          this._stop(computedTime);\n        } else {\n          var sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n          this._scheduled.push(sched);\n        }\n        this._state.cancel(computedTime);\n        this._state.setStateAtTime(\"stopped\", computedTime);\n      }\n      return this;\n    }\n    /**\n     * Restart the source.\n     */\n  }, {\n    key: \"restart\",\n    value: function restart(time, offset, duration) {\n      time = this.toSeconds(time);\n      if (this._state.getValueAtTime(time) === \"started\") {\n        this._state.cancel(time);\n        this._restart(time, offset, duration);\n      }\n      return this;\n    }\n    /**\n     * Sync the source to the Transport so that all subsequent\n     * calls to `start` and `stop` are synced to the TransportTime\n     * instead of the AudioContext time.\n     *\n     * @example\n     * const osc = new Tone.Oscillator().toDestination();\n     * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n     * osc.sync().start(0).stop(0.3);\n     * // start the transport.\n     * Tone.Transport.start();\n     * // set it to loop once a second\n     * Tone.Transport.loop = true;\n     * Tone.Transport.loopEnd = 1;\n     */\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      var _this3 = this;\n      if (!this._synced) {\n        this._synced = true;\n        this._syncedStart = function (time, offset) {\n          if (offset > 0) {\n            // get the playback state at that time\n            var stateEvent = _this3._state.get(offset);\n            // listen for start events which may occur in the middle of the sync'ed time\n            if (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n              // get the offset\n              var startOffset = offset - _this3.toSeconds(stateEvent.time);\n              var duration;\n              if (stateEvent.duration) {\n                duration = _this3.toSeconds(stateEvent.duration) - startOffset;\n              }\n              _this3._start(time, _this3.toSeconds(stateEvent.offset) + startOffset, duration);\n            }\n          }\n        };\n        this._syncedStop = function (time) {\n          var seconds = _this3.context.transport.getSecondsAtTime(Math.max(time - _this3.sampleTime, 0));\n          if (_this3._state.getValueAtTime(seconds) === \"started\") {\n            _this3._stop(time);\n          }\n        };\n        this.context.transport.on(\"start\", this._syncedStart);\n        this.context.transport.on(\"loopStart\", this._syncedStart);\n        this.context.transport.on(\"stop\", this._syncedStop);\n        this.context.transport.on(\"pause\", this._syncedStop);\n        this.context.transport.on(\"loopEnd\", this._syncedStop);\n      }\n      return this;\n    }\n    /**\n     * Unsync the source to the Transport. See Source.sync\n     */\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      var _this4 = this;\n      if (this._synced) {\n        this.context.transport.off(\"stop\", this._syncedStop);\n        this.context.transport.off(\"pause\", this._syncedStop);\n        this.context.transport.off(\"loopEnd\", this._syncedStop);\n        this.context.transport.off(\"start\", this._syncedStart);\n        this.context.transport.off(\"loopStart\", this._syncedStart);\n      }\n      this._synced = false;\n      // clear all of the scheduled ids\n      this._scheduled.forEach(function (id) {\n        return _this4.context.transport.clear(id);\n      });\n      this._scheduled = [];\n      this._state.cancel(0);\n      // stop it also\n      this._stop(0);\n      return this;\n    }\n    /**\n     * Clean up.\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Source.prototype), \"dispose\", this).call(this);\n      this.onstop = noOp;\n      this.unsync();\n      this._volume.dispose();\n      this._state.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        onstop: noOp,\n        volume: 0\n      });\n    }\n  }]);\n  return Source;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["Volume","ToneAudioNode","defaultArg","noOp","readOnly","StateTimeline","isDefined","isUndef","assert","assertContextRunning","GT","Source","options","undefined","_state","memory","increasing","_volume","output","context","mute","volume","onstop","_synced","transport","state","getValueAtTime","seconds","now","time","Math","max","currentTime","offset","duration","computedTime","toSeconds","_clampToCurrentTime","get","cancel","setStateAtTime","log","restart","event","sched","schedule","_start","t","_scheduled","push","getSecondsAtTime","immediate","_syncedStart","getNextState","_stop","bind","_restart","stateEvent","startOffset","_syncedStop","sampleTime","on","off","forEach","clear","id","unsync","dispose","Object","assign","getDefaults"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\Source.ts"],"sourcesContent":["import { Volume } from \"../component/channel/Volume\";\nimport \"../core/context/Destination\";\nimport \"../core/clock/Transport\";\nimport { Param } from \"../core/context/Param\";\nimport { OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels, Seconds, Time } from \"../core/type/Units\";\nimport { defaultArg } from \"../core/util/Defaults\";\nimport { noOp, readOnly } from \"../core/util/Interface\";\nimport { BasicPlaybackState, StateTimeline, StateTimelineEvent } from \"../core/util/StateTimeline\";\nimport { isDefined, isUndef } from \"../core/util/TypeCheck\";\nimport { assert, assertContextRunning } from \"../core/util/Debug\";\nimport { GT } from \"../core/util/Math\";\n\ntype onStopCallback = (source: Source<any>) => void;\n\nexport interface SourceOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n\tonstop: onStopCallback;\n}\n\n/**\n * Base class for sources. \n * start/stop of this.context.transport.\n * \n * ```\n * // Multiple state change events can be chained together,\n * // but must be set in the correct order and with ascending times\n * // OK\n * state.start().stop(\"+0.2\");\n * // OK\n * state.start().stop(\"+0.2\").start(\"+0.4\").stop(\"+0.7\")\n * // BAD\n * state.stop(\"+0.2\").start();\n * // BAD\n * state.start(\"+0.3\").stop(\"+0.2\");\n * ```\n */\nexport abstract class Source<Options extends SourceOptions> extends ToneAudioNode<Options> {\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The output note\n\t */\n\toutput: OutputNode;\n\n\t/**\n\t * Sources have no inputs\n\t */\n\tinput = undefined;\n\n\t/**\n\t * The volume of the output in decibels.\n\t * @example\n\t * const source = new Tone.PWMOscillator().toDestination();\n\t * source.volume.value = -6;\n\t */\n\tvolume: Param<\"decibels\">;\n\n\t/**\n\t * The callback to invoke when the source is stopped.\n\t */\n\tonstop: onStopCallback;\n\n\t/**\n\t * Keep track of the scheduled state.\n\t */\n\tprotected _state: StateTimeline<{\n\t\tduration?: Seconds;\n\t\toffset?: Seconds;\n\t\t/**\n\t\t * Either the buffer is explicitly scheduled to end using the stop method,\n\t\t * or it's implicitly ended when the buffer is over.\n\t\t */\n\t\timplicitEnd?: boolean;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The synced `start` callback function from the transport\n\t */\n\tprotected _synced = false;\n\n\t/**\n\t * Keep track of all of the scheduled event ids\n\t */\n\tprivate _scheduled: number[] = [];\n\n\t/**\n\t * Placeholder functions for syncing/unsyncing to transport\n\t */\n\tprivate _syncedStart: (time: Seconds, offset: Seconds) => void = noOp;\n\tprivate _syncedStop: (time: Seconds) => void = noOp;\n\n\tconstructor(options: SourceOptions) {\n\t\tsuper(options);\n\t\tthis._state.memory = 100;\n\t\tthis._state.increasing = true;\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tmute: options.mute,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.onstop = options.onstop;\n\t}\n\n\tstatic getDefaults(): SourceOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tonstop: noOp,\n\t\t\tvolume: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t * @example\n\t * const player = new Tone.Player(\"https://tonejs.github.io/audio/berklee/ahntone_c3.mp3\", () => {\n\t * \tplayer.start();\n\t * \tconsole.log(player.state);\n\t * }).toDestination();\n\t */\n\tget state(): BasicPlaybackState {\n\t\tif (this._synced) {\n\t\t\tif (this.context.transport.state === \"started\") {\n\t\t\t\treturn this._state.getValueAtTime(this.context.transport.seconds) as BasicPlaybackState;\n\t\t\t} else {\n\t\t\t\treturn \"stopped\";\n\t\t\t}\n\t\t} else {\n\t\t\treturn this._state.getValueAtTime(this.now()) as BasicPlaybackState;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * // mute the output\n\t * osc.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute: boolean) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\t// overwrite these functions\n\tprotected abstract _start(time: Time, offset?: Time, duration?: Time): void;\n\tprotected abstract _stop(time: Time): void;\n\tprotected abstract _restart(time: Seconds, offset?: Time, duration?: Time): void;\n\n\t/**\n\t * Ensure that the scheduled time is not before the current time.\n\t * Should only be used when scheduled unsynced.\n\t */\n\tprivate _clampToCurrentTime(time: Seconds): Seconds {\n\t\tif (this._synced) {\n\t\t\treturn time;\n\t\t} else {\n\t\t\treturn Math.max(time, this.context.currentTime);\n\t\t}\n\t}\n\n\t/**\n\t * Start the source at the specified time. If no time is given,\n\t * start the source now.\n\t * @param  time When the source should be started.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start(\"+0.5\"); // starts the source 0.5 seconds from now\n\t */\n\tstart(time?: Time, offset?: Time, duration?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\t// if it's started, stop it and restart it\n\t\tif (!this._synced && this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\t// time should be strictly greater than the previous start time\n\t\t\tassert(GT(computedTime, (this._state.get(computedTime) as StateTimelineEvent).time), \"Start time must be strictly greater than previous start time\");\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tthis.log(\"restart\", computedTime);\n\t\t\tthis.restart(computedTime, offset, duration);\n\t\t} else {\n\t\t\tthis.log(\"start\", computedTime);\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (this._synced) {\n\t\t\t\t// add the offset time to the event\n\t\t\t\tconst event = this._state.get(computedTime);\n\t\t\t\tif (event) {\n\t\t\t\t\tevent.offset = this.toSeconds(defaultArg(offset, 0));\n\t\t\t\t\tevent.duration = duration ? this.toSeconds(duration) : undefined;\n\t\t\t\t}\n\t\t\t\tconst sched = this.context.transport.schedule(t => {\n\t\t\t\t\tthis._start(t, offset, duration);\n\t\t\t\t}, computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\n\t\t\t\t// if the transport is already started\n\t\t\t\t// and the time is greater than where the transport is\n\t\t\t\tif (this.context.transport.state === \"started\" && \n\t\t\t\t\tthis.context.transport.getSecondsAtTime(this.immediate()) > computedTime) {\n\t\t\t\t\tthis._syncedStart(this.now(), this.context.transport.seconds);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tassertContextRunning(this.context);\n\t\t\t\tthis._start(computedTime, offset, duration);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the source at the specified time. If no time is given,\n\t * stop the source now.\n\t * @param  time When the source should be stopped.\n\t * @example\n\t * const source = new Tone.Oscillator().toDestination();\n\t * source.start();\n\t * source.stop(\"+0.5\"); // stops the source 0.5 seconds from now\n\t */\n\tstop(time?: Time): this {\n\t\tlet computedTime = isUndef(time) && this._synced ? this.context.transport.seconds : this.toSeconds(time);\n\t\tcomputedTime = this._clampToCurrentTime(computedTime);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\" || isDefined(this._state.getNextState(\"started\", computedTime))) {\n\t\t\tthis.log(\"stop\", computedTime);\n\t\t\tif (!this._synced) {\n\t\t\t\tthis._stop(computedTime);\n\t\t\t} else {\n\t\t\t\tconst sched = this.context.transport.schedule(this._stop.bind(this), computedTime);\n\t\t\t\tthis._scheduled.push(sched);\n\t\t\t}\n\t\t\tthis._state.cancel(computedTime);\n\t\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the source.\n\t */\n\trestart(time?: Time, offset?: Time, duration?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(time) === \"started\") {\n\t\t\tthis._state.cancel(time);\n\t\t\tthis._restart(time, offset, duration);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the source to the Transport so that all subsequent\n\t * calls to `start` and `stop` are synced to the TransportTime\n\t * instead of the AudioContext time.\n\t *\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination();\n\t * // sync the source so that it plays between 0 and 0.3 on the Transport's timeline\n\t * osc.sync().start(0).stop(0.3);\n\t * // start the transport.\n\t * Tone.Transport.start();\n\t * // set it to loop once a second\n\t * Tone.Transport.loop = true;\n\t * Tone.Transport.loopEnd = 1;\n\t */\n\tsync(): this {\n\t\tif (!this._synced) {\n\t\t\tthis._synced = true;\n\t\t\tthis._syncedStart = (time, offset) => {\n\t\t\t\tif (offset > 0) {\n\t\t\t\t\t// get the playback state at that time\n\t\t\t\t\tconst stateEvent = this._state.get(offset);\n\t\t\t\t\t// listen for start events which may occur in the middle of the sync'ed time\n\t\t\t\t\tif (stateEvent && stateEvent.state === \"started\" && stateEvent.time !== offset) {\n\t\t\t\t\t\t// get the offset\n\t\t\t\t\t\tconst startOffset = offset - this.toSeconds(stateEvent.time);\n\t\t\t\t\t\tlet duration: number | undefined;\n\t\t\t\t\t\tif (stateEvent.duration) {\n\t\t\t\t\t\t\tduration = this.toSeconds(stateEvent.duration) - startOffset;\n\t\t\t\t\t\t}\n\t\t\t\t\t\tthis._start(time, this.toSeconds(stateEvent.offset) + startOffset, duration);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis._syncedStop = time => {\n\t\t\t\tconst seconds = this.context.transport.getSecondsAtTime(Math.max(time - this.sampleTime, 0));\n\t\t\t\tif (this._state.getValueAtTime(seconds) === \"started\") {\n\t\t\t\t\tthis._stop(time);\n\t\t\t\t}\n\t\t\t};\n\t\t\tthis.context.transport.on(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"loopStart\", this._syncedStart);\n\t\t\tthis.context.transport.on(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.on(\"loopEnd\", this._syncedStop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the source to the Transport. See Source.sync\n\t */\n\tunsync(): this {\n\t\tif (this._synced) {\n\t\t\tthis.context.transport.off(\"stop\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"pause\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"loopEnd\", this._syncedStop);\n\t\t\tthis.context.transport.off(\"start\", this._syncedStart);\n\t\t\tthis.context.transport.off(\"loopStart\", this._syncedStart);\n\t\t}\n\t\tthis._synced = false;\n\t\t// clear all of the scheduled ids\n\t\tthis._scheduled.forEach(id => this.context.transport.clear(id));\n\t\tthis._scheduled = [];\n\t\tthis._state.cancel(0);\n\t\t// stop it also\n\t\tthis._stop(0);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up.\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.onstop = noOp;\n\t\tthis.unsync();\n\t\tthis._volume.dispose();\n\t\tthis._state.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { StereoEffect } from \"./StereoEffect\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport var Phaser = /*#__PURE__*/function (_StereoEffect) {\n  _inherits(Phaser, _StereoEffect);\n  var _super = _createSuper(Phaser);\n  function Phaser() {\n    var _this2, _this3;\n    var _this;\n    _classCallCheck(this, Phaser);\n    _this = _super.call(this, optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n    _this.name = \"Phaser\";\n    var options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n    _this._lfoL = new LFO({\n      context: _this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1\n    });\n    _this._lfoR = new LFO({\n      context: _this.context,\n      frequency: options.frequency,\n      min: 0,\n      max: 1,\n      phase: 180\n    });\n    _this._baseFrequency = _this.toFrequency(options.baseFrequency);\n    _this._octaves = options.octaves;\n    _this.Q = new Signal({\n      context: _this.context,\n      value: options.Q,\n      units: \"positive\"\n    });\n    _this._filtersL = _this._makeFilters(options.stages, _this._lfoL);\n    _this._filtersR = _this._makeFilters(options.stages, _this._lfoR);\n    _this.frequency = _this._lfoL.frequency;\n    _this.frequency.value = options.frequency;\n    // connect them up\n    (_this2 = _this).connectEffectLeft.apply(_this2, _toConsumableArray(_this._filtersL));\n    (_this3 = _this).connectEffectRight.apply(_this3, _toConsumableArray(_this._filtersR));\n    // control the frequency with one LFO\n    _this._lfoL.frequency.connect(_this._lfoR.frequency);\n    // set the options\n    _this.baseFrequency = options.baseFrequency;\n    _this.octaves = options.octaves;\n    // start the lfo\n    _this._lfoL.start();\n    _this._lfoR.start();\n    readOnly(_assertThisInitialized(_this), [\"frequency\", \"Q\"]);\n    return _this;\n  }\n  _createClass(Phaser, [{\n    key: \"_makeFilters\",\n    value: function _makeFilters(stages, connectToFreq) {\n      var filters = [];\n      // make all the filters\n      for (var i = 0; i < stages; i++) {\n        var filter = this.context.createBiquadFilter();\n        filter.type = \"allpass\";\n        this.Q.connect(filter.Q);\n        connectToFreq.connect(filter.frequency);\n        filters.push(filter);\n      }\n      return filters;\n    }\n    /**\n     * The number of octaves the phase goes above the baseFrequency\n     */\n  }, {\n    key: \"octaves\",\n    get: function get() {\n      return this._octaves;\n    },\n    set: function set(octaves) {\n      this._octaves = octaves;\n      var max = this._baseFrequency * Math.pow(2, octaves);\n      this._lfoL.max = max;\n      this._lfoR.max = max;\n    }\n    /**\n     * The the base frequency of the filters.\n     */\n  }, {\n    key: \"baseFrequency\",\n    get: function get() {\n      return this._baseFrequency;\n    },\n    set: function set(freq) {\n      this._baseFrequency = this.toFrequency(freq);\n      this._lfoL.min = this._baseFrequency;\n      this._lfoR.min = this._baseFrequency;\n      this.octaves = this._octaves;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Phaser.prototype), \"dispose\", this).call(this);\n      this.Q.dispose();\n      this._lfoL.dispose();\n      this._lfoR.dispose();\n      this._filtersL.forEach(function (f) {\n        return f.disconnect();\n      });\n      this._filtersR.forEach(function (f) {\n        return f.disconnect();\n      });\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(StereoEffect.getDefaults(), {\n        frequency: 0.5,\n        octaves: 3,\n        stages: 10,\n        Q: 10,\n        baseFrequency: 350\n      });\n    }\n  }]);\n  return Phaser;\n}(StereoEffect);","map":{"version":3,"mappings":"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","names":["StereoEffect","optionsFromArguments","LFO","Signal","readOnly","Phaser","getDefaults","arguments","options","_lfoL","context","frequency","min","max","_lfoR","phase","_baseFrequency","toFrequency","baseFrequency","_octaves","octaves","Q","value","units","_filtersL","_makeFilters","stages","_filtersR","connectEffectLeft","connectEffectRight","connect","start","connectToFreq","filters","i","filter","createBiquadFilter","type","push","Math","pow","freq","dispose","forEach","f","disconnect","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\effect\\Phaser.ts"],"sourcesContent":["import { StereoEffect, StereoEffectOptions } from \"./StereoEffect\";\nimport { Frequency, Hertz, Positive } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { LFO } from \"../source/oscillator/LFO\";\nimport { Signal } from \"../signal/Signal\";\nimport { readOnly } from \"../core/util/Interface\";\n\nexport interface PhaserOptions extends StereoEffectOptions {\n\tfrequency: Frequency;\n\toctaves: Positive;\n\tstages: Positive;\n\tQ: Positive;\n\tbaseFrequency: Frequency;\n}\n\n/**\n * Phaser is a phaser effect. Phasers work by changing the phase\n * of different frequency components of an incoming signal. Read more on\n * [Wikipedia](https://en.wikipedia.org/wiki/Phaser_(effect)).\n * Inspiration for this phaser comes from [Tuna.js](https://github.com/Dinahmoe/tuna/).\n * @example\n * const phaser = new Tone.Phaser({\n * \tfrequency: 15,\n * \toctaves: 5,\n * \tbaseFrequency: 1000\n * }).toDestination();\n * const synth = new Tone.FMSynth().connect(phaser);\n * synth.triggerAttackRelease(\"E3\", \"2n\");\n * @category Effect\n */\nexport class Phaser extends StereoEffect<PhaserOptions> {\n\n\treadonly name: string = \"Phaser\";\n\n\t/**\n\t * the lfo which controls the frequency on the left side\n\t */\n\tprivate _lfoL: LFO;\n\n\t/**\n\t * the lfo which controls the frequency on the right side\n\t */\n\tprivate _lfoR: LFO;\n\n\t/**\n\t * the base modulation frequency\n\t */\n\tprivate _baseFrequency: Hertz;\n\n\t/**\n\t * the octaves of the phasing\n\t */\n\tprivate _octaves: Positive;\n\n\t/**\n\t * The quality factor of the filters\n\t */\n\treadonly Q: Signal<\"positive\">;\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersL: BiquadFilterNode[];\n\n\t/**\n\t * the array of filters for the left side\n\t */\n\tprivate _filtersR: BiquadFilterNode[];\n\n\t/**\n\t * the frequency of the effect\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The speed of the phasing.\n\t * @param octaves The octaves of the effect.\n\t * @param baseFrequency The base frequency of the filters.\n\t */\n\tconstructor(frequency?: Frequency, octaves?: Positive, baseFrequency?: Frequency);\n\tconstructor(options?: Partial<PhaserOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]));\n\t\tconst options = optionsFromArguments(Phaser.getDefaults(), arguments, [\"frequency\", \"octaves\", \"baseFrequency\"]);\n\n\t\tthis._lfoL = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1\n\t\t});\n\t\tthis._lfoR = new LFO({\n\t\t\tcontext: this.context,\n\t\t\tfrequency: options.frequency,\n\t\t\tmin: 0,\n\t\t\tmax: 1,\n\t\t\tphase: 180,\n\t\t});\n\t\tthis._baseFrequency = this.toFrequency(options.baseFrequency);\n\t\tthis._octaves = options.octaves;\n\t\tthis.Q = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tvalue: options.Q,\n\t\t\tunits: \"positive\",\n\t\t});\n\t\tthis._filtersL = this._makeFilters(options.stages, this._lfoL);\n\t\tthis._filtersR = this._makeFilters(options.stages, this._lfoR);\n\n\t\tthis.frequency = this._lfoL.frequency;\n\t\tthis.frequency.value = options.frequency;\n\n\t\t// connect them up\n\t\tthis.connectEffectLeft(...this._filtersL);\n\t\tthis.connectEffectRight(...this._filtersR);\n\t\t// control the frequency with one LFO\n\t\tthis._lfoL.frequency.connect(this._lfoR.frequency);\n\t\t// set the options\n\t\tthis.baseFrequency = options.baseFrequency;\n\t\tthis.octaves = options.octaves;\n\t\t// start the lfo\n\t\tthis._lfoL.start();\n\t\tthis._lfoR.start();\n\t\treadOnly(this, [\"frequency\", \"Q\"]);\n\t}\n\n\tstatic getDefaults(): PhaserOptions {\n\t\treturn Object.assign(StereoEffect.getDefaults(), {\n\t\t\tfrequency: 0.5,\n\t\t\toctaves: 3,\n\t\t\tstages: 10,\n\t\t\tQ: 10,\n\t\t\tbaseFrequency: 350,\n\t\t});\n\t}\n\n\tprivate _makeFilters(stages: number, connectToFreq: LFO): BiquadFilterNode[] {\n\t\tconst filters: BiquadFilterNode[] = [];\n\t\t// make all the filters\n\t\tfor (let i = 0; i < stages; i++) {\n\t\t\tconst filter = this.context.createBiquadFilter();\n\t\t\tfilter.type = \"allpass\";\n\t\t\tthis.Q.connect(filter.Q);\n\t\t\tconnectToFreq.connect(filter.frequency);\n\t\t\tfilters.push(filter);\n\t\t}\n\t\treturn filters;\n\t}\n\n\t/**\n\t * The number of octaves the phase goes above the baseFrequency\n\t */\n\tget octaves() {\n\t\treturn this._octaves;\n\t}\n\tset octaves(octaves) {\n\t\tthis._octaves = octaves;\n\t\tconst max = this._baseFrequency * Math.pow(2, octaves);\n\t\tthis._lfoL.max = max;\n\t\tthis._lfoR.max = max;\n\t}\n\n\t/**\n\t * The the base frequency of the filters.\n\t */\n\tget baseFrequency(): Frequency {\n\t\treturn this._baseFrequency;\n\t}\n\tset baseFrequency(freq) {\n\t\tthis._baseFrequency = this.toFrequency(freq);\n\t\tthis._lfoL.min = this._baseFrequency;\n\t\tthis._lfoR.min = this._baseFrequency;\n\t\tthis.octaves = this._octaves;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.Q.dispose();\n\t\tthis._lfoL.dispose();\n\t\tthis._lfoR.dispose();\n\t\tthis._filtersL.forEach(f => f.disconnect());\n\t\tthis._filtersR.forEach(f => f.disconnect());\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
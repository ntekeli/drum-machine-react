{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneEvent } from \"./ToneEvent\";\nimport { ToneWithContext } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\n/**\n * Loop creates a looped callback at the\n * specified interval. The callback can be\n * started, stopped and scheduled along\n * the Transport's timeline.\n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note.\n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport var Loop = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Loop, _ToneWithContext);\n  var _super = _createSuper(Loop);\n  function Loop() {\n    var _this;\n    _classCallCheck(this, Loop);\n    _this = _super.call(this, optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n    _this.name = \"Loop\";\n    var options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n    _this._event = new ToneEvent({\n      context: _this.context,\n      callback: _this._tick.bind(_assertThisInitialized(_this)),\n      loop: true,\n      loopEnd: options.interval,\n      playbackRate: options.playbackRate,\n      probability: options.probability\n    });\n    _this.callback = options.callback;\n    // set the iterations\n    _this.iterations = options.iterations;\n    return _this;\n  }\n  _createClass(Loop, [{\n    key: \"start\",\n    value:\n    /**\n     * Start the loop at the specified time along the Transport's timeline.\n     * @param  time  When to start the Loop.\n     */\n    function start(time) {\n      this._event.start(time);\n      return this;\n    }\n    /**\n     * Stop the loop at the given time.\n     * @param  time  When to stop the Loop.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._event.stop(time);\n      return this;\n    }\n    /**\n     * Cancel all scheduled events greater than or equal to the given time\n     * @param  time  The time after which events will be cancel.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      this._event.cancel(time);\n      return this;\n    }\n    /**\n     * Internal function called when the notes should be called\n     * @param time  The time the event occurs\n     */\n  }, {\n    key: \"_tick\",\n    value: function _tick(time) {\n      this.callback(time);\n    }\n    /**\n     * The state of the Loop, either started or stopped.\n     */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._event.state;\n    }\n    /**\n     * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating.\n     */\n  }, {\n    key: \"progress\",\n    get: function get() {\n      return this._event.progress;\n    }\n    /**\n     * The time between successive callbacks.\n     * @example\n     * const loop = new Tone.Loop();\n     * loop.interval = \"8n\"; // loop every 8n\n     */\n  }, {\n    key: \"interval\",\n    get: function get() {\n      return this._event.loopEnd;\n    },\n    set: function set(interval) {\n      this._event.loopEnd = interval;\n    }\n    /**\n     * The playback rate of the loop. The normal playback rate is 1 (no change).\n     * A `playbackRate` of 2 would be twice as fast.\n     */\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._event.playbackRate;\n    },\n    set: function set(rate) {\n      this._event.playbackRate = rate;\n    }\n    /**\n     * Random variation +/-0.01s to the scheduled time.\n     * Or give it a time value which it will randomize by.\n     */\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._event.humanize;\n    },\n    set: function set(variation) {\n      this._event.humanize = variation;\n    }\n    /**\n     * The probably of the callback being invoked.\n     */\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._event.probability;\n    },\n    set: function set(prob) {\n      this._event.probability = prob;\n    }\n    /**\n     * Muting the Loop means that no callbacks are invoked.\n     */\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._event.mute;\n    },\n    set: function set(mute) {\n      this._event.mute = mute;\n    }\n    /**\n     * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n     */\n  }, {\n    key: \"iterations\",\n    get: function get() {\n      if (this._event.loop === true) {\n        return Infinity;\n      } else {\n        return this._event.loop;\n      }\n    },\n    set: function set(iters) {\n      if (iters === Infinity) {\n        this._event.loop = true;\n      } else {\n        this._event.loop = iters;\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Loop.prototype), \"dispose\", this).call(this);\n      this._event.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneWithContext.getDefaults(), {\n        interval: \"4n\",\n        callback: noOp,\n        playbackRate: 1,\n        iterations: Infinity,\n        probability: 1,\n        mute: false,\n        humanize: false\n      });\n    }\n  }]);\n  return Loop;\n}(ToneWithContext);","map":{"version":3,"mappings":"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","names":["ToneEvent","ToneWithContext","optionsFromArguments","noOp","Loop","getDefaults","arguments","options","_event","context","callback","_tick","bind","loop","loopEnd","interval","playbackRate","probability","iterations","time","start","stop","cancel","state","progress","rate","humanize","variation","prob","mute","Infinity","iters","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\event\\Loop.ts"],"sourcesContent":["import { ToneEvent } from \"./ToneEvent\";\nimport { NormalRange, Positive, Seconds, Time, TransportTime } from \"../core/type/Units\";\nimport { ToneWithContext, ToneWithContextOptions } from \"../core/context/ToneWithContext\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { BasicPlaybackState } from \"../core/util/StateTimeline\";\n\nexport interface LoopOptions extends ToneWithContextOptions {\n\tcallback: (time: Seconds) => void;\n\tinterval: Time;\n\tplaybackRate: Positive;\n\titerations: number;\n\tprobability: NormalRange;\n\tmute: boolean;\n\thumanize: boolean | Time;\n}\n\n/**\n * Loop creates a looped callback at the \n * specified interval. The callback can be \n * started, stopped and scheduled along\n * the Transport's timeline. \n * @example\n * const loop = new Tone.Loop((time) => {\n * \t// triggered every eighth note. \n * \tconsole.log(time);\n * }, \"8n\").start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Loop<Options extends LoopOptions = LoopOptions> extends ToneWithContext<Options> {\n\n\treadonly name: string = \"Loop\";\n\n\t/**\n\t * The event which produces the callbacks\n\t */\n\tprivate _event: ToneEvent;\n\n\t/**\n\t * The callback to invoke with the next event in the pattern\n\t */\n\tcallback: (time: Seconds) => void\n\n\t/**\n\t * @param callback The callback to invoke at the time.\n\t * @param interval The time between successive callback calls. \n\t */\n\tconstructor(callback?: (time: Seconds) => void, interval?: Time);\n\tconstructor(options?: Partial<LoopOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]));\n\t\tconst options = optionsFromArguments(Loop.getDefaults(), arguments, [\"callback\", \"interval\"]);\n\n\t\tthis._event = new ToneEvent({\n\t\t\tcontext: this.context,\n\t\t\tcallback: this._tick.bind(this),\n\t\t\tloop: true,\n\t\t\tloopEnd: options.interval,\n\t\t\tplaybackRate: options.playbackRate,\n\t\t\tprobability: options.probability\n\t\t});\n\n\t\tthis.callback = options.callback;\n\t\t// set the iterations\n\t\tthis.iterations = options.iterations;\n\t}\n\n\tstatic getDefaults(): LoopOptions {\n\t\treturn Object.assign(ToneWithContext.getDefaults(), {\n\t\t\tinterval: \"4n\",\n\t\t\tcallback: noOp,\n\t\t\tplaybackRate: 1,\n\t\t\titerations: Infinity,\n\t\t\tprobability: 1,\n\t\t\tmute: false,\n\t\t\thumanize: false\n\t\t});\n\t}\n\n\t/**\n\t * Start the loop at the specified time along the Transport's timeline.\n\t * @param  time  When to start the Loop.\n\t */\n\tstart(time?: TransportTime): this {\n\t\tthis._event.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the loop at the given time.\n\t * @param  time  When to stop the Loop.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._event.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel all scheduled events greater than or equal to the given time\n\t * @param  time  The time after which events will be cancel.\n\t */\n\tcancel(time?: TransportTime): this {\n\t\tthis._event.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal function called when the notes should be called\n\t * @param time  The time the event occurs\n\t */\n\tprotected _tick(time: Seconds): void {\n\t\tthis.callback(time);\n\t}\n\n\t/**\n\t * The state of the Loop, either started or stopped.\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._event.state;\n\t}\n\n\t/**\n\t * The progress of the loop as a value between 0-1. 0, when the loop is stopped or done iterating. \n\t */\n\tget progress(): NormalRange {\n\t\treturn this._event.progress;\n\t}\n\n\t/**\n\t * The time between successive callbacks. \n\t * @example\n\t * const loop = new Tone.Loop();\n\t * loop.interval = \"8n\"; // loop every 8n\n\t */\n\tget interval(): Time {\n\t\treturn this._event.loopEnd;\n\t}\n\tset interval(interval) {\n\t\tthis._event.loopEnd = interval;\n\t}\n\n\t/**\n\t * The playback rate of the loop. The normal playback rate is 1 (no change). \n\t * A `playbackRate` of 2 would be twice as fast. \n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._event.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._event.playbackRate = rate;\n\t}\n\n\t/**\n\t * Random variation +/-0.01s to the scheduled time. \n\t * Or give it a time value which it will randomize by.\n\t */\n\tget humanize(): boolean | Time {\n\t\treturn this._event.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._event.humanize = variation;\n\t}\n\n\t/**\n\t * The probably of the callback being invoked.\n\t */\n\tget probability(): NormalRange {\n\t\treturn this._event.probability;\n\t}\n\n\tset probability(prob) {\n\t\tthis._event.probability = prob;\n\t}\n\n\t/**\n\t * Muting the Loop means that no callbacks are invoked.\n\t */\n\tget mute(): boolean {\n\t\treturn this._event.mute;\n\t}\n\n\tset mute(mute) {\n\t\tthis._event.mute = mute;\n\t}\n\n\t/**\n\t * The number of iterations of the loop. The default value is `Infinity` (loop forever).\n\t */\n\tget iterations(): number {\n\t\tif (this._event.loop === true) {\n\t\t\treturn Infinity;\n\t\t} else {\n\t\t\treturn this._event.loop as number;\n\t\t}\n\t}\n\tset iterations(iters) {\n\t\tif (iters === Infinity) {\n\t\t\tthis._event.loop = true;\n\t\t} else {\n\t\t\tthis._event.loop = iters;\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._event.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
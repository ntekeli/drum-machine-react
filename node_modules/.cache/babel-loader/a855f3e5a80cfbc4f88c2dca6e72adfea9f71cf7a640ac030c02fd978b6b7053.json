{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _slicedToArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport { generateWaveform } from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport var Oscillator = /*#__PURE__*/function (_Source) {\n  _inherits(Oscillator, _Source);\n  var _super = _createSuper(Oscillator);\n  function Oscillator() {\n    var _this;\n    _classCallCheck(this, Oscillator);\n    _this = _super.call(this, optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n    _this.name = \"Oscillator\";\n    /**\n     * the main oscillator\n     */\n    _this._oscillator = null;\n    var options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\");\n    _this.detune = new Signal({\n      context: _this.context,\n      units: \"cents\",\n      value: options.detune\n    });\n    readOnly(_assertThisInitialized(_this), \"detune\");\n    _this._partials = options.partials;\n    _this._partialCount = options.partialCount;\n    _this._type = options.type;\n    if (options.partialCount && options.type !== \"custom\") {\n      _this._type = _this.baseType + options.partialCount.toString();\n    }\n    _this.phase = options.phase;\n    return _this;\n  }\n  _createClass(Oscillator, [{\n    key: \"_start\",\n    value:\n    /**\n     * start the oscillator\n     */\n    function _start(time) {\n      var _this2 = this;\n      var computedTime = this.toSeconds(time);\n      // new oscillator with previous values\n      var oscillator = new ToneOscillatorNode({\n        context: this.context,\n        onended: function onended() {\n          return _this2.onstop(_this2);\n        }\n      });\n      this._oscillator = oscillator;\n      if (this._wave) {\n        this._oscillator.setPeriodicWave(this._wave);\n      } else {\n        this._oscillator.type = this._type;\n      }\n      // connect the control signal to the oscillator frequency & detune\n      this._oscillator.connect(this.output);\n      this.frequency.connect(this._oscillator.frequency);\n      this.detune.connect(this._oscillator.detune);\n      // start the oscillator\n      this._oscillator.start(computedTime);\n    }\n    /**\n     * stop the oscillator\n     */\n  }, {\n    key: \"_stop\",\n    value: function _stop(time) {\n      var computedTime = this.toSeconds(time);\n      if (this._oscillator) {\n        this._oscillator.stop(computedTime);\n      }\n    }\n    /**\n     * Restart the oscillator. Does not stop the oscillator, but instead\n     * just cancels any scheduled 'stop' from being invoked.\n     */\n  }, {\n    key: \"_restart\",\n    value: function _restart(time) {\n      var computedTime = this.toSeconds(time);\n      this.log(\"restart\", computedTime);\n      if (this._oscillator) {\n        this._oscillator.cancelStop();\n      }\n      this._state.cancel(computedTime);\n      return this;\n    }\n    /**\n     * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n     * will also affect the oscillators frequency.\n     * @example\n     * const osc = new Tone.Oscillator().toDestination().start();\n     * osc.frequency.value = 440;\n     * // the ratio between the bpm and the frequency will be maintained\n     * osc.syncFrequency();\n     * // double the tempo\n     * Tone.Transport.bpm.value *= 2;\n     * // the frequency of the oscillator is doubled to 880\n     */\n  }, {\n    key: \"syncFrequency\",\n    value: function syncFrequency() {\n      this.context.transport.syncSignal(this.frequency);\n      return this;\n    }\n    /**\n     * Unsync the oscillator's frequency from the Transport.\n     * See Oscillator.syncFrequency\n     */\n  }, {\n    key: \"unsyncFrequency\",\n    value: function unsyncFrequency() {\n      this.context.transport.unsyncSignal(this.frequency);\n      return this;\n    }\n    /**\n     * Get a cached periodic wave. Avoids having to recompute\n     * the oscillator values when they have already been computed\n     * with the same values.\n     */\n  }, {\n    key: \"_getCachedPeriodicWave\",\n    value: function _getCachedPeriodicWave() {\n      var _this3 = this;\n      if (this._type === \"custom\") {\n        var oscProps = Oscillator._periodicWaveCache.find(function (description) {\n          return description.phase === _this3._phase && deepEquals(description.partials, _this3._partials);\n        });\n        return oscProps;\n      } else {\n        var _oscProps = Oscillator._periodicWaveCache.find(function (description) {\n          return description.type === _this3._type && description.phase === _this3._phase;\n        });\n        this._partialCount = _oscProps ? _oscProps.partialCount : this._partialCount;\n        return _oscProps;\n      }\n    }\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      this._type = type;\n      var isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n      if (this._phase === 0 && isBasicType) {\n        this._wave = undefined;\n        this._partialCount = 0;\n        // just go with the basic approach\n        if (this._oscillator !== null) {\n          // already tested that it's a basic type\n          this._oscillator.type = type;\n        }\n      } else {\n        // first check if the value is cached\n        var cache = this._getCachedPeriodicWave();\n        if (isDefined(cache)) {\n          var partials = cache.partials,\n            wave = cache.wave;\n          this._wave = wave;\n          this._partials = partials;\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          }\n        } else {\n          var _this$_getRealImagina = this._getRealImaginary(type, this._phase),\n            _this$_getRealImagina2 = _slicedToArray(_this$_getRealImagina, 2),\n            real = _this$_getRealImagina2[0],\n            imag = _this$_getRealImagina2[1];\n          var periodicWave = this.context.createPeriodicWave(real, imag);\n          this._wave = periodicWave;\n          if (this._oscillator !== null) {\n            this._oscillator.setPeriodicWave(this._wave);\n          }\n          // set the cache\n          Oscillator._periodicWaveCache.push({\n            imag: imag,\n            partialCount: this._partialCount,\n            partials: this._partials,\n            phase: this._phase,\n            real: real,\n            type: this._type,\n            wave: this._wave\n          });\n          if (Oscillator._periodicWaveCache.length > 100) {\n            Oscillator._periodicWaveCache.shift();\n          }\n        }\n      }\n    }\n  }, {\n    key: \"baseType\",\n    get: function get() {\n      return this._type.replace(this.partialCount.toString(), \"\");\n    },\n    set: function set(baseType) {\n      if (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n        this.type = baseType + this.partialCount;\n      } else {\n        this.type = baseType;\n      }\n    }\n  }, {\n    key: \"partialCount\",\n    get: function get() {\n      return this._partialCount;\n    },\n    set: function set(p) {\n      assertRange(p, 0);\n      var type = this._type;\n      var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n      if (partial) {\n        type = partial[1];\n      }\n      if (this._type !== \"custom\") {\n        if (p === 0) {\n          this.type = type;\n        } else {\n          this.type = type + p.toString();\n        }\n      } else {\n        // extend or shorten the partials array\n        var fullPartials = new Float32Array(p);\n        // copy over the partials array\n        this._partials.forEach(function (v, i) {\n          return fullPartials[i] = v;\n        });\n        this._partials = Array.from(fullPartials);\n        this.type = this._type;\n      }\n    }\n    /**\n     * Returns the real and imaginary components based\n     * on the oscillator type.\n     * @returns [real: Float32Array, imaginary: Float32Array]\n     */\n  }, {\n    key: \"_getRealImaginary\",\n    value: function _getRealImaginary(type, phase) {\n      var fftSize = 4096;\n      var periodicWaveSize = fftSize / 2;\n      var real = new Float32Array(periodicWaveSize);\n      var imag = new Float32Array(periodicWaveSize);\n      var partialCount = 1;\n      if (type === \"custom\") {\n        partialCount = this._partials.length + 1;\n        this._partialCount = this._partials.length;\n        periodicWaveSize = partialCount;\n        // if the partial count is 0, don't bother doing any computation\n        if (this._partials.length === 0) {\n          return [real, imag];\n        }\n      } else {\n        var partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n        if (partial) {\n          partialCount = parseInt(partial[2], 10) + 1;\n          this._partialCount = parseInt(partial[2], 10);\n          type = partial[1];\n          partialCount = Math.max(partialCount, 2);\n          periodicWaveSize = partialCount;\n        } else {\n          this._partialCount = 0;\n        }\n        this._partials = [];\n      }\n      for (var n = 1; n < periodicWaveSize; ++n) {\n        var piFactor = 2 / (n * Math.PI);\n        var b = void 0;\n        switch (type) {\n          case \"sine\":\n            b = n <= partialCount ? 1 : 0;\n            this._partials[n - 1] = b;\n            break;\n          case \"square\":\n            b = n & 1 ? 2 * piFactor : 0;\n            this._partials[n - 1] = b;\n            break;\n          case \"sawtooth\":\n            b = piFactor * (n & 1 ? 1 : -1);\n            this._partials[n - 1] = b;\n            break;\n          case \"triangle\":\n            if (n & 1) {\n              b = 2 * (piFactor * piFactor) * (n - 1 >> 1 & 1 ? -1 : 1);\n            } else {\n              b = 0;\n            }\n            this._partials[n - 1] = b;\n            break;\n          case \"custom\":\n            b = this._partials[n - 1];\n            break;\n          default:\n            throw new TypeError(\"Oscillator: invalid type: \" + type);\n        }\n        if (b !== 0) {\n          real[n] = -b * Math.sin(phase * n);\n          imag[n] = b * Math.cos(phase * n);\n        } else {\n          real[n] = 0;\n          imag[n] = 0;\n        }\n      }\n      return [real, imag];\n    }\n    /**\n     * Compute the inverse FFT for a given phase.\n     */\n  }, {\n    key: \"_inverseFFT\",\n    value: function _inverseFFT(real, imag, phase) {\n      var sum = 0;\n      var len = real.length;\n      for (var i = 0; i < len; i++) {\n        sum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n      }\n      return sum;\n    }\n    /**\n     * Returns the initial value of the oscillator when stopped.\n     * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n     */\n  }, {\n    key: \"getInitialValue\",\n    value: function getInitialValue() {\n      var _this$_getRealImagina3 = this._getRealImaginary(this._type, 0),\n        _this$_getRealImagina4 = _slicedToArray(_this$_getRealImagina3, 2),\n        real = _this$_getRealImagina4[0],\n        imag = _this$_getRealImagina4[1];\n      var maxValue = 0;\n      var twoPi = Math.PI * 2;\n      var testPositions = 32;\n      // check for peaks in 16 places\n      for (var i = 0; i < testPositions; i++) {\n        maxValue = Math.max(this._inverseFFT(real, imag, i / testPositions * twoPi), maxValue);\n      }\n      return clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n    }\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._partials.slice(0, this.partialCount);\n    },\n    set: function set(partials) {\n      this._partials = partials;\n      this._partialCount = this._partials.length;\n      if (partials.length) {\n        this.type = \"custom\";\n      }\n    }\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._phase * (180 / Math.PI);\n    },\n    set: function set(phase) {\n      this._phase = phase * Math.PI / 180;\n      // reset the type\n      this.type = this._type;\n    }\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              return _context.abrupt(\"return\", generateWaveform(this, length));\n            case 1:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Oscillator.prototype), \"dispose\", this).call(this);\n      if (this._oscillator !== null) {\n        this._oscillator.dispose();\n      }\n      this._wave = undefined;\n      this.frequency.dispose();\n      this.detune.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Source.getDefaults(), {\n        detune: 0,\n        frequency: 440,\n        partialCount: 0,\n        partials: [],\n        phase: 0,\n        type: \"sine\"\n      });\n    }\n  }]);\n  return Oscillator;\n}(Source);\n/**\n * Cache the periodic waves to avoid having to redo computations\n */\nOscillator._periodicWaveCache = [];","map":{"version":3,"mappings":"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","names":["deepEquals","optionsFromArguments","readOnly","isDefined","Signal","Source","generateWaveform","ToneOscillatorNode","assertRange","clamp","Oscillator","getDefaults","arguments","options","frequency","context","units","value","detune","_partials","partials","_partialCount","partialCount","_type","type","baseType","toString","phase","time","computedTime","toSeconds","oscillator","onended","onstop","_oscillator","_wave","setPeriodicWave","connect","output","start","stop","log","cancelStop","_state","cancel","transport","syncSignal","unsyncSignal","oscProps","_periodicWaveCache","find","description","_phase","isBasicType","indexOf","undefined","cache","_getCachedPeriodicWave","wave","_getRealImaginary","real","imag","periodicWave","createPeriodicWave","push","length","shift","replace","p","partial","exec","fullPartials","Float32Array","forEach","v","i","Array","from","fftSize","periodicWaveSize","parseInt","Math","max","n","piFactor","PI","b","TypeError","sin","cos","sum","len","maxValue","twoPi","testPositions","_inverseFFT","slice","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\oscillator\\Oscillator.ts"],"sourcesContent":["import { AudioRange, Degrees, Frequency, Radians, Time } from \"../../core/type/Units\";\nimport { deepEquals, optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { isDefined } from \"../../core/util/TypeCheck\";\nimport { Signal } from \"../../signal/Signal\";\nimport { Source } from \"../Source\";\nimport {\n\tgenerateWaveform, ToneOscillatorConstructorOptions, ToneOscillatorInterface,\n\tToneOscillatorOptions, ToneOscillatorType\n} from \"./OscillatorInterface\";\nimport { ToneOscillatorNode } from \"./ToneOscillatorNode\";\nimport { assertRange } from \"../../core/util/Debug\";\nimport { clamp } from \"../../core/util/Math\";\nexport { ToneOscillatorOptions, ToneOscillatorType } from \"./OscillatorInterface\";\n/**\n * Oscillator supports a number of features including\n * phase rotation, multiple oscillator types (see Oscillator.type),\n * and Transport syncing (see Oscillator.syncFrequency).\n *\n * @example\n * // make and start a 440hz sine tone\n * const osc = new Tone.Oscillator(440, \"sine\").toDestination().start();\n * @category Source\n */\nexport class Oscillator extends Source<ToneOscillatorOptions> implements ToneOscillatorInterface {\n\n\treadonly name: string = \"Oscillator\";\n\n\t/**\n\t * the main oscillator\n\t */\n\tprivate _oscillator: ToneOscillatorNode | null = null;\n\n\t/**\n\t * The frequency control.\n\t */\n\tfrequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune control signal.\n\t */\n\tdetune: Signal<\"cents\">;\n\n\t/**\n\t * the periodic wave\n\t */\n\tprivate _wave?: PeriodicWave;\n\n\t/**\n\t * The partials of the oscillator\n\t */\n\tprivate _partials: number[];\n\n\t/**\n\t * The number of partials to limit or extend the periodic wave by\n\t */\n\tprivate _partialCount: number;\n\n\t/**\n\t * the phase of the oscillator between 0 - 360\n\t */\n\tprivate _phase!: Radians;\n\n\t/**\n\t * the type of the oscillator\n\t */\n\tprivate _type: ToneOscillatorType;\n\n\t/**\n\t * @param frequency Starting frequency\n\t * @param type The oscillator type. Read more about type below.\n\t */\n\tconstructor(frequency?: Frequency, type?: ToneOscillatorType);\n\tconstructor(options?: Partial<ToneOscillatorConstructorOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]));\n\t\tconst options = optionsFromArguments(Oscillator.getDefaults(), arguments, [\"frequency\", \"type\"]);\n\n\t\tthis.frequency = new Signal<\"frequency\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\tthis.detune = new Signal<\"cents\">({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"cents\",\n\t\t\tvalue: options.detune,\n\t\t});\n\t\treadOnly(this, \"detune\");\n\n\t\tthis._partials = options.partials;\n\t\tthis._partialCount = options.partialCount;\n\t\tthis._type = options.type;\n\n\t\tif (options.partialCount && options.type !== \"custom\") {\n\t\t\tthis._type = this.baseType + options.partialCount.toString() as ToneOscillatorType;\n\t\t}\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): ToneOscillatorOptions {\n\t\treturn Object.assign(Source.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tfrequency: 440,\n\t\t\tpartialCount: 0,\n\t\t\tpartials: [],\n\t\t\tphase: 0,\n\t\t\ttype: \"sine\" as const,\n\t\t});\n\t}\n\n\t/**\n\t * start the oscillator\n\t */\n\tprotected _start(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// new oscillator with previous values\n\t\tconst oscillator = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\tonended: () => this.onstop(this),\n\t\t});\n\t\tthis._oscillator = oscillator;\n\t\tif (this._wave) {\n\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t} else {\n\t\t\tthis._oscillator.type = this._type as OscillatorType;\n\t\t}\n\t\t// connect the control signal to the oscillator frequency & detune\n\t\tthis._oscillator.connect(this.output);\n\t\tthis.frequency.connect(this._oscillator.frequency);\n\t\tthis.detune.connect(this._oscillator.detune);\n\n\t\t// start the oscillator\n\t\tthis._oscillator.start(computedTime);\n\t}\n\n\t/**\n\t * stop the oscillator\n\t */\n\tprotected _stop(time?: Time): void {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.stop(computedTime);\n\t\t}\n\t}\n\n\t/**\n\t * Restart the oscillator. Does not stop the oscillator, but instead\n\t * just cancels any scheduled 'stop' from being invoked.\n\t */\n\tprotected _restart(time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tthis.log(\"restart\", computedTime);\n\t\tif (this._oscillator) {\n\t\t\tthis._oscillator.cancelStop();\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the signal to the Transport's bpm. Any changes to the transports bpm,\n\t * will also affect the oscillators frequency.\n\t * @example\n\t * const osc = new Tone.Oscillator().toDestination().start();\n\t * osc.frequency.value = 440;\n\t * // the ratio between the bpm and the frequency will be maintained\n\t * osc.syncFrequency();\n\t * // double the tempo\n\t * Tone.Transport.bpm.value *= 2;\n\t * // the frequency of the oscillator is doubled to 880\n\t */\n\tsyncFrequency(): this {\n\t\tthis.context.transport.syncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Unsync the oscillator's frequency from the Transport.\n\t * See Oscillator.syncFrequency\n\t */\n\tunsyncFrequency(): this {\n\t\tthis.context.transport.unsyncSignal(this.frequency);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cache the periodic waves to avoid having to redo computations\n\t */\n\tprivate static _periodicWaveCache: Array<{\n\t\tpartials: number[];\n\t\tphase: number;\n\t\ttype: string;\n\t\tpartialCount: number;\n\t\treal: Float32Array;\n\t\timag: Float32Array;\n\t\twave: PeriodicWave;\n\t}> = [];\n\n\t/**\n\t * Get a cached periodic wave. Avoids having to recompute\n\t * the oscillator values when they have already been computed\n\t * with the same values.\n\t */\n\tprivate _getCachedPeriodicWave(): { real: Float32Array; imag: Float32Array; partials: number[]; wave: PeriodicWave } | undefined {\n\t\tif (this._type === \"custom\") {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.phase === this._phase &&\n\t\t\t\t\tdeepEquals(description.partials, this._partials);\n\t\t\t});\n\t\t\treturn oscProps;\n\t\t} else {\n\t\t\tconst oscProps = Oscillator._periodicWaveCache.find(description => {\n\t\t\t\treturn description.type === this._type &&\n\t\t\t\t\tdescription.phase === this._phase;\n\t\t\t});\n\t\t\tthis._partialCount = oscProps ? oscProps.partialCount : this._partialCount;\n\t\t\treturn oscProps;\n\t\t}\n\t}\n\n\tget type(): ToneOscillatorType {\n\t\treturn this._type;\n\t}\n\tset type(type) {\n\t\tthis._type = type;\n\t\tconst isBasicType = [\"sine\", \"square\", \"sawtooth\", \"triangle\"].indexOf(type) !== -1;\n\t\tif (this._phase === 0 && isBasicType) {\n\t\t\tthis._wave = undefined;\n\t\t\tthis._partialCount = 0;\n\t\t\t// just go with the basic approach\n\t\t\tif (this._oscillator !== null) {\n\t\t\t\t// already tested that it's a basic type\n\t\t\t\tthis._oscillator.type = type as OscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// first check if the value is cached\n\t\t\tconst cache = this._getCachedPeriodicWave();\n\t\t\tif (isDefined(cache)) {\n\t\t\t\tconst { partials, wave } = cache;\n\t\t\t\tthis._wave = wave;\n\t\t\t\tthis._partials = partials;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tconst [real, imag] = this._getRealImaginary(type, this._phase);\n\t\t\t\tconst periodicWave = this.context.createPeriodicWave(real, imag);\n\t\t\t\tthis._wave = periodicWave;\n\t\t\t\tif (this._oscillator !== null) {\n\t\t\t\t\tthis._oscillator.setPeriodicWave(this._wave);\n\t\t\t\t}\n\t\t\t\t// set the cache\n\t\t\t\tOscillator._periodicWaveCache.push({\n\t\t\t\t\timag,\n\t\t\t\t\tpartialCount: this._partialCount,\n\t\t\t\t\tpartials: this._partials,\n\t\t\t\t\tphase: this._phase,\n\t\t\t\t\treal,\n\t\t\t\t\ttype: this._type,\n\t\t\t\t\twave: this._wave,\n\t\t\t\t});\n\t\t\t\tif (Oscillator._periodicWaveCache.length > 100) {\n\t\t\t\t\tOscillator._periodicWaveCache.shift();\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\n\tget baseType(): OscillatorType {\n\t\treturn (this._type as string).replace(this.partialCount.toString(), \"\") as OscillatorType;\n\t}\n\tset baseType(baseType) {\n\t\tif (this.partialCount && this._type !== \"custom\" && baseType !== \"custom\") {\n\t\t\tthis.type = baseType + this.partialCount as ToneOscillatorType;\n\t\t} else {\n\t\t\tthis.type = baseType;\n\t\t}\n\t}\n\n\tget partialCount(): number {\n\t\treturn this._partialCount;\n\t}\n\tset partialCount(p) {\n\t\tassertRange(p, 0);\n\t\tlet type = this._type;\n\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(this._type);\n\t\tif (partial) {\n\t\t\ttype = partial[1] as OscillatorType;\n\t\t}\n\t\tif (this._type !== \"custom\") {\n\t\t\tif (p === 0) {\n\t\t\t\tthis.type = type;\n\t\t\t} else {\n\t\t\t\tthis.type = type + p.toString() as ToneOscillatorType;\n\t\t\t}\n\t\t} else {\n\t\t\t// extend or shorten the partials array\n\t\t\tconst fullPartials = new Float32Array(p);\n\t\t\t// copy over the partials array\n\t\t\tthis._partials.forEach((v, i) => fullPartials[i] = v);\n\t\t\tthis._partials = Array.from(fullPartials);\n\t\t\tthis.type = this._type;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the real and imaginary components based\n\t * on the oscillator type.\n\t * @returns [real: Float32Array, imaginary: Float32Array]\n\t */\n\tprivate _getRealImaginary(type: ToneOscillatorType, phase: Radians): Float32Array[] {\n\t\tconst fftSize = 4096;\n\t\tlet periodicWaveSize = fftSize / 2;\n\n\t\tconst real = new Float32Array(periodicWaveSize);\n\t\tconst imag = new Float32Array(periodicWaveSize);\n\n\t\tlet partialCount = 1;\n\t\tif (type === \"custom\") {\n\t\t\tpartialCount = this._partials.length + 1;\n\t\t\tthis._partialCount = this._partials.length;\n\t\t\tperiodicWaveSize = partialCount;\n\t\t\t// if the partial count is 0, don't bother doing any computation\n\t\t\tif (this._partials.length === 0) {\n\t\t\t\treturn [real, imag];\n\t\t\t}\n\t\t} else {\n\t\t\tconst partial = /^(sine|triangle|square|sawtooth)(\\d+)$/.exec(type);\n\t\t\tif (partial) {\n\t\t\t\tpartialCount = parseInt(partial[2], 10) + 1;\n\t\t\t\tthis._partialCount = parseInt(partial[2], 10);\n\t\t\t\ttype = partial[1] as ToneOscillatorType;\n\t\t\t\tpartialCount = Math.max(partialCount, 2);\n\t\t\t\tperiodicWaveSize = partialCount;\n\t\t\t} else {\n\t\t\t\tthis._partialCount = 0;\n\t\t\t}\n\t\t\tthis._partials = [];\n\t\t}\n\n\t\tfor (let n = 1; n < periodicWaveSize; ++n) {\n\t\t\tconst piFactor = 2 / (n * Math.PI);\n\t\t\tlet b;\n\t\t\tswitch (type) {\n\t\t\t\tcase \"sine\":\n\t\t\t\t\tb = (n <= partialCount) ? 1 : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"square\":\n\t\t\t\t\tb = (n & 1) ? 2 * piFactor : 0;\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"sawtooth\":\n\t\t\t\t\tb = piFactor * ((n & 1) ? 1 : -1);\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"triangle\":\n\t\t\t\t\tif (n & 1) {\n\t\t\t\t\t\tb = 2 * (piFactor * piFactor) * ((((n - 1) >> 1) & 1) ? -1 : 1);\n\t\t\t\t\t} else {\n\t\t\t\t\t\tb = 0;\n\t\t\t\t\t}\n\t\t\t\t\tthis._partials[n - 1] = b;\n\t\t\t\t\tbreak;\n\t\t\t\tcase \"custom\":\n\t\t\t\t\tb = this._partials[n - 1];\n\t\t\t\t\tbreak;\n\t\t\t\tdefault:\n\t\t\t\t\tthrow new TypeError(\"Oscillator: invalid type: \" + type);\n\t\t\t}\n\t\t\tif (b !== 0) {\n\t\t\t\treal[n] = -b * Math.sin(phase * n);\n\t\t\t\timag[n] = b * Math.cos(phase * n);\n\t\t\t} else {\n\t\t\t\treal[n] = 0;\n\t\t\t\timag[n] = 0;\n\t\t\t}\n\t\t}\n\t\treturn [real, imag];\n\t}\n\n\t/**\n\t * Compute the inverse FFT for a given phase.\n\t */\n\tprivate _inverseFFT(real: Float32Array, imag: Float32Array, phase: Radians): number {\n\t\tlet sum = 0;\n\t\tconst len = real.length;\n\t\tfor (let i = 0; i < len; i++) {\n\t\t\tsum += real[i] * Math.cos(i * phase) + imag[i] * Math.sin(i * phase);\n\t\t}\n\t\treturn sum;\n\t}\n\n\t/**\n\t * Returns the initial value of the oscillator when stopped.\n\t * E.g. a \"sine\" oscillator with phase = 90 would return an initial value of -1.\n\t */\n\tgetInitialValue(): AudioRange {\n\t\tconst [real, imag] = this._getRealImaginary(this._type, 0);\n\t\tlet maxValue = 0;\n\t\tconst twoPi = Math.PI * 2;\n\t\tconst testPositions = 32;\n\t\t// check for peaks in 16 places\n\t\tfor (let i = 0; i < testPositions; i++) {\n\t\t\tmaxValue = Math.max(this._inverseFFT(real, imag, (i / testPositions) * twoPi), maxValue);\n\t\t}\n\t\treturn clamp(-this._inverseFFT(real, imag, this._phase) / maxValue, -1, 1);\n\t}\n\n\tget partials(): number[] {\n\t\treturn this._partials.slice(0, this.partialCount);\n\t}\n\tset partials(partials) {\n\t\tthis._partials = partials;\n\t\tthis._partialCount = this._partials.length;\n\t\tif (partials.length) {\n\t\t\tthis.type = \"custom\";\n\t\t}\n\t}\n\n\tget phase(): Degrees {\n\t\treturn this._phase * (180 / Math.PI);\n\t}\n\tset phase(phase) {\n\t\tthis._phase = phase * Math.PI / 180;\n\t\t// reset the type\n\t\tthis.type = this._type;\n\t}\n\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\treturn generateWaveform(this, length);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tif (this._oscillator !== null) {\n\t\t\tthis._oscillator.dispose();\n\t\t}\n\t\tthis._wave = undefined;\n\t\tthis.frequency.dispose();\n\t\tthis.detune.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import { interceptConnections } from './intercept-connections';\nexport var wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls = function wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls(nativeAudioScheduledSourceNode, nativeContext) {\n  var nativeGainNode = nativeContext.createGain();\n  nativeAudioScheduledSourceNode.connect(nativeGainNode);\n  var disconnectGainNode = function (disconnect) {\n    return function () {\n      // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n      disconnect.call(nativeAudioScheduledSourceNode, nativeGainNode);\n      nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n    };\n  }(nativeAudioScheduledSourceNode.disconnect);\n  nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n  interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n  nativeAudioScheduledSourceNode.stop = function (stop) {\n    var isStopped = false;\n    return function () {\n      var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n      if (isStopped) {\n        try {\n          stop.call(nativeAudioScheduledSourceNode, when);\n        } catch (_unused) {\n          nativeGainNode.gain.setValueAtTime(0, when);\n        }\n      } else {\n        stop.call(nativeAudioScheduledSourceNode, when);\n        isStopped = true;\n      }\n    };\n  }(nativeAudioScheduledSourceNode.stop);\n};","map":{"version":3,"mappings":"AACA,SAASA,oBAAoB,QAAQ,yBAAyB;AAE9D,OAAO,IAAMC,sDAAsD,GAAoE,SAA1HA,sDAAsD,CAC/DC,8BAA8B,EAC9BC,aAAa,EACb;EACA,IAAMC,cAAc,GAAGD,aAAa,CAACE,UAAU,EAAE;EAEjDH,8BAA8B,CAACI,OAAO,CAACF,cAAc,CAAC;EAEtD,IAAMG,kBAAkB,GAAI,UAACC,UAAU,EAAI;IACvC,OAAO,YAAK;MACR;MACyCA,UAAW,CAACC,IAAI,CAACP,8BAA8B,EAAEE,cAAc,CAAC;MACzGF,8BAA8B,CAACQ,mBAAmB,CAAC,OAAO,EAAEH,kBAAkB,CAAC;IACnF,CAAC;EACL,CAAC,CAAEL,8BAA8B,CAACM,UAAU,CAAC;EAE7CN,8BAA8B,CAACS,gBAAgB,CAAC,OAAO,EAAEJ,kBAAkB,CAAC;EAE5EP,oBAAoB,CAACE,8BAA8B,EAAEE,cAAc,CAAC;EAEpEF,8BAA8B,CAACU,IAAI,GAAI,UAACA,IAAI,EAAI;IAC5C,IAAIC,SAAS,GAAG,KAAK;IAErB,OAAO,YAAa;MAAA,IAAZC,IAAI,uEAAG,CAAC;MACZ,IAAID,SAAS,EAAE;QACX,IAAI;UACAD,IAAI,CAACH,IAAI,CAACP,8BAA8B,EAAEY,IAAI,CAAC;SAClD,CAAC,gBAAM;UACJV,cAAc,CAACW,IAAI,CAACC,cAAc,CAAC,CAAC,EAAEF,IAAI,CAAC;;OAElD,MAAM;QACHF,IAAI,CAACH,IAAI,CAACP,8BAA8B,EAAEY,IAAI,CAAC;QAE/CD,SAAS,GAAG,IAAI;;IAExB,CAAC;EACL,CAAC,CAAEX,8BAA8B,CAACU,IAAI,CAAC;AAC3C,CAAC","names":["interceptConnections","wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls","nativeAudioScheduledSourceNode","nativeContext","nativeGainNode","createGain","connect","disconnectGainNode","disconnect","call","removeEventListener","addEventListener","stop","isStopped","when","gain","setValueAtTime"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\helpers\\wrap-audio-scheduled-source-node-stop-method-consecutive-calls.ts"],"sourcesContent":["import { TNativeAudioNode, TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction } from '../types';\nimport { interceptConnections } from './intercept-connections';\n\nexport const wrapAudioScheduledSourceNodeStopMethodConsecutiveCalls: TWrapAudioScheduledSourceNodeStopMethodConsecutiveCallsFunction = (\n    nativeAudioScheduledSourceNode,\n    nativeContext\n) => {\n    const nativeGainNode = nativeContext.createGain();\n\n    nativeAudioScheduledSourceNode.connect(nativeGainNode);\n\n    const disconnectGainNode = ((disconnect) => {\n        return () => {\n            // @todo TypeScript cannot infer the overloaded signature with 1 argument yet.\n            (<(destinaton: TNativeAudioNode) => void>disconnect).call(nativeAudioScheduledSourceNode, nativeGainNode);\n            nativeAudioScheduledSourceNode.removeEventListener('ended', disconnectGainNode);\n        };\n    })(nativeAudioScheduledSourceNode.disconnect);\n\n    nativeAudioScheduledSourceNode.addEventListener('ended', disconnectGainNode);\n\n    interceptConnections(nativeAudioScheduledSourceNode, nativeGainNode);\n\n    nativeAudioScheduledSourceNode.stop = ((stop) => {\n        let isStopped = false;\n\n        return (when = 0) => {\n            if (isStopped) {\n                try {\n                    stop.call(nativeAudioScheduledSourceNode, when);\n                } catch {\n                    nativeGainNode.gain.setValueAtTime(0, when);\n                }\n            } else {\n                stop.call(nativeAudioScheduledSourceNode, when);\n\n                isStopped = true;\n            }\n        };\n    })(nativeAudioScheduledSourceNode.stop);\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
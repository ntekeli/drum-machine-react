{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport var Ticker = /*#__PURE__*/function () {\n  function Ticker(callback, type, updateInterval) {\n    _classCallCheck(this, Ticker);\n    this._callback = callback;\n    this._type = type;\n    this._updateInterval = updateInterval;\n    // create the clock source for the first time\n    this._createClock();\n  }\n  /**\n   * Generate a web worker\n   */\n  _createClass(Ticker, [{\n    key: \"_createWorker\",\n    value: function _createWorker() {\n      var blob = new Blob([/* javascript */\"\\n\\t\\t\\t// the initial timeout time\\n\\t\\t\\tlet timeoutTime =  \".concat((this._updateInterval * 1000).toFixed(1), \";\\n\\t\\t\\t// onmessage callback\\n\\t\\t\\tself.onmessage = function(msg){\\n\\t\\t\\t\\ttimeoutTime = parseInt(msg.data);\\n\\t\\t\\t};\\n\\t\\t\\t// the tick function which posts a message\\n\\t\\t\\t// and schedules a new tick\\n\\t\\t\\tfunction tick(){\\n\\t\\t\\t\\tsetTimeout(tick, timeoutTime);\\n\\t\\t\\t\\tself.postMessage('tick');\\n\\t\\t\\t}\\n\\t\\t\\t// call tick initially\\n\\t\\t\\ttick();\\n\\t\\t\\t\")], {\n        type: \"text/javascript\"\n      });\n      var blobUrl = URL.createObjectURL(blob);\n      var worker = new Worker(blobUrl);\n      worker.onmessage = this._callback.bind(this);\n      this._worker = worker;\n    }\n    /**\n     * Create a timeout loop\n     */\n  }, {\n    key: \"_createTimeout\",\n    value: function _createTimeout() {\n      var _this = this;\n      this._timeout = setTimeout(function () {\n        _this._createTimeout();\n        _this._callback();\n      }, this._updateInterval * 1000);\n    }\n    /**\n     * Create the clock source.\n     */\n  }, {\n    key: \"_createClock\",\n    value: function _createClock() {\n      if (this._type === \"worker\") {\n        try {\n          this._createWorker();\n        } catch (e) {\n          // workers not supported, fallback to timeout\n          this._type = \"timeout\";\n          this._createClock();\n        }\n      } else if (this._type === \"timeout\") {\n        this._createTimeout();\n      }\n    }\n    /**\n     * Clean up the current clock source\n     */\n  }, {\n    key: \"_disposeClock\",\n    value: function _disposeClock() {\n      if (this._timeout) {\n        clearTimeout(this._timeout);\n        this._timeout = 0;\n      }\n      if (this._worker) {\n        this._worker.terminate();\n        this._worker.onmessage = null;\n      }\n    }\n    /**\n     * The rate in seconds the ticker will update\n     */\n  }, {\n    key: \"updateInterval\",\n    get: function get() {\n      return this._updateInterval;\n    },\n    set: function set(interval) {\n      this._updateInterval = Math.max(interval, 128 / 44100);\n      if (this._type === \"worker\") {\n        this._worker.postMessage(Math.max(interval * 1000, 1));\n      }\n    }\n    /**\n     * The type of the ticker, either a worker or a timeout\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._type;\n    },\n    set: function set(type) {\n      this._disposeClock();\n      this._type = type;\n      this._createClock();\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      this._disposeClock();\n    }\n  }]);\n  return Ticker;\n}();","map":{"version":3,"mappings":";;AAIA;;;;AAIA,WAAaA,MAAM;EA2BlB,gBAAYC,QAAoB,EAAEC,IAAuB,EAAEC,cAAuB;IAAA;IAEjF,IAAI,CAACC,SAAS,GAAGH,QAAQ;IACzB,IAAI,CAACI,KAAK,GAAGH,IAAI;IACjB,IAAI,CAACI,eAAe,GAAGH,cAAc;IAErC;IACA,IAAI,CAACI,YAAY,EAAE;EACpB;EAEA;;;EAAA;IAAA;IAAA,OAGQ,yBAAa;MAEpB,IAAMC,IAAI,GAAG,IAAIC,IAAI,CAAC,CACrB,wFAEqB,CAAC,IAAI,CAACH,eAAe,GAAG,IAAI,EAAEI,OAAO,CAAC,CAAC,CAAC,sXAc7D,EAAE;QAAER,IAAI,EAAE;MAAiB,CAAE,CAAC;MAC/B,IAAMS,OAAO,GAAGC,GAAG,CAACC,eAAe,CAACL,IAAI,CAAC;MACzC,IAAMM,MAAM,GAAG,IAAIC,MAAM,CAACJ,OAAO,CAAC;MAElCG,MAAM,CAACE,SAAS,GAAG,IAAI,CAACZ,SAAS,CAACa,IAAI,CAAC,IAAI,CAAC;MAE5C,IAAI,CAACC,OAAO,GAAGJ,MAAM;IACtB;IAEA;;;EAAA;IAAA;IAAA,OAGQ,0BAAc;MAAA;MACrB,IAAI,CAACK,QAAQ,GAAGC,UAAU,CAAC,YAAK;QAC/B,KAAI,CAACC,cAAc,EAAE;QACrB,KAAI,CAACjB,SAAS,EAAE;MACjB,CAAC,EAAE,IAAI,CAACE,eAAe,GAAG,IAAI,CAAC;IAChC;IAEA;;;EAAA;IAAA;IAAA,OAGQ,wBAAY;MACnB,IAAI,IAAI,CAACD,KAAK,KAAK,QAAQ,EAAE;QAC5B,IAAI;UACH,IAAI,CAACiB,aAAa,EAAE;SACpB,CAAC,OAAOC,CAAC,EAAE;UACX;UACA,IAAI,CAAClB,KAAK,GAAG,SAAS;UACtB,IAAI,CAACE,YAAY,EAAE;;OAEpB,MAAM,IAAI,IAAI,CAACF,KAAK,KAAK,SAAS,EAAE;QACpC,IAAI,CAACgB,cAAc,EAAE;;IAEvB;IAEA;;;EAAA;IAAA;IAAA,OAGQ,yBAAa;MACpB,IAAI,IAAI,CAACF,QAAQ,EAAE;QAClBK,YAAY,CAAC,IAAI,CAACL,QAAQ,CAAC;QAC3B,IAAI,CAACA,QAAQ,GAAG,CAAC;;MAElB,IAAI,IAAI,CAACD,OAAO,EAAE;QACjB,IAAI,CAACA,OAAO,CAACO,SAAS,EAAE;QACxB,IAAI,CAACP,OAAO,CAACF,SAAS,GAAG,IAAI;;IAE/B;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAkB;MACjB,OAAO,IAAI,CAACV,eAAe;IAC5B,CAAC;IAAA,KACD,aAAmBoB,QAAiB;MACnC,IAAI,CAACpB,eAAe,GAAGqB,IAAI,CAACC,GAAG,CAACF,QAAQ,EAAE,GAAG,GAAG,KAAK,CAAC;MACtD,IAAI,IAAI,CAACrB,KAAK,KAAK,QAAQ,EAAE;QAC5B,IAAI,CAACa,OAAO,CAACW,WAAW,CAACF,IAAI,CAACC,GAAG,CAACF,QAAQ,GAAG,IAAI,EAAE,CAAC,CAAC,CAAC;;IAExD;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAQ;MACP,OAAO,IAAI,CAACrB,KAAK;IAClB,CAAC;IAAA,KACD,aAASH,IAAuB;MAC/B,IAAI,CAAC4B,aAAa,EAAE;MACpB,IAAI,CAACzB,KAAK,GAAGH,IAAI;MACjB,IAAI,CAACK,YAAY,EAAE;IACpB;IAEA;;;EAAA;IAAA;IAAA,OAGA,mBAAO;MACN,IAAI,CAACuB,aAAa,EAAE;IACrB;EAAC;EAAA;AAAA","names":["Ticker","callback","type","updateInterval","_callback","_type","_updateInterval","_createClock","blob","Blob","toFixed","blobUrl","URL","createObjectURL","worker","Worker","onmessage","bind","_worker","_timeout","setTimeout","_createTimeout","_createWorker","e","clearTimeout","terminate","interval","Math","max","postMessage","_disposeClock"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\Ticker.ts"],"sourcesContent":["import { Seconds } from \"../type/Units\";\n\nexport type TickerClockSource = \"worker\" | \"timeout\" | \"offline\";\n\n/**\n * A class which provides a reliable callback using either\n * a Web Worker, or if that isn't supported, falls back to setTimeout.\n */\nexport class Ticker {\n\n\t/**\n\t * Either \"worker\" or \"timeout\" or \"offline\"\n\t */\n\tprivate _type: TickerClockSource;\n\n\t/**\n\t * The update interval of the worker\n\t */\n\tprivate _updateInterval: Seconds;\n\n\t/**\n\t * The callback to invoke at regular intervals\n\t */\n\tprivate _callback: () => void;\n\n\t/**\n\t * track the callback interval\n\t */\n\tprivate _timeout!: ReturnType<typeof setTimeout>;\n\n\t/**\n\t * private reference to the worker\n\t */\n\tprivate _worker!: Worker;\n\n\tconstructor(callback: () => void, type: TickerClockSource, updateInterval: Seconds) {\n\n\t\tthis._callback = callback;\n\t\tthis._type = type;\n\t\tthis._updateInterval = updateInterval;\n\n\t\t// create the clock source for the first time\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Generate a web worker\n\t */\n\tprivate _createWorker(): void {\n\n\t\tconst blob = new Blob([\n\t\t\t/* javascript */`\n\t\t\t// the initial timeout time\n\t\t\tlet timeoutTime =  ${(this._updateInterval * 1000).toFixed(1)};\n\t\t\t// onmessage callback\n\t\t\tself.onmessage = function(msg){\n\t\t\t\ttimeoutTime = parseInt(msg.data);\n\t\t\t};\n\t\t\t// the tick function which posts a message\n\t\t\t// and schedules a new tick\n\t\t\tfunction tick(){\n\t\t\t\tsetTimeout(tick, timeoutTime);\n\t\t\t\tself.postMessage('tick');\n\t\t\t}\n\t\t\t// call tick initially\n\t\t\ttick();\n\t\t\t`\n\t\t], { type: \"text/javascript\" });\n\t\tconst blobUrl = URL.createObjectURL(blob);\n\t\tconst worker = new Worker(blobUrl);\n\n\t\tworker.onmessage = this._callback.bind(this);\n\n\t\tthis._worker = worker;\n\t}\n\n\t/**\n\t * Create a timeout loop\n\t */\n\tprivate _createTimeout(): void {\n\t\tthis._timeout = setTimeout(() => {\n\t\t\tthis._createTimeout();\n\t\t\tthis._callback();\n\t\t}, this._updateInterval * 1000);\n\t}\n\n\t/**\n\t * Create the clock source.\n\t */\n\tprivate _createClock(): void {\n\t\tif (this._type === \"worker\") {\n\t\t\ttry {\n\t\t\t\tthis._createWorker();\n\t\t\t} catch (e) {\n\t\t\t\t// workers not supported, fallback to timeout\n\t\t\t\tthis._type = \"timeout\";\n\t\t\t\tthis._createClock();\n\t\t\t}\n\t\t} else if (this._type === \"timeout\") {\n\t\t\tthis._createTimeout();\n\t\t}\n\t}\n\n\t/**\n\t * Clean up the current clock source\n\t */\n\tprivate _disposeClock(): void {\n\t\tif (this._timeout) {\n\t\t\tclearTimeout(this._timeout);\n\t\t\tthis._timeout = 0;\n\t\t}\n\t\tif (this._worker) {\n\t\t\tthis._worker.terminate();\n\t\t\tthis._worker.onmessage = null;\n\t\t}\n\t}\n\n\t/**\n\t * The rate in seconds the ticker will update\n\t */\n\tget updateInterval(): Seconds {\n\t\treturn this._updateInterval;\n\t}\n\tset updateInterval(interval: Seconds) {\n\t\tthis._updateInterval = Math.max(interval, 128 / 44100);\n\t\tif (this._type === \"worker\") {\n\t\t\tthis._worker.postMessage(Math.max(interval * 1000, 1));\n\t\t}\n\t}\n\n\t/**\n\t * The type of the ticker, either a worker or a timeout\n\t */\n\tget type(): TickerClockSource {\n\t\treturn this._type;\n\t}\n\tset type(type: TickerClockSource) {\n\t\tthis._disposeClock();\n\t\tthis._type = type;\n\t\tthis._createClock();\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): void {\n\t\tthis._disposeClock();\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
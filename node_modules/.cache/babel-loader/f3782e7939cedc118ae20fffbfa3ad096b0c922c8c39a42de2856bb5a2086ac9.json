{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport _toConsumableArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _createForOfIteratorHelper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _slicedToArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/slicedToArray.js\";\nimport { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nvar addConnectionToAudioParamOfAudioContext = function addConnectionToAudioParamOfAudioContext(source, destination, output, isOffline) {\n  var _getAudioParamConnect = getAudioParamConnections(destination),\n    activeInputs = _getAudioParamConnect.activeInputs,\n    passiveInputs = _getAudioParamConnect.passiveInputs;\n  var _getAudioNodeConnecti = getAudioNodeConnections(source),\n    outputs = _getAudioNodeConnecti.outputs;\n  var eventListeners = getEventListenersOfAudioNode(source);\n  var eventListener = function eventListener(isActive) {\n    var nativeAudioNode = getNativeAudioNode(source);\n    var nativeAudioParam = getNativeAudioParam(destination);\n    if (isActive) {\n      var partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n      addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.connect(nativeAudioParam, output);\n      }\n    } else {\n      var _partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n      addPassiveInputConnectionToAudioParam(passiveInputs, _partialConnection, false);\n      if (!isOffline && !isPartOfACycle(source)) {\n        nativeAudioNode.disconnect(nativeAudioParam, output);\n      }\n    }\n  };\n  if (insertElementInSet(outputs, [destination, output], function (outputConnection) {\n    return outputConnection[0] === destination && outputConnection[1] === output;\n  }, true)) {\n    eventListeners.add(eventListener);\n    if (isActiveAudioNode(source)) {\n      addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n    } else {\n      addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n    }\n    return true;\n  }\n  return false;\n};\nvar deleteInputConnectionOfAudioNode = function deleteInputConnectionOfAudioNode(source, destination, output, input) {\n  var _getAudioNodeConnecti2 = getAudioNodeConnections(destination),\n    activeInputs = _getAudioNodeConnecti2.activeInputs,\n    passiveInputs = _getAudioNodeConnecti2.passiveInputs;\n  var activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n    return [passiveInputConnection[2], false];\n  }\n  return [activeInputConnection[2], true];\n};\nvar deleteInputConnectionOfAudioParam = function deleteInputConnectionOfAudioParam(source, destination, output) {\n  var _getAudioParamConnect2 = getAudioParamConnections(destination),\n    activeInputs = _getAudioParamConnect2.activeInputs,\n    passiveInputs = _getAudioParamConnect2.passiveInputs;\n  var activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n  if (activeInputConnection === null) {\n    var passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n    return [passiveInputConnection[1], false];\n  }\n  return [activeInputConnection[2], true];\n};\nvar deleteInputsOfAudioNode = function deleteInputsOfAudioNode(source, isOffline, destination, output, input) {\n  var _deleteInputConnectio = deleteInputConnectionOfAudioNode(source, destination, output, input),\n    _deleteInputConnectio2 = _slicedToArray(_deleteInputConnectio, 2),\n    listener = _deleteInputConnectio2[0],\n    isActive = _deleteInputConnectio2[1];\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n    }\n  }\n  if (isActiveAudioNode(destination)) {\n    var _getAudioNodeConnecti3 = getAudioNodeConnections(destination),\n      activeInputs = _getAudioNodeConnecti3.activeInputs;\n    setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n  }\n};\nvar deleteInputsOfAudioParam = function deleteInputsOfAudioParam(source, isOffline, destination, output) {\n  var _deleteInputConnectio3 = deleteInputConnectionOfAudioParam(source, destination, output),\n    _deleteInputConnectio4 = _slicedToArray(_deleteInputConnectio3, 2),\n    listener = _deleteInputConnectio4[0],\n    isActive = _deleteInputConnectio4[1];\n  if (listener !== null) {\n    deleteEventListenerOfAudioNode(source, listener);\n    if (isActive && !isOffline && !isPartOfACycle(source)) {\n      getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n    }\n  }\n};\nvar deleteAnyConnection = function deleteAnyConnection(source, isOffline) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n  var _iterator = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n    _step;\n  try {\n    for (_iterator.s(); !(_step = _iterator.n()).done;) {\n      var outputConnection = _step.value;\n      if (isAudioNodeOutputConnection(outputConnection)) {\n        deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      } else {\n        deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n      }\n      destinations.push(outputConnection[0]);\n    }\n  } catch (err) {\n    _iterator.e(err);\n  } finally {\n    _iterator.f();\n  }\n  audioNodeConnectionsOfSource.outputs.clear();\n  return destinations;\n};\nvar deleteConnectionAtOutput = function deleteConnectionAtOutput(source, isOffline, output) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  var destinations = [];\n  var _iterator2 = _createForOfIteratorHelper(audioNodeConnectionsOfSource.outputs),\n    _step2;\n  try {\n    for (_iterator2.s(); !(_step2 = _iterator2.n()).done;) {\n      var outputConnection = _step2.value;\n      if (outputConnection[1] === output) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n          deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        } else {\n          deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n        }\n        destinations.push(outputConnection[0]);\n        audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n      }\n    }\n  } catch (err) {\n    _iterator2.e(err);\n  } finally {\n    _iterator2.f();\n  }\n  return destinations;\n};\nvar deleteConnectionToDestination = function deleteConnectionToDestination(source, isOffline, destination, output, input) {\n  var audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n  return Array.from(audioNodeConnectionsOfSource.outputs).filter(function (outputConnection) {\n    return outputConnection[0] === destination && (output === undefined || outputConnection[1] === output) && (input === undefined || outputConnection[2] === input);\n  }).map(function (outputConnection) {\n    if (isAudioNodeOutputConnection(outputConnection)) {\n      deleteInputsOfAudioNode.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    } else {\n      deleteInputsOfAudioParam.apply(void 0, [source, isOffline].concat(_toConsumableArray(outputConnection)));\n    }\n    audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n    return outputConnection[0];\n  });\n};\nexport var createAudioNodeConstructor = function createAudioNodeConstructor(addAudioNodeConnections, addConnectionToAudioNode, cacheTestResult, createIncrementCycleCounter, createIndexSizeError, createInvalidAccessError, createNotSupportedError, decrementCycleCounter, detectCycles, eventTargetConstructor, getNativeContext, isNativeAudioContext, isNativeAudioNode, isNativeAudioParam, isNativeOfflineAudioContext, nativeAudioWorkletNodeConstructor) {\n  return /*#__PURE__*/function (_eventTargetConstruct) {\n    _inherits(AudioNode, _eventTargetConstruct);\n    var _super = _createSuper(AudioNode);\n    function AudioNode(context, isActive, nativeAudioNode, audioNodeRenderer) {\n      var _this;\n      _classCallCheck(this, AudioNode);\n      _this = _super.call(this, nativeAudioNode);\n      _this._context = context;\n      _this._nativeAudioNode = nativeAudioNode;\n      var nativeContext = getNativeContext(context);\n      // Bug #12: Safari does not support to disconnect a specific destination.\n      if (isNativeAudioContext(nativeContext) && true !== cacheTestResult(testAudioNodeDisconnectMethodSupport, function () {\n        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n      })) {\n        wrapAudioNodeDisconnectMethod(nativeAudioNode);\n      }\n      AUDIO_NODE_STORE.set(_assertThisInitialized(_this), nativeAudioNode);\n      EVENT_LISTENERS.set(_assertThisInitialized(_this), new Set());\n      if (context.state !== 'closed' && isActive) {\n        setInternalStateToActive(_assertThisInitialized(_this));\n      }\n      addAudioNodeConnections(_assertThisInitialized(_this), audioNodeRenderer, nativeAudioNode);\n      return _this;\n    }\n    _createClass(AudioNode, [{\n      key: \"channelCount\",\n      get: function get() {\n        return this._nativeAudioNode.channelCount;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCount = value;\n      }\n    }, {\n      key: \"channelCountMode\",\n      get: function get() {\n        return this._nativeAudioNode.channelCountMode;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelCountMode = value;\n      }\n    }, {\n      key: \"channelInterpretation\",\n      get: function get() {\n        return this._nativeAudioNode.channelInterpretation;\n      },\n      set: function set(value) {\n        this._nativeAudioNode.channelInterpretation = value;\n      }\n    }, {\n      key: \"context\",\n      get: function get() {\n        return this._context;\n      }\n    }, {\n      key: \"numberOfInputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfInputs;\n      }\n    }, {\n      key: \"numberOfOutputs\",\n      get: function get() {\n        return this._nativeAudioNode.numberOfOutputs;\n      }\n      // tslint:disable-next-line:invalid-void\n    }, {\n      key: \"connect\",\n      value: function connect(destination) {\n        var output = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var input = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n        // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n        if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n          throw createIndexSizeError();\n        }\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n          throw createInvalidAccessError();\n        }\n        if (isAudioNode(destination)) {\n          var nativeDestinationAudioNode = getNativeAudioNode(destination);\n          try {\n            var connection = connectNativeAudioNodeToNativeAudioNode(this._nativeAudioNode, nativeDestinationAudioNode, output, input);\n            var isPassive = isPassiveAudioNode(this);\n            if (isOffline || isPassive) {\n              var _this$_nativeAudioNod;\n              (_this$_nativeAudioNod = this._nativeAudioNode).disconnect.apply(_this$_nativeAudioNod, _toConsumableArray(connection));\n            }\n            if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n              setInternalStateToActive(destination);\n            }\n          } catch (err) {\n            // Bug #41: Safari does not throw the correct exception so far.\n            if (err.code === 12) {\n              throw createInvalidAccessError();\n            }\n            throw err;\n          }\n          var isNewConnectionToAudioNode = addConnectionToAudioNode(this, destination, output, input, isOffline);\n          // Bug #164: Only Firefox detects cycles so far.\n          if (isNewConnectionToAudioNode) {\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n          }\n          return destination;\n        }\n        var nativeAudioParam = getNativeAudioParam(destination);\n        /*\n         * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n         * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n         * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n         */\n        if (nativeAudioParam.name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n          throw createNotSupportedError();\n        }\n        try {\n          this._nativeAudioNode.connect(nativeAudioParam, output);\n          if (isOffline || isPassiveAudioNode(this)) {\n            this._nativeAudioNode.disconnect(nativeAudioParam, output);\n          }\n        } catch (err) {\n          // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n          if (err.code === 12) {\n            throw createInvalidAccessError();\n          }\n          throw err;\n        }\n        var isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n        // Bug #164: Only Firefox detects cycles so far.\n        if (isNewConnectionToAudioParam) {\n          var _cycles = detectCycles([this], destination);\n          visitEachAudioNodeOnce(_cycles, createIncrementCycleCounter(isOffline));\n        }\n      }\n    }, {\n      key: \"disconnect\",\n      value: function disconnect(destinationOrOutput, output, input) {\n        var destinations;\n        var nativeContext = getNativeContext(this._context);\n        var isOffline = isNativeOfflineAudioContext(nativeContext);\n        if (destinationOrOutput === undefined) {\n          destinations = deleteAnyConnection(this, isOffline);\n        } else if (typeof destinationOrOutput === 'number') {\n          if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n            throw createIndexSizeError();\n          }\n          destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n        } else {\n          if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n            throw createIndexSizeError();\n          }\n          if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n            throw createIndexSizeError();\n          }\n          destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n          if (destinations.length === 0) {\n            throw createInvalidAccessError();\n          }\n        }\n        // Bug #164: Only Firefox detects cycles so far.\n        var _iterator3 = _createForOfIteratorHelper(destinations),\n          _step3;\n        try {\n          for (_iterator3.s(); !(_step3 = _iterator3.n()).done;) {\n            var destination = _step3.value;\n            var cycles = detectCycles([this], destination);\n            visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n          }\n        } catch (err) {\n          _iterator3.e(err);\n        } finally {\n          _iterator3.f();\n        }\n      }\n    }]);\n    return AudioNode;\n  }(eventTargetConstructor);\n};","map":{"version":3,"mappings":"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","names":["AUDIO_NODE_STORE","EVENT_LISTENERS","isAudioNode","isAudioNodeOutputConnection","addActiveInputConnectionToAudioParam","addPassiveInputConnectionToAudioParam","connectNativeAudioNodeToNativeAudioNode","deleteActiveInputConnection","deleteActiveInputConnectionToAudioParam","deleteEventListenerOfAudioNode","deletePassiveInputConnectionToAudioNode","deletePassiveInputConnectionToAudioParam","disconnectNativeAudioNodeFromNativeAudioNode","getAudioNodeConnections","getAudioParamConnections","getEventListenersOfAudioNode","getNativeAudioNode","getNativeAudioParam","insertElementInSet","isActiveAudioNode","isPartOfACycle","isPassiveAudioNode","setInternalStateToActive","setInternalStateToPassiveWhenNecessary","testAudioNodeDisconnectMethodSupport","visitEachAudioNodeOnce","wrapAudioNodeDisconnectMethod","addConnectionToAudioParamOfAudioContext","source","destination","output","isOffline","activeInputs","passiveInputs","outputs","eventListeners","eventListener","isActive","nativeAudioNode","nativeAudioParam","partialConnection","connect","disconnect","outputConnection","add","deleteInputConnectionOfAudioNode","input","activeInputConnection","passiveInputConnection","deleteInputConnectionOfAudioParam","deleteInputsOfAudioNode","listener","deleteInputsOfAudioParam","deleteAnyConnection","audioNodeConnectionsOfSource","destinations","push","clear","deleteConnectionAtOutput","delete","deleteConnectionToDestination","Array","from","filter","undefined","map","createAudioNodeConstructor","addAudioNodeConnections","addConnectionToAudioNode","cacheTestResult","createIncrementCycleCounter","createIndexSizeError","createInvalidAccessError","createNotSupportedError","decrementCycleCounter","detectCycles","eventTargetConstructor","getNativeContext","isNativeAudioContext","isNativeAudioNode","isNativeAudioParam","isNativeOfflineAudioContext","nativeAudioWorkletNodeConstructor","context","audioNodeRenderer","_context","_nativeAudioNode","nativeContext","set","Set","state","channelCount","value","channelCountMode","channelInterpretation","numberOfInputs","numberOfOutputs","nativeDestinationAudioNode","connection","isPassive","err","code","isNewConnectionToAudioNode","cycles","name","maxValue","isNewConnectionToAudioParam","destinationOrOutput","length"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-node-constructor.ts"],"sourcesContent":["import { AUDIO_NODE_STORE, EVENT_LISTENERS } from '../globals';\nimport { isAudioNode } from '../guards/audio-node';\nimport { isAudioNodeOutputConnection } from '../guards/audio-node-output-connection';\nimport { addActiveInputConnectionToAudioParam } from '../helpers/add-active-input-connection-to-audio-param';\nimport { addPassiveInputConnectionToAudioParam } from '../helpers/add-passive-input-connection-to-audio-param';\nimport { connectNativeAudioNodeToNativeAudioNode } from '../helpers/connect-native-audio-node-to-native-audio-node';\nimport { deleteActiveInputConnection } from '../helpers/delete-active-input-connection';\nimport { deleteActiveInputConnectionToAudioParam } from '../helpers/delete-active-input-connection-to-audio-param';\nimport { deleteEventListenerOfAudioNode } from '../helpers/delete-event-listeners-of-audio-node';\nimport { deletePassiveInputConnectionToAudioNode } from '../helpers/delete-passive-input-connection-to-audio-node';\nimport { deletePassiveInputConnectionToAudioParam } from '../helpers/delete-passive-input-connection-to-audio-param';\nimport { disconnectNativeAudioNodeFromNativeAudioNode } from '../helpers/disconnect-native-audio-node-from-native-audio-node';\nimport { getAudioNodeConnections } from '../helpers/get-audio-node-connections';\nimport { getAudioParamConnections } from '../helpers/get-audio-param-connections';\nimport { getEventListenersOfAudioNode } from '../helpers/get-event-listeners-of-audio-node';\nimport { getNativeAudioNode } from '../helpers/get-native-audio-node';\nimport { getNativeAudioParam } from '../helpers/get-native-audio-param';\nimport { insertElementInSet } from '../helpers/insert-element-in-set';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { isPartOfACycle } from '../helpers/is-part-of-a-cycle';\nimport { isPassiveAudioNode } from '../helpers/is-passive-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassiveWhenNecessary } from '../helpers/set-internal-state-to-passive-when-necessary';\nimport { testAudioNodeDisconnectMethodSupport } from '../helpers/test-audio-node-disconnect-method-support';\nimport { visitEachAudioNodeOnce } from '../helpers/visit-each-audio-node-once';\nimport { wrapAudioNodeDisconnectMethod } from '../helpers/wrap-audio-node-disconnect-method';\nimport {\n    IAudioNode,\n    IAudioNodeRenderer,\n    IAudioParam,\n    IMinimalOfflineAudioContext,\n    INativeAudioNodeFaker,\n    IOfflineAudioContext\n} from '../interfaces';\nimport {\n    TAudioNodeConstructorFactory,\n    TChannelCountMode,\n    TChannelInterpretation,\n    TContext,\n    TInternalStateEventListener,\n    TNativeAudioNode,\n    TNativeAudioParam\n} from '../types';\n\nconst addConnectionToAudioParamOfAudioContext = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number,\n    isOffline: boolean\n): boolean => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n    const { outputs } = getAudioNodeConnections(source);\n    const eventListeners = getEventListenersOfAudioNode(source);\n\n    const eventListener: TInternalStateEventListener = (isActive) => {\n        const nativeAudioNode = getNativeAudioNode(source);\n        const nativeAudioParam = getNativeAudioParam(destination);\n\n        if (isActive) {\n            const partialConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n            addActiveInputConnectionToAudioParam(activeInputs, source, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.connect(nativeAudioParam, output);\n            }\n        } else {\n            const partialConnection = deleteActiveInputConnectionToAudioParam(activeInputs, source, output);\n\n            addPassiveInputConnectionToAudioParam(passiveInputs, partialConnection, false);\n\n            if (!isOffline && !isPartOfACycle(source)) {\n                nativeAudioNode.disconnect(nativeAudioParam, output);\n            }\n        }\n    };\n\n    if (\n        insertElementInSet(\n            outputs,\n            [destination, output],\n            (outputConnection) => outputConnection[0] === destination && outputConnection[1] === output,\n            true\n        )\n    ) {\n        eventListeners.add(eventListener);\n\n        if (isActiveAudioNode(source)) {\n            addActiveInputConnectionToAudioParam(activeInputs, source, [output, eventListener], true);\n        } else {\n            addPassiveInputConnectionToAudioParam(passiveInputs, [source, output, eventListener], true);\n        }\n\n        return true;\n    }\n\n    return false;\n};\n\nconst deleteInputConnectionOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioNodeConnections(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs[input], source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioNode(passiveInputs, source, output, input);\n\n        return [passiveInputConnection[2], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputConnectionOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    destination: IAudioParam,\n    output: number\n): [null | TInternalStateEventListener, boolean] => {\n    const { activeInputs, passiveInputs } = getAudioParamConnections<T>(destination);\n\n    const activeInputConnection = deleteActiveInputConnection(activeInputs, source, output);\n\n    if (activeInputConnection === null) {\n        const passiveInputConnection = deletePassiveInputConnectionToAudioParam(passiveInputs, source, output);\n\n        return [passiveInputConnection[1], false];\n    }\n\n    return [activeInputConnection[2], true];\n};\n\nconst deleteInputsOfAudioNode = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<T>,\n    output: number,\n    input: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioNode(source, destination, output, input);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            disconnectNativeAudioNodeFromNativeAudioNode(getNativeAudioNode(source), getNativeAudioNode(destination), output, input);\n        }\n    }\n\n    if (isActiveAudioNode(destination)) {\n        const { activeInputs } = getAudioNodeConnections(destination);\n\n        setInternalStateToPassiveWhenNecessary(destination, activeInputs);\n    }\n};\n\nconst deleteInputsOfAudioParam = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioParam,\n    output: number\n) => {\n    const [listener, isActive] = deleteInputConnectionOfAudioParam(source, destination, output);\n\n    if (listener !== null) {\n        deleteEventListenerOfAudioNode(source, listener);\n\n        if (isActive && !isOffline && !isPartOfACycle(source)) {\n            getNativeAudioNode(source).disconnect(getNativeAudioParam(destination), output);\n        }\n    }\n};\n\nconst deleteAnyConnection = <T extends TContext>(source: IAudioNode<T>, isOffline: boolean): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (isAudioNodeOutputConnection(outputConnection)) {\n            deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n        } else {\n            deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n        }\n\n        destinations.push(outputConnection[0]);\n    }\n\n    audioNodeConnectionsOfSource.outputs.clear();\n\n    return destinations;\n};\n\nconst deleteConnectionAtOutput = <T extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    output: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n    const destinations = [];\n\n    for (const outputConnection of audioNodeConnectionsOfSource.outputs) {\n        if (outputConnection[1] === output) {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            destinations.push(outputConnection[0]);\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n        }\n    }\n\n    return destinations;\n};\n\nconst deleteConnectionToDestination = <T extends TContext, U extends TContext>(\n    source: IAudioNode<T>,\n    isOffline: boolean,\n    destination: IAudioNode<U> | IAudioParam,\n    output?: number,\n    input?: number\n): (IAudioNode<T> | IAudioParam)[] => {\n    const audioNodeConnectionsOfSource = getAudioNodeConnections(source);\n\n    return Array.from(audioNodeConnectionsOfSource.outputs)\n        .filter(\n            (outputConnection) =>\n                outputConnection[0] === destination &&\n                (output === undefined || outputConnection[1] === output) &&\n                (input === undefined || outputConnection[2] === input)\n        )\n        .map((outputConnection) => {\n            if (isAudioNodeOutputConnection(outputConnection)) {\n                deleteInputsOfAudioNode(source, isOffline, ...outputConnection);\n            } else {\n                deleteInputsOfAudioParam(source, isOffline, ...outputConnection);\n            }\n\n            audioNodeConnectionsOfSource.outputs.delete(outputConnection);\n\n            return outputConnection[0];\n        });\n};\n\nexport const createAudioNodeConstructor: TAudioNodeConstructorFactory = (\n    addAudioNodeConnections,\n    addConnectionToAudioNode,\n    cacheTestResult,\n    createIncrementCycleCounter,\n    createIndexSizeError,\n    createInvalidAccessError,\n    createNotSupportedError,\n    decrementCycleCounter,\n    detectCycles,\n    eventTargetConstructor,\n    getNativeContext,\n    isNativeAudioContext,\n    isNativeAudioNode,\n    isNativeAudioParam,\n    isNativeOfflineAudioContext,\n    nativeAudioWorkletNodeConstructor\n) => {\n    return class AudioNode<T extends TContext, EventMap extends Record<string, Event> = {}>\n        extends eventTargetConstructor<EventMap>\n        implements IAudioNode<T, EventMap>\n    {\n        private _context: T;\n\n        private _nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode;\n\n        constructor(\n            context: T,\n            isActive: boolean,\n            nativeAudioNode: INativeAudioNodeFaker | TNativeAudioNode,\n            audioNodeRenderer: T extends IMinimalOfflineAudioContext | IOfflineAudioContext ? IAudioNodeRenderer<T, IAudioNode<T>> : null\n        ) {\n            super(nativeAudioNode);\n\n            this._context = context;\n            this._nativeAudioNode = nativeAudioNode;\n\n            const nativeContext = getNativeContext(context);\n\n            // Bug #12: Safari does not support to disconnect a specific destination.\n            if (\n                isNativeAudioContext(nativeContext) &&\n                true !==\n                    cacheTestResult(testAudioNodeDisconnectMethodSupport, () => {\n                        return testAudioNodeDisconnectMethodSupport(nativeContext, nativeAudioWorkletNodeConstructor);\n                    })\n            ) {\n                wrapAudioNodeDisconnectMethod(nativeAudioNode);\n            }\n\n            AUDIO_NODE_STORE.set(this, nativeAudioNode);\n            EVENT_LISTENERS.set(this, new Set());\n\n            if (context.state !== 'closed' && isActive) {\n                setInternalStateToActive(this);\n            }\n\n            addAudioNodeConnections(this, audioNodeRenderer, nativeAudioNode);\n        }\n\n        get channelCount(): number {\n            return this._nativeAudioNode.channelCount;\n        }\n\n        set channelCount(value) {\n            this._nativeAudioNode.channelCount = value;\n        }\n\n        get channelCountMode(): TChannelCountMode {\n            return this._nativeAudioNode.channelCountMode;\n        }\n\n        set channelCountMode(value) {\n            this._nativeAudioNode.channelCountMode = value;\n        }\n\n        get channelInterpretation(): TChannelInterpretation {\n            return this._nativeAudioNode.channelInterpretation;\n        }\n\n        set channelInterpretation(value) {\n            this._nativeAudioNode.channelInterpretation = value;\n        }\n\n        get context(): T {\n            return this._context;\n        }\n\n        get numberOfInputs(): number {\n            return this._nativeAudioNode.numberOfInputs;\n        }\n\n        get numberOfOutputs(): number {\n            return this._nativeAudioNode.numberOfOutputs;\n        }\n\n        public connect<U extends TContext, V extends IAudioNode<U>>(destinationNode: V, output?: number, input?: number): V;\n        public connect(destinationParam: IAudioParam, output?: number): void;\n        // tslint:disable-next-line:invalid-void\n        public connect<U extends TContext, V extends IAudioNode<U>>(destination: V | IAudioParam, output = 0, input = 0): void | V {\n            // Bug #174: Safari does expose a wrong numberOfOutputs for MediaStreamAudioDestinationNodes.\n            if (output < 0 || output >= this._nativeAudioNode.numberOfOutputs) {\n                throw createIndexSizeError();\n            }\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (isNativeAudioNode(destination) || isNativeAudioParam(destination)) {\n                throw createInvalidAccessError();\n            }\n\n            if (isAudioNode(destination)) {\n                const nativeDestinationAudioNode = getNativeAudioNode(destination);\n\n                try {\n                    const connection = connectNativeAudioNodeToNativeAudioNode(\n                        this._nativeAudioNode,\n                        nativeDestinationAudioNode,\n                        output,\n                        input\n                    );\n\n                    const isPassive = isPassiveAudioNode(this);\n\n                    if (isOffline || isPassive) {\n                        this._nativeAudioNode.disconnect(...connection);\n                    }\n\n                    if (this.context.state !== 'closed' && !isPassive && isPassiveAudioNode(destination)) {\n                        setInternalStateToActive(destination);\n                    }\n                } catch (err) {\n                    // Bug #41: Safari does not throw the correct exception so far.\n                    if (err.code === 12) {\n                        throw createInvalidAccessError();\n                    }\n\n                    throw err;\n                }\n\n                const isNewConnectionToAudioNode = addConnectionToAudioNode(\n                    this,\n                    <IAudioNode<TContext>>destination,\n                    output,\n                    input,\n                    isOffline\n                );\n\n                // Bug #164: Only Firefox detects cycles so far.\n                if (isNewConnectionToAudioNode) {\n                    const cycles = detectCycles([this], <IAudioNode<T>>(<unknown>destination));\n\n                    visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n                }\n\n                return destination;\n            }\n\n            const nativeAudioParam = getNativeAudioParam(destination);\n\n            /*\n             * Bug #73, #147 & #153: Safari does not support to connect an input signal to the playbackRate AudioParam of an\n             * AudioBufferSourceNode. This can't be easily detected and that's why the outdated name property is used here to identify\n             * Safari. In addition to that the maxValue property is used to only detect the affected versions below v14.0.2.\n             */\n            if ((<TNativeAudioParam & { name: string }>nativeAudioParam).name === 'playbackRate' && nativeAudioParam.maxValue === 1024) {\n                throw createNotSupportedError();\n            }\n\n            try {\n                this._nativeAudioNode.connect(nativeAudioParam, output);\n\n                if (isOffline || isPassiveAudioNode(this)) {\n                    this._nativeAudioNode.disconnect(nativeAudioParam, output);\n                }\n            } catch (err) {\n                // Bug #58: Safari doesn't throw an InvalidAccessError yet.\n                if (err.code === 12) {\n                    throw createInvalidAccessError();\n                }\n\n                throw err;\n            }\n\n            const isNewConnectionToAudioParam = addConnectionToAudioParamOfAudioContext(this, destination, output, isOffline);\n\n            // Bug #164: Only Firefox detects cycles so far.\n            if (isNewConnectionToAudioParam) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, createIncrementCycleCounter(isOffline));\n            }\n        }\n\n        public disconnect(output?: number): void;\n        public disconnect<U extends TContext>(destinationNode: IAudioNode<U>, output?: number, input?: number): void;\n        public disconnect(destinationParam: IAudioParam, output?: number): void;\n        public disconnect<U extends TContext>(\n            destinationOrOutput?: number | IAudioNode<U> | IAudioParam,\n            output?: number,\n            input?: number\n        ): void {\n            let destinations: (IAudioNode<T> | IAudioParam)[];\n\n            const nativeContext = getNativeContext(this._context);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n\n            if (destinationOrOutput === undefined) {\n                destinations = deleteAnyConnection(this, isOffline);\n            } else if (typeof destinationOrOutput === 'number') {\n                if (destinationOrOutput < 0 || destinationOrOutput >= this.numberOfOutputs) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionAtOutput(this, isOffline, destinationOrOutput);\n            } else {\n                if (output !== undefined && (output < 0 || output >= this.numberOfOutputs)) {\n                    throw createIndexSizeError();\n                }\n\n                if (isAudioNode(destinationOrOutput) && input !== undefined && (input < 0 || input >= destinationOrOutput.numberOfInputs)) {\n                    throw createIndexSizeError();\n                }\n\n                destinations = deleteConnectionToDestination(this, isOffline, destinationOrOutput, output, input);\n\n                if (destinations.length === 0) {\n                    throw createInvalidAccessError();\n                }\n            }\n\n            // Bug #164: Only Firefox detects cycles so far.\n            for (const destination of destinations) {\n                const cycles = detectCycles([this], destination);\n\n                visitEachAudioNodeOnce(cycles, decrementCycleCounter);\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter, __decorate } from \"tslib\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport var Envelope = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(Envelope, _ToneAudioNode);\n  var _super = _createSuper(Envelope);\n  function Envelope() {\n    var _this;\n    _classCallCheck(this, Envelope);\n    _this = _super.call(this, optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n    _this.name = \"Envelope\";\n    /**\n     * the signal which is output.\n     */\n    _this._sig = new Signal({\n      context: _this.context,\n      value: 0\n    });\n    /**\n     * The output signal of the envelope\n     */\n    _this.output = _this._sig;\n    /**\n     * Envelope has no input\n     */\n    _this.input = undefined;\n    var options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n    _this.attack = options.attack;\n    _this.decay = options.decay;\n    _this.sustain = options.sustain;\n    _this.release = options.release;\n    _this.attackCurve = options.attackCurve;\n    _this.releaseCurve = options.releaseCurve;\n    _this.decayCurve = options.decayCurve;\n    return _this;\n  }\n  _createClass(Envelope, [{\n    key: \"value\",\n    get:\n    /**\n     * Read the current value of the envelope. Useful for\n     * synchronizing visual output to the envelope.\n     */\n    function get() {\n      return this.getValueAtTime(this.now());\n    }\n    /**\n     * Get the curve\n     * @param  curve\n     * @param  direction  In/Out\n     * @return The curve name\n     */\n  }, {\n    key: \"_getCurve\",\n    value: function _getCurve(curve, direction) {\n      if (isString(curve)) {\n        return curve;\n      } else {\n        // look up the name in the curves array\n        var curveName;\n        for (curveName in EnvelopeCurves) {\n          if (EnvelopeCurves[curveName][direction] === curve) {\n            return curveName;\n          }\n        }\n        // return the custom curve\n        return curve;\n      }\n    }\n    /**\n     * Assign a the curve to the given name using the direction\n     * @param  name\n     * @param  direction In/Out\n     * @param  curve\n     */\n  }, {\n    key: \"_setCurve\",\n    value: function _setCurve(name, direction, curve) {\n      // check if it's a valid type\n      if (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n        var curveDef = EnvelopeCurves[curve];\n        if (isObject(curveDef)) {\n          if (name !== \"_decayCurve\") {\n            this[name] = curveDef[direction];\n          }\n        } else {\n          this[name] = curveDef;\n        }\n      } else if (isArray(curve) && name !== \"_decayCurve\") {\n        this[name] = curve;\n      } else {\n        throw new Error(\"Envelope: invalid curve: \" + curve);\n      }\n    }\n    /**\n     * The shape of the attack.\n     * Can be any of these strings:\n     * * \"linear\"\n     * * \"exponential\"\n     * * \"sine\"\n     * * \"cosine\"\n     * * \"bounce\"\n     * * \"ripple\"\n     * * \"step\"\n     *\n     * Can also be an array which describes the curve. Values\n     * in the array are evenly subdivided and linearly\n     * interpolated over the duration of the attack.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope(0.4).toDestination();\n     * \tenv.attackCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n  }, {\n    key: \"attackCurve\",\n    get: function get() {\n      return this._getCurve(this._attackCurve, \"In\");\n    },\n    set: function set(curve) {\n      this._setCurve(\"_attackCurve\", \"In\", curve);\n    }\n    /**\n     * The shape of the release. See the attack curve types.\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\trelease: 0.8\n     * \t}).toDestination();\n     * \tenv.triggerAttack();\n     * \t// release curve could also be defined by an array\n     * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n     * \tenv.triggerRelease(0.2);\n     * }, 1, 1);\n     */\n  }, {\n    key: \"releaseCurve\",\n    get: function get() {\n      return this._getCurve(this._releaseCurve, \"Out\");\n    },\n    set: function set(curve) {\n      this._setCurve(\"_releaseCurve\", \"Out\", curve);\n    }\n    /**\n     * The shape of the decay either \"linear\" or \"exponential\"\n     * @example\n     * return Tone.Offline(() => {\n     * \tconst env = new Tone.Envelope({\n     * \t\tsustain: 0.1,\n     * \t\tdecay: 0.5\n     * \t}).toDestination();\n     * \tenv.decayCurve = \"linear\";\n     * \tenv.triggerAttack();\n     * }, 1, 1);\n     */\n  }, {\n    key: \"decayCurve\",\n    get: function get() {\n      return this._decayCurve;\n    },\n    set: function set(curve) {\n      assert([\"linear\", \"exponential\"].some(function (c) {\n        return c === curve;\n      }), \"Invalid envelope curve: \".concat(curve));\n      this._decayCurve = curve;\n    }\n    /**\n     * Trigger the attack/decay portion of the ADSR envelope.\n     * @param  time When the attack should start.\n     * @param velocity The velocity of the envelope scales the vales.\n     *                             number between 0-1\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n     * env.triggerAttack(\"+0.5\", 0.2);\n     */\n  }, {\n    key: \"triggerAttack\",\n    value: function triggerAttack(time) {\n      var velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      this.log(\"triggerAttack\", time, velocity);\n      time = this.toSeconds(time);\n      var originalAttack = this.toSeconds(this.attack);\n      var attack = originalAttack;\n      var decay = this.toSeconds(this.decay);\n      // check if it's not a complete attack\n      var currentValue = this.getValueAtTime(time);\n      if (currentValue > 0) {\n        // subtract the current value from the attack time\n        var attackRate = 1 / attack;\n        var remainingDistance = 1 - currentValue;\n        // the attack is now the remaining time\n        attack = remainingDistance / attackRate;\n      }\n      // attack\n      if (attack < this.sampleTime) {\n        this._sig.cancelScheduledValues(time);\n        // case where the attack time is 0 should set instantly\n        this._sig.setValueAtTime(velocity, time);\n      } else if (this._attackCurve === \"linear\") {\n        this._sig.linearRampTo(velocity, attack, time);\n      } else if (this._attackCurve === \"exponential\") {\n        this._sig.targetRampTo(velocity, attack, time);\n      } else {\n        this._sig.cancelAndHoldAtTime(time);\n        var curve = this._attackCurve;\n        // find the starting position in the curve\n        for (var i = 1; i < curve.length; i++) {\n          // the starting index is between the two values\n          if (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n            curve = this._attackCurve.slice(i);\n            // the first index is the current value\n            curve[0] = currentValue;\n            break;\n          }\n        }\n        this._sig.setValueCurveAtTime(curve, time, attack, velocity);\n      }\n      // decay\n      if (decay && this.sustain < 1) {\n        var decayValue = velocity * this.sustain;\n        var decayStart = time + attack;\n        this.log(\"decay\", decayStart);\n        if (this._decayCurve === \"linear\") {\n          this._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n        } else {\n          this._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n        }\n      }\n      return this;\n    }\n    /**\n     * Triggers the release of the envelope.\n     * @param  time When the release portion of the envelope should start.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator({\n     * \ttype: \"sawtooth\"\n     * }).connect(env).start();\n     * env.triggerAttack();\n     * // trigger the release half a second after the attack\n     * env.triggerRelease(\"+0.5\");\n     */\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(time) {\n      this.log(\"triggerRelease\", time);\n      time = this.toSeconds(time);\n      var currentValue = this.getValueAtTime(time);\n      if (currentValue > 0) {\n        var release = this.toSeconds(this.release);\n        if (release < this.sampleTime) {\n          this._sig.setValueAtTime(0, time);\n        } else if (this._releaseCurve === \"linear\") {\n          this._sig.linearRampTo(0, release, time);\n        } else if (this._releaseCurve === \"exponential\") {\n          this._sig.targetRampTo(0, release, time);\n        } else {\n          assert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n          this._sig.cancelAndHoldAtTime(time);\n          this._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n        }\n      }\n      return this;\n    }\n    /**\n     * Get the scheduled value at the given time. This will\n     * return the unconverted (raw) value.\n     * @example\n     * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n     * env.triggerAttackRelease(2);\n     * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n     */\n  }, {\n    key: \"getValueAtTime\",\n    value: function getValueAtTime(time) {\n      return this._sig.getValueAtTime(time);\n    }\n    /**\n     * triggerAttackRelease is shorthand for triggerAttack, then waiting\n     * some duration, then triggerRelease.\n     * @param duration The duration of the sustain.\n     * @param time When the attack should be triggered.\n     * @param velocity The velocity of the envelope.\n     * @example\n     * const env = new Tone.AmplitudeEnvelope().toDestination();\n     * const osc = new Tone.Oscillator().connect(env).start();\n     * // trigger the release 0.5 seconds after the attack\n     * env.triggerAttackRelease(0.5);\n     */\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(duration, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      time = this.toSeconds(time);\n      this.triggerAttack(time, velocity);\n      this.triggerRelease(time + this.toSeconds(duration));\n      return this;\n    }\n    /**\n     * Cancels all scheduled envelope changes after the given time.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      this._sig.cancelScheduledValues(this.toSeconds(after));\n      return this;\n    }\n    /**\n     * Connect the envelope to a destination node.\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(destination) {\n      var outputNumber = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n      var inputNumber = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 0;\n      connectSignal(this, destination, outputNumber, inputNumber);\n      return this;\n    }\n    /**\n     * Render the envelope curve to an array of the given length.\n     * Good for visualizing the envelope curve. Rescales the duration of the\n     * envelope to fit the length.\n     */\n  }, {\n    key: \"asArray\",\n    value: function asArray() {\n      var length = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 1024;\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var duration, context, attackPortion, envelopeDuration, sustainTime, totalDuration, clone, buffer;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              duration = length / this.context.sampleRate;\n              context = new OfflineContext(1, duration, this.context.sampleRate); // normalize the ADSR for the given duration with 20% sustain time\n              attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n              envelopeDuration = attackPortion + this.toSeconds(this.release);\n              sustainTime = envelopeDuration * 0.1;\n              totalDuration = envelopeDuration + sustainTime; // @ts-ignore\n              clone = new this.constructor(Object.assign(this.get(), {\n                attack: duration * this.toSeconds(this.attack) / totalDuration,\n                decay: duration * this.toSeconds(this.decay) / totalDuration,\n                release: duration * this.toSeconds(this.release) / totalDuration,\n                context: context\n              }));\n              clone._sig.toDestination();\n              clone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n              _context.next = 11;\n              return context.render();\n            case 11:\n              buffer = _context.sent;\n              return _context.abrupt(\"return\", buffer.getChannelData(0));\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Envelope.prototype), \"dispose\", this).call(this);\n      this._sig.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        attack: 0.01,\n        attackCurve: \"linear\",\n        decay: 0.1,\n        decayCurve: \"exponential\",\n        release: 1,\n        releaseCurve: \"exponential\",\n        sustain: 0.5\n      });\n    }\n  }]);\n  return Envelope;\n}(ToneAudioNode);\n__decorate([timeRange(0)], Envelope.prototype, \"attack\", void 0);\n__decorate([timeRange(0)], Envelope.prototype, \"decay\", void 0);\n__decorate([range(0, 1)], Envelope.prototype, \"sustain\", void 0);\n__decorate([timeRange(0)], Envelope.prototype, \"release\", void 0);\n/**\n * Generate some complex envelope curves.\n */\nvar EnvelopeCurves = function () {\n  var curveLen = 128;\n  var i;\n  var k;\n  // cosine curve\n  var cosineCurve = [];\n  for (i = 0; i < curveLen; i++) {\n    cosineCurve[i] = Math.sin(i / (curveLen - 1) * (Math.PI / 2));\n  }\n  // ripple curve\n  var rippleCurve = [];\n  var rippleCurveFreq = 6.4;\n  for (i = 0; i < curveLen - 1; i++) {\n    k = i / (curveLen - 1);\n    var sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n    rippleCurve[i] = sineWave / 10 + k * 0.83;\n  }\n  rippleCurve[curveLen - 1] = 1;\n  // stairs curve\n  var stairsCurve = [];\n  var steps = 5;\n  for (i = 0; i < curveLen; i++) {\n    stairsCurve[i] = Math.ceil(i / (curveLen - 1) * steps) / steps;\n  }\n  // in-out easing curve\n  var sineCurve = [];\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    sineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n  }\n  // a bounce curve\n  var bounceCurve = [];\n  for (i = 0; i < curveLen; i++) {\n    k = i / (curveLen - 1);\n    var freq = Math.pow(k, 3) * 4 + 0.2;\n    var val = Math.cos(freq * Math.PI * 2 * k);\n    bounceCurve[i] = Math.abs(val * (1 - k));\n  }\n  /**\n   * Invert a value curve to make it work for the release\n   */\n  function invertCurve(curve) {\n    var out = new Array(curve.length);\n    for (var j = 0; j < curve.length; j++) {\n      out[j] = 1 - curve[j];\n    }\n    return out;\n  }\n  /**\n   * reverse the curve\n   */\n  function reverseCurve(curve) {\n    return curve.slice(0).reverse();\n  }\n  /**\n   * attack and release curve arrays\n   */\n  return {\n    bounce: {\n      In: invertCurve(bounceCurve),\n      Out: bounceCurve\n    },\n    cosine: {\n      In: cosineCurve,\n      Out: reverseCurve(cosineCurve)\n    },\n    exponential: \"exponential\",\n    linear: \"linear\",\n    ripple: {\n      In: rippleCurve,\n      Out: invertCurve(rippleCurve)\n    },\n    sine: {\n      In: sineCurve,\n      Out: invertCurve(sineCurve)\n    },\n    step: {\n      In: stairsCurve,\n      Out: invertCurve(stairsCurve)\n    }\n  };\n}();","map":{"version":3,"mappings":"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","names":["ToneAudioNode","optionsFromArguments","isArray","isObject","isString","connectSignal","Signal","OfflineContext","assert","range","timeRange","Envelope","getDefaults","arguments","context","value","_sig","undefined","options","attack","decay","sustain","release","attackCurve","releaseCurve","decayCurve","getValueAtTime","now","curve","direction","curveName","EnvelopeCurves","name","Reflect","has","curveDef","Error","_getCurve","_attackCurve","_setCurve","_releaseCurve","_decayCurve","some","c","time","velocity","log","toSeconds","originalAttack","currentValue","attackRate","remainingDistance","sampleTime","cancelScheduledValues","setValueAtTime","linearRampTo","targetRampTo","cancelAndHoldAtTime","i","length","slice","setValueCurveAtTime","decayValue","decayStart","linearRampToValueAtTime","exponentialApproachValueAtTime","duration","triggerAttack","triggerRelease","after","destination","outputNumber","inputNumber","sampleRate","attackPortion","envelopeDuration","sustainTime","totalDuration","clone","constructor","Object","assign","get","toDestination","triggerAttackRelease","render","buffer","getChannelData","dispose","__decorate","curveLen","k","cosineCurve","Math","sin","PI","rippleCurve","rippleCurveFreq","sineWave","stairsCurve","steps","ceil","sineCurve","cos","bounceCurve","freq","pow","val","abs","invertCurve","out","Array","j","reverseCurve","reverse","bounce","In","Out","cosine","exponential","linear","ripple","sine","step"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\component\\envelope\\Envelope.ts"],"sourcesContent":["import { InputNode, OutputNode } from \"../../core/context/ToneAudioNode\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\nimport { NormalRange, Time } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { isArray, isObject, isString } from \"../../core/util/TypeCheck\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { OfflineContext } from \"../../core/context/OfflineContext\";\nimport { assert } from \"../../core/util/Debug\";\nimport { range, timeRange } from \"../../core/util/Decorator\";\n\ntype BasicEnvelopeCurve = \"linear\" | \"exponential\";\ntype InternalEnvelopeCurve = BasicEnvelopeCurve | number[];\nexport type EnvelopeCurve = EnvelopeCurveName | number[];\n\nexport interface EnvelopeOptions extends ToneAudioNodeOptions {\n\tattack: Time;\n\tdecay: Time;\n\tsustain: NormalRange;\n\trelease: Time;\n\tattackCurve: EnvelopeCurve;\n\treleaseCurve: EnvelopeCurve;\n\tdecayCurve: BasicEnvelopeCurve;\n}\n\n/**\n * Envelope is an [ADSR](https://en.wikipedia.org/wiki/Synthesizer#ADSR_envelope)\n * envelope generator. Envelope outputs a signal which\n * can be connected to an AudioParam or Tone.Signal.\n * ```\n *           /\\\n *          /  \\\n *         /    \\\n *        /      \\\n *       /        \\___________\n *      /                     \\\n *     /                       \\\n *    /                         \\\n *   /                           \\\n * ```\n * @example\n * return Tone.Offline(() => {\n * \tconst env = new Tone.Envelope({\n * \t\tattack: 0.1,\n * \t\tdecay: 0.2,\n * \t\tsustain: 0.5,\n * \t\trelease: 0.8,\n * \t}).toDestination();\n * \tenv.triggerAttackRelease(0.5);\n * }, 1.5, 1);\n * @category Component\n */\nexport class Envelope extends ToneAudioNode<EnvelopeOptions> {\n\n\treadonly name: string = \"Envelope\";\n\n\t/**\n\t * When triggerAttack is called, the attack time is the amount of\n\t * time it takes for the envelope to reach it's maximum value.\n\t * ```\n\t *           /\\\n\t *          /X \\\n\t *         /XX  \\\n\t *        /XXX   \\\n\t *       /XXXX    \\___________\n\t *      /XXXXX                \\\n\t *     /XXXXXX                 \\\n\t *    /XXXXXXX                  \\\n\t *   /XXXXXXXX                   \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tattack: Time;\n\n\t/**\n\t * After the attack portion of the envelope, the value will fall\n\t * over the duration of the decay time to it's sustain value.\n\t * ```\n\t *           /\\\n\t *          / X\\\n\t *         /  XX\\\n\t *        /   XXX\\\n\t *       /    XXXX\\___________\n\t *      /     XXXXX           \\\n\t *     /      XXXXX            \\\n\t *    /       XXXXX             \\\n\t *   /        XXXXX              \\\n\t * ```\n\t * @min 0\n\t * @max 2\n\t */\n\t@timeRange(0)\n\tdecay: Time;\n\n\t/**\n\t * The sustain value is the value\n\t * which the envelope rests at after triggerAttack is\n\t * called, but before triggerRelease is invoked.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /          XXXXXXXXXXX\\\n\t *     /           XXXXXXXXXXX \\\n\t *    /            XXXXXXXXXXX  \\\n\t *   /             XXXXXXXXXXX   \\\n\t * ```\n\t */\n\t@range(0, 1)\n\tsustain: NormalRange;\n\n\t/**\n\t * After triggerRelease is called, the envelope's\n\t * value will fall to it's miminum value over the\n\t * duration of the release time.\n\t * ```\n\t *           /\\\n\t *          /  \\\n\t *         /    \\\n\t *        /      \\\n\t *       /        \\___________\n\t *      /                    X\\\n\t *     /                     XX\\\n\t *    /                      XXX\\\n\t *   /                       XXXX\\\n\t * ```\n\t * @min 0\n\t * @max 5\n\t */\n\t@timeRange(0)\n\trelease: Time;\n\n\t/**\n\t * The automation curve type for the attack\n\t */\n\tprivate _attackCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the decay\n\t */\n\tprivate _decayCurve!: BasicEnvelopeCurve;\n\n\t/**\n\t * The automation curve type for the release\n\t */\n\tprivate _releaseCurve!: InternalEnvelopeCurve;\n\n\t/**\n\t * the signal which is output.\n\t */\n\tprotected _sig: Signal<\"normalRange\"> = new Signal({\n\t\tcontext: this.context,\n\t\tvalue: 0,\n\t});\n\n\t/**\n\t * The output signal of the envelope\n\t */\n\toutput: OutputNode = this._sig;\n\n\t/**\n\t * Envelope has no input\n\t */\n\tinput: InputNode | undefined = undefined;\n\n\t/**\n\t * @param attack The amount of time it takes for the envelope to go from\n\t *                        0 to it's maximum value.\n\t * @param decay\tThe period of time after the attack that it takes for the envelope\n\t *                      \tto fall to the sustain value. Value must be greater than 0.\n\t * @param sustain\tThe percent of the maximum value that the envelope rests at until\n\t *                               \tthe release is triggered.\n\t * @param release\tThe amount of time after the release is triggered it takes to reach 0.\n\t *                        \tValue must be greater than 0.\n\t */\n\tconstructor(attack?: Time, decay?: Time, sustain?: NormalRange, release?: Time);\n\tconstructor(options?: Partial<EnvelopeOptions>)\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]));\n\t\tconst options = optionsFromArguments(Envelope.getDefaults(), arguments, [\"attack\", \"decay\", \"sustain\", \"release\"]);\n\n\t\tthis.attack = options.attack;\n\t\tthis.decay = options.decay;\n\t\tthis.sustain = options.sustain;\n\t\tthis.release = options.release;\n\t\tthis.attackCurve = options.attackCurve;\n\t\tthis.releaseCurve = options.releaseCurve;\n\t\tthis.decayCurve = options.decayCurve;\n\t}\n\n\tstatic getDefaults(): EnvelopeOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tattack: 0.01,\n\t\t\tattackCurve: \"linear\" as EnvelopeCurveName,\n\t\t\tdecay: 0.1,\n\t\t\tdecayCurve: \"exponential\" as BasicEnvelopeCurve,\n\t\t\trelease: 1,\n\t\t\treleaseCurve: \"exponential\" as EnvelopeCurveName,\n\t\t\tsustain: 0.5,\n\t\t});\n\t}\n\n\t/**\n\t * Read the current value of the envelope. Useful for\n\t * synchronizing visual output to the envelope.\n\t */\n\tget value(): NormalRange {\n\t\treturn this.getValueAtTime(this.now());\n\t}\n\n\t/**\n\t * Get the curve\n\t * @param  curve\n\t * @param  direction  In/Out\n\t * @return The curve name\n\t */\n\tprivate _getCurve(curve: InternalEnvelopeCurve, direction: EnvelopeDirection): EnvelopeCurve {\n\t\tif (isString(curve)) {\n\t\t\treturn curve;\n\t\t} else {\n\t\t\t// look up the name in the curves array\n\t\t\tlet curveName: EnvelopeCurveName;\n\t\t\tfor (curveName in EnvelopeCurves) {\n\t\t\t\tif (EnvelopeCurves[curveName][direction] === curve) {\n\t\t\t\t\treturn curveName;\n\t\t\t\t}\n\t\t\t}\n\t\t\t// return the custom curve\n\t\t\treturn curve;\n\t\t}\n\t}\n\n\t/**\n\t * Assign a the curve to the given name using the direction\n\t * @param  name\n\t * @param  direction In/Out\n\t * @param  curve\n\t */\n\tprivate _setCurve(\n\t\tname: \"_attackCurve\" | \"_decayCurve\" | \"_releaseCurve\",\n\t\tdirection: EnvelopeDirection,\n\t\tcurve: EnvelopeCurve,\n\t): void {\n\t\t// check if it's a valid type\n\t\tif (isString(curve) && Reflect.has(EnvelopeCurves, curve)) {\n\t\t\tconst curveDef = EnvelopeCurves[curve];\n\t\t\tif (isObject(curveDef)) {\n\t\t\t\tif (name !== \"_decayCurve\") {\n\t\t\t\t\tthis[name] = curveDef[direction];\n\t\t\t\t}\n\t\t\t} else {\n\t\t\t\tthis[name] = curveDef;\n\t\t\t}\n\t\t} else if (isArray(curve) && name !== \"_decayCurve\") {\n\t\t\tthis[name] = curve;\n\t\t} else {\n\t\t\tthrow new Error(\"Envelope: invalid curve: \" + curve);\n\t\t}\n\t}\n\n\t/**\n\t * The shape of the attack.\n\t * Can be any of these strings:\n\t * * \"linear\"\n\t * * \"exponential\"\n\t * * \"sine\"\n\t * * \"cosine\"\n\t * * \"bounce\"\n\t * * \"ripple\"\n\t * * \"step\"\n\t *\n\t * Can also be an array which describes the curve. Values\n\t * in the array are evenly subdivided and linearly\n\t * interpolated over the duration of the attack.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope(0.4).toDestination();\n\t * \tenv.attackCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget attackCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._attackCurve, \"In\");\n\t}\n\tset attackCurve(curve) {\n\t\tthis._setCurve(\"_attackCurve\", \"In\", curve);\n\t}\n\n\t/**\n\t * The shape of the release. See the attack curve types.\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\trelease: 0.8\n\t * \t}).toDestination();\n\t * \tenv.triggerAttack();\n\t * \t// release curve could also be defined by an array\n\t * \tenv.releaseCurve = [1, 0.3, 0.4, 0.2, 0.7, 0];\n\t * \tenv.triggerRelease(0.2);\n\t * }, 1, 1);\n\t */\n\tget releaseCurve(): EnvelopeCurve {\n\t\treturn this._getCurve(this._releaseCurve, \"Out\");\n\t}\n\tset releaseCurve(curve) {\n\t\tthis._setCurve(\"_releaseCurve\", \"Out\", curve);\n\t}\n\n\t/**\n\t * The shape of the decay either \"linear\" or \"exponential\"\n\t * @example\n\t * return Tone.Offline(() => {\n\t * \tconst env = new Tone.Envelope({\n\t * \t\tsustain: 0.1,\n\t * \t\tdecay: 0.5\n\t * \t}).toDestination();\n\t * \tenv.decayCurve = \"linear\";\n\t * \tenv.triggerAttack();\n\t * }, 1, 1);\n\t */\n\tget decayCurve(): BasicEnvelopeCurve {\n\t\treturn this._decayCurve;\n\t}\n\tset decayCurve(curve) {\n\t\tassert([\"linear\", \"exponential\"].some(c => c === curve), `Invalid envelope curve: ${curve}`);\n\t\tthis._decayCurve = curve;\n\t}\n\n\t/**\n\t * Trigger the attack/decay portion of the ADSR envelope.\n\t * @param  time When the attack should start.\n\t * @param velocity The velocity of the envelope scales the vales.\n\t *                             number between 0-1\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the attack 0.5 seconds from now with a velocity of 0.2\n\t * env.triggerAttack(\"+0.5\", 0.2);\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", time, velocity);\n\t\ttime = this.toSeconds(time);\n\t\tconst originalAttack = this.toSeconds(this.attack);\n\t\tlet attack = originalAttack;\n\t\tconst decay = this.toSeconds(this.decay);\n\t\t// check if it's not a complete attack\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\t// subtract the current value from the attack time\n\t\t\tconst attackRate = 1 / attack;\n\t\t\tconst remainingDistance = 1 - currentValue;\n\t\t\t// the attack is now the remaining time\n\t\t\tattack = remainingDistance / attackRate;\n\t\t}\n\t\t// attack\n\t\tif (attack < this.sampleTime) {\n\t\t\tthis._sig.cancelScheduledValues(time);\n\t\t\t// case where the attack time is 0 should set instantly\n\t\t\tthis._sig.setValueAtTime(velocity, time);\n\t\t} else if (this._attackCurve === \"linear\") {\n\t\t\tthis._sig.linearRampTo(velocity, attack, time);\n\t\t} else if (this._attackCurve === \"exponential\") {\n\t\t\tthis._sig.targetRampTo(velocity, attack, time);\n\t\t} else {\n\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\tlet curve = this._attackCurve;\n\t\t\t// find the starting position in the curve\n\t\t\tfor (let i = 1; i < curve.length; i++) {\n\t\t\t\t// the starting index is between the two values\n\t\t\t\tif (curve[i - 1] <= currentValue && currentValue <= curve[i]) {\n\t\t\t\t\tcurve = this._attackCurve.slice(i);\n\t\t\t\t\t// the first index is the current value\n\t\t\t\t\tcurve[0] = currentValue;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\tthis._sig.setValueCurveAtTime(curve, time, attack, velocity);\n\t\t}\n\t\t// decay\n\t\tif (decay && this.sustain < 1) {\n\t\t\tconst decayValue = velocity * this.sustain;\n\t\t\tconst decayStart = time + attack;\n\t\t\tthis.log(\"decay\", decayStart);\n\t\t\tif (this._decayCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampToValueAtTime(decayValue, decay + decayStart);\n\t\t\t} else {\n\t\t\t\tthis._sig.exponentialApproachValueAtTime(decayValue, decayStart, decay);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Triggers the release of the envelope.\n\t * @param  time When the release portion of the envelope should start.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator({\n\t * \ttype: \"sawtooth\"\n\t * }).connect(env).start();\n\t * env.triggerAttack();\n\t * // trigger the release half a second after the attack\n\t * env.triggerRelease(\"+0.5\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\ttime = this.toSeconds(time);\n\t\tconst currentValue = this.getValueAtTime(time);\n\t\tif (currentValue > 0) {\n\t\t\tconst release = this.toSeconds(this.release);\n\t\t\tif (release < this.sampleTime) {\n\t\t\t\tthis._sig.setValueAtTime(0, time);\n\t\t\t} else if (this._releaseCurve === \"linear\") {\n\t\t\t\tthis._sig.linearRampTo(0, release, time);\n\t\t\t} else if (this._releaseCurve === \"exponential\") {\n\t\t\t\tthis._sig.targetRampTo(0, release, time);\n\t\t\t} else {\n\t\t\t\tassert(isArray(this._releaseCurve), \"releaseCurve must be either 'linear', 'exponential' or an array\");\n\t\t\t\tthis._sig.cancelAndHoldAtTime(time);\n\t\t\t\tthis._sig.setValueCurveAtTime(this._releaseCurve, time, release, currentValue);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the scheduled value at the given time. This will\n\t * return the unconverted (raw) value.\n\t * @example\n\t * const env = new Tone.Envelope(0.5, 1, 0.4, 2);\n\t * env.triggerAttackRelease(2);\n\t * setInterval(() => console.log(env.getValueAtTime(Tone.now())), 100);\n\t */\n\tgetValueAtTime(time: Time): NormalRange {\n\t\treturn this._sig.getValueAtTime(time);\n\t}\n\n\t/**\n\t * triggerAttackRelease is shorthand for triggerAttack, then waiting\n\t * some duration, then triggerRelease.\n\t * @param duration The duration of the sustain.\n\t * @param time When the attack should be triggered.\n\t * @param velocity The velocity of the envelope.\n\t * @example\n\t * const env = new Tone.AmplitudeEnvelope().toDestination();\n\t * const osc = new Tone.Oscillator().connect(env).start();\n\t * // trigger the release 0.5 seconds after the attack\n\t * env.triggerAttackRelease(0.5);\n\t */\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + this.toSeconds(duration));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancels all scheduled envelope changes after the given time.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._sig.cancelScheduledValues(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Connect the envelope to a destination node.\n\t */\n\tconnect(destination: InputNode, outputNumber = 0, inputNumber = 0): this {\n\t\tconnectSignal(this, destination, outputNumber, inputNumber);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Render the envelope curve to an array of the given length. \n\t * Good for visualizing the envelope curve. Rescales the duration of the\n\t * envelope to fit the length.\n\t */\n\tasync asArray(length = 1024): Promise<Float32Array> {\n\t\tconst duration = length / this.context.sampleRate;\n\t\tconst context = new OfflineContext(1, duration, this.context.sampleRate);\n\t\t// normalize the ADSR for the given duration with 20% sustain time\n\t\tconst attackPortion = this.toSeconds(this.attack) + this.toSeconds(this.decay);\n\t\tconst envelopeDuration = attackPortion + this.toSeconds(this.release);\n\t\tconst sustainTime = envelopeDuration * 0.1;\n\t\tconst totalDuration = envelopeDuration + sustainTime;\n\t\t// @ts-ignore\n\t\tconst clone = new this.constructor(Object.assign(this.get(), {\n\t\t\tattack: duration * this.toSeconds(this.attack) / totalDuration,\n\t\t\tdecay: duration * this.toSeconds(this.decay) / totalDuration,\n\t\t\trelease: duration * this.toSeconds(this.release) / totalDuration,\n\t\t\tcontext\n\t\t})) as Envelope;\n\t\tclone._sig.toDestination();\n\t\tclone.triggerAttackRelease(duration * (attackPortion + sustainTime) / totalDuration, 0);\n\t\tconst buffer = await context.render();\n\t\treturn buffer.getChannelData(0);\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._sig.dispose();\n\t\treturn this;\n\t}\n}\n\ninterface EnvelopeCurveObject {\n\tIn: number[];\n\tOut: number[];\n}\n\ntype EnvelopeDirection = keyof EnvelopeCurveObject;\n\ninterface EnvelopeCurveMap {\n\tlinear: \"linear\";\n\texponential: \"exponential\";\n\tbounce: EnvelopeCurveObject;\n\tcosine: EnvelopeCurveObject;\n\tsine: EnvelopeCurveObject;\n\tripple: EnvelopeCurveObject;\n\tstep: EnvelopeCurveObject;\n}\n\ntype EnvelopeCurveName = keyof EnvelopeCurveMap;\n\n/**\n * Generate some complex envelope curves.\n */\nconst EnvelopeCurves: EnvelopeCurveMap = (() => {\n\n\tconst curveLen = 128;\n\n\tlet i: number;\n\tlet k: number;\n\n\t// cosine curve\n\tconst cosineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tcosineCurve[i] = Math.sin((i / (curveLen - 1)) * (Math.PI / 2));\n\t}\n\n\t// ripple curve\n\tconst rippleCurve: number[] = [];\n\tconst rippleCurveFreq = 6.4;\n\tfor (i = 0; i < curveLen - 1; i++) {\n\t\tk = (i / (curveLen - 1));\n\t\tconst sineWave = Math.sin(k * (Math.PI * 2) * rippleCurveFreq - Math.PI / 2) + 1;\n\t\trippleCurve[i] = sineWave / 10 + k * 0.83;\n\t}\n\trippleCurve[curveLen - 1] = 1;\n\n\t// stairs curve\n\tconst stairsCurve: number[] = [];\n\tconst steps = 5;\n\tfor (i = 0; i < curveLen; i++) {\n\t\tstairsCurve[i] = Math.ceil((i / (curveLen - 1)) * steps) / steps;\n\t}\n\n\t// in-out easing curve\n\tconst sineCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tsineCurve[i] = 0.5 * (1 - Math.cos(Math.PI * k));\n\t}\n\n\t// a bounce curve\n\tconst bounceCurve: number[] = [];\n\tfor (i = 0; i < curveLen; i++) {\n\t\tk = i / (curveLen - 1);\n\t\tconst freq = Math.pow(k, 3) * 4 + 0.2;\n\t\tconst val = Math.cos(freq * Math.PI * 2 * k);\n\t\tbounceCurve[i] = Math.abs(val * (1 - k));\n\t}\n\n\t/**\n\t * Invert a value curve to make it work for the release\n\t */\n\tfunction invertCurve(curve: number[]): number[] {\n\t\tconst out = new Array(curve.length);\n\t\tfor (let j = 0; j < curve.length; j++) {\n\t\t\tout[j] = 1 - curve[j];\n\t\t}\n\t\treturn out;\n\t}\n\n\t/**\n\t * reverse the curve\n\t */\n\tfunction reverseCurve(curve: number[]): number[] {\n\t\treturn curve.slice(0).reverse();\n\t}\n\n\t/**\n\t * attack and release curve arrays\n\t */\n\treturn {\n\t\tbounce: {\n\t\t\tIn: invertCurve(bounceCurve),\n\t\t\tOut: bounceCurve,\n\t\t},\n\t\tcosine: {\n\t\t\tIn: cosineCurve,\n\t\t\tOut: reverseCurve(cosineCurve),\n\t\t},\n\t\texponential: \"exponential\" as \"exponential\",\n\t\tlinear: \"linear\" as \"linear\",\n\t\tripple: {\n\t\t\tIn: rippleCurve,\n\t\t\tOut: invertCurve(rippleCurve),\n\t\t},\n\t\tsine: {\n\t\t\tIn: sineCurve,\n\t\t\tOut: invertCurve(sineCurve),\n\t\t},\n\t\tstep: {\n\t\t\tIn: stairsCurve,\n\t\t\tOut: invertCurve(stairsCurve),\n\t\t},\n\t};\n})();\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic } from \"./Monophonic\";\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport var Synth = /*#__PURE__*/function (_Monophonic) {\n  _inherits(Synth, _Monophonic);\n  var _super = _createSuper(Synth);\n  function Synth() {\n    var _this;\n    _classCallCheck(this, Synth);\n    _this = _super.call(this, optionsFromArguments(Synth.getDefaults(), arguments));\n    _this.name = \"Synth\";\n    var options = optionsFromArguments(Synth.getDefaults(), arguments);\n    _this.oscillator = new OmniOscillator(Object.assign({\n      context: _this.context,\n      detune: options.detune,\n      onstop: function onstop() {\n        return _this.onsilence(_assertThisInitialized(_this));\n      }\n    }, options.oscillator));\n    _this.frequency = _this.oscillator.frequency;\n    _this.detune = _this.oscillator.detune;\n    _this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: _this.context\n    }, options.envelope));\n    // connect the oscillators to the output\n    _this.oscillator.chain(_this.envelope, _this.output);\n    readOnly(_assertThisInitialized(_this), [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n    return _this;\n  }\n  _createClass(Synth, [{\n    key: \"_triggerEnvelopeAttack\",\n    value:\n    /**\n     * start the attack portion of the envelope\n     * @param time the time the attack should start\n     * @param velocity the velocity of the note (0-1)\n     */\n    function _triggerEnvelopeAttack(time, velocity) {\n      // the envelopes\n      this.envelope.triggerAttack(time, velocity);\n      this.oscillator.start(time);\n      // if there is no release portion, stop the oscillator\n      if (this.envelope.sustain === 0) {\n        var computedAttack = this.toSeconds(this.envelope.attack);\n        var computedDecay = this.toSeconds(this.envelope.decay);\n        this.oscillator.stop(time + computedAttack + computedDecay);\n      }\n    }\n    /**\n     * start the release portion of the envelope\n     * @param time the time the release should start\n     */\n  }, {\n    key: \"_triggerEnvelopeRelease\",\n    value: function _triggerEnvelopeRelease(time) {\n      this.envelope.triggerRelease(time);\n      this.oscillator.stop(time + this.toSeconds(this.envelope.release));\n    }\n  }, {\n    key: \"getLevelAtTime\",\n    value: function getLevelAtTime(time) {\n      time = this.toSeconds(time);\n      return this.envelope.getValueAtTime(time);\n    }\n    /**\n     * clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Synth.prototype), \"dispose\", this).call(this);\n      this.oscillator.dispose();\n      this.envelope.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Monophonic.getDefaults(), {\n        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n          attack: 0.005,\n          decay: 0.1,\n          release: 1,\n          sustain: 0.3\n        }),\n        oscillator: Object.assign(omitFromObject(OmniOscillator.getDefaults(), [].concat(_toConsumableArray(Object.keys(Source.getDefaults())), [\"frequency\", \"detune\"])), {\n          type: \"triangle\"\n        })\n      });\n    }\n  }]);\n  return Synth;\n}(Monophonic);","map":{"version":3,"mappings":"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","names":["AmplitudeEnvelope","Envelope","ToneAudioNode","omitFromObject","optionsFromArguments","readOnly","OmniOscillator","Source","Monophonic","Synth","getDefaults","arguments","options","oscillator","Object","assign","context","detune","onstop","onsilence","frequency","envelope","chain","output","time","velocity","triggerAttack","start","sustain","computedAttack","toSeconds","attack","computedDecay","decay","stop","triggerRelease","release","getValueAtTime","dispose","keys","type"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\instrument\\Synth.ts"],"sourcesContent":["import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Signal } from \"../signal/Signal\";\nimport { OmniOscillator } from \"../source/oscillator/OmniOscillator\";\nimport { OmniOscillatorOptions, OmniOscillatorSynthOptions } from \"../source/oscillator/OscillatorInterface\";\nimport { Source } from \"../source/Source\";\nimport { Monophonic, MonophonicOptions } from \"./Monophonic\";\n\nexport interface SynthOptions extends MonophonicOptions {\n\toscillator: OmniOscillatorSynthOptions;\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Synth is composed simply of a [[OmniOscillator]] routed through an [[AmplitudeEnvelope]].\n * ```\n * +----------------+   +-------------------+\n * | OmniOscillator +>--> AmplitudeEnvelope +>--> Output\n * +----------------+   +-------------------+\n * ```\n * @example\n * const synth = new Tone.Synth().toDestination();\n * synth.triggerAttackRelease(\"C4\", \"8n\");\n * @category Instrument\n */\nexport class Synth<Options extends SynthOptions = SynthOptions> extends Monophonic<Options> {\n\n\treadonly name: string = \"Synth\";\n\n\t/**\n\t * The oscillator.\n\t */\n\treadonly oscillator: OmniOscillator<any>;\n\n\t/**\n\t * The frequency signal\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The detune signal\n\t */\n\treadonly detune: Signal<\"cents\">;\n\n\t/**\n\t * The envelope\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\t/**\n\t * @param options the options available for the synth.\n\t */\n\tconstructor(options?: RecursivePartial<SynthOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(Synth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Synth.getDefaults(), arguments);\n\n\t\tthis.oscillator = new OmniOscillator(Object.assign({\n\t\t\tcontext: this.context,\n\t\t\tdetune: options.detune,\n\t\t\tonstop: () => this.onsilence(this),\n\t\t}, options.oscillator));\n\n\t\tthis.frequency = this.oscillator.frequency;\n\t\tthis.detune = this.oscillator.detune;\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the oscillators to the output\n\t\tthis.oscillator.chain(this.envelope, this.output);\n\t\treadOnly(this, [\"oscillator\", \"frequency\", \"detune\", \"envelope\"]);\n\t}\n\n\tstatic getDefaults(): SynthOptions {\n\t\treturn Object.assign(Monophonic.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tattack: 0.005,\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\trelease: 1,\n\t\t\t\t\tsustain: 0.3,\n\t\t\t\t},\n\t\t\t),\n\t\t\toscillator: Object.assign(\n\t\t\t\tomitFromObject(OmniOscillator.getDefaults(), [...Object.keys(Source.getDefaults()), \"frequency\", \"detune\"]),\n\t\t\t\t{\n\t\t\t\t\ttype: \"triangle\",\n\t\t\t\t},\n\t\t\t) as OmniOscillatorOptions,\n\t\t});\n\t}\n\n\t/**\n\t * start the attack portion of the envelope\n\t * @param time the time the attack should start\n\t * @param velocity the velocity of the note (0-1)\n\t */\n\tprotected _triggerEnvelopeAttack(time: Seconds, velocity: number): void {\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\tthis.oscillator.start(time);\n\t\t// if there is no release portion, stop the oscillator\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tconst computedAttack = this.toSeconds(this.envelope.attack);\n\t\t\tconst computedDecay = this.toSeconds(this.envelope.decay);\n\t\t\tthis.oscillator.stop(time + computedAttack + computedDecay);\n\t\t}\n\t}\n\n\t/**\n\t * start the release portion of the envelope\n\t * @param time the time the release should start\n\t */\n\tprotected _triggerEnvelopeRelease(time: Seconds): void {\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.oscillator.stop(time + this.toSeconds(this.envelope.release));\n\t}\n\n\tgetLevelAtTime(time: Time): NormalRange {\n\t\ttime = this.toSeconds(time);\n\t\treturn this.envelope.getValueAtTime(time);\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.oscillator.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
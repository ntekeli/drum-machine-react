{"ast":null,"code":"import _toConsumableArray from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/toConsumableArray.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport var PhaseShiftAllpass = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(PhaseShiftAllpass, _ToneAudioNode);\n  var _super = _createSuper(PhaseShiftAllpass);\n  function PhaseShiftAllpass(options) {\n    var _this;\n    _classCallCheck(this, PhaseShiftAllpass);\n    _this = _super.call(this, options);\n    _this.name = \"PhaseShiftAllpass\";\n    _this.input = new Gain({\n      context: _this.context\n    });\n    /**\n     * The phase shifted output\n     */\n    _this.output = new Gain({\n      context: _this.context\n    });\n    /**\n     * The PhaseShifted allpass output\n     */\n    _this.offset90 = new Gain({\n      context: _this.context\n    });\n    var allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n    var allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n    _this._bank0 = _this._createAllPassFilterBank(allpassBank1Values);\n    _this._bank1 = _this._createAllPassFilterBank(allpassBank2Values);\n    _this._oneSampleDelay = _this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n    // connect Allpass filter banks\n    connectSeries.apply(void 0, [_this.input].concat(_toConsumableArray(_this._bank0), [_this._oneSampleDelay, _this.output]));\n    connectSeries.apply(void 0, [_this.input].concat(_toConsumableArray(_this._bank1), [_this.offset90]));\n    return _this;\n  }\n  /**\n   * Create all of the IIR filters from an array of values using the coefficient calculation.\n   */\n  _createClass(PhaseShiftAllpass, [{\n    key: \"_createAllPassFilterBank\",\n    value: function _createAllPassFilterBank(bankValues) {\n      var _this2 = this;\n      var nodes = bankValues.map(function (value) {\n        var coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n        return _this2.context.createIIRFilter(coefficients[0], coefficients[1]);\n      });\n      return nodes;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(PhaseShiftAllpass.prototype), \"dispose\", this).call(this);\n      this.input.dispose();\n      this.output.dispose();\n      this.offset90.dispose();\n      this._bank0.forEach(function (f) {\n        return f.disconnect();\n      });\n      this._bank1.forEach(function (f) {\n        return f.disconnect();\n      });\n      this._oneSampleDelay.disconnect();\n      return this;\n    }\n  }]);\n  return PhaseShiftAllpass;\n}(ToneAudioNode);","map":{"version":3,"mappings":";;;;;;;AAAA,SAASA,IAAI,QAAQ,yBAAyB;AAC9C,SAASC,aAAa,EAAEC,aAAa,QAA8B,kCAAkC;AAErG;;;;;;;;AAQA,WAAaC,iBAAkB;EAAA;EAAA;EA+B9B,2BAAYC,OAAuC;IAAA;IAAA;IAElD,0BAAMA,OAAO;IA/BL,UAAI,GAAW,mBAAmB;IAElC,WAAK,GAAG,IAAIJ,IAAI,CAAC;MAAEK,OAAO,EAAE,MAAKA;IAAO,CAAE,CAAC;IAiBpD;;;IAGS,YAAM,GAAG,IAAIL,IAAI,CAAC;MAAEK,OAAO,EAAE,MAAKA;IAAO,CAAE,CAAC;IAErD;;;IAGS,cAAQ,GAAG,IAAIL,IAAI,CAAC;MAAEK,OAAO,EAAE,MAAKA;IAAO,CAAE,CAAC;IAMtD,IAAMC,kBAAkB,GAAG,CAAC,SAAS,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,CAAC;IACzF,IAAMC,kBAAkB,GAAG,CAAC,eAAe,EAAE,eAAe,EAAE,eAAe,EAAE,eAAe,CAAC;IAE/F,MAAKC,MAAM,GAAG,MAAKC,wBAAwB,CAACH,kBAAkB,CAAC;IAC/D,MAAKI,MAAM,GAAG,MAAKD,wBAAwB,CAACF,kBAAkB,CAAC;IAC/D,MAAKI,eAAe,GAAG,MAAKN,OAAO,CAACO,eAAe,CAAC,CAAC,GAAG,EAAE,GAAG,CAAC,EAAE,CAAC,GAAG,EAAE,GAAG,CAAC,CAAC;IAE3E;IACAX,aAAa,gBAAC,MAAKY,KAAK,4BAAK,MAAKL,MAAM,IAAE,MAAKG,eAAe,EAAE,MAAKG,MAAM,GAAC;IAC5Eb,aAAa,gBAAC,MAAKY,KAAK,4BAAK,MAAKH,MAAM,IAAE,MAAKK,QAAQ,GAAC;IAAC;EAC1D;EAEA;;;EAAA;IAAA;IAAA,OAGQ,kCAAyBC,UAAoB;MAAA;MACpD,IAAMC,KAAK,GAAoBD,UAAU,CAACE,GAAG,CAAC,eAAK,EAAG;QACrD,IAAMC,YAAY,GAAG,CAAC,CAACC,KAAK,GAAGA,KAAK,EAAE,CAAC,EAAE,CAAC,CAAC,CAAC,EAAE,CAAC,CAAC,EAAE,CAAC,EAAE,EAAEA,KAAK,GAAGA,KAAK,CAAC,CAAC,CAAC;QACvE,OAAO,MAAI,CAACf,OAAO,CAACO,eAAe,CAACO,YAAY,CAAC,CAAC,CAAC,EAAEA,YAAY,CAAC,CAAC,CAAC,CAAC;MACtE,CAAC,CAAC;MAEF,OAAOF,KAAK;IACb;EAAC;IAAA;IAAA,OAED,mBAAO;MACN;MACA,IAAI,CAACJ,KAAK,CAACQ,OAAO,EAAE;MACpB,IAAI,CAACP,MAAM,CAACO,OAAO,EAAE;MACrB,IAAI,CAACN,QAAQ,CAACM,OAAO,EAAE;MACvB,IAAI,CAACb,MAAM,CAACc,OAAO,CAAC,WAAC;QAAA,OAAIC,CAAC,CAACC,UAAU,EAAE;MAAA,EAAC;MACxC,IAAI,CAACd,MAAM,CAACY,OAAO,CAAC,WAAC;QAAA,OAAIC,CAAC,CAACC,UAAU,EAAE;MAAA,EAAC;MACxC,IAAI,CAACb,eAAe,CAACa,UAAU,EAAE;MACjC,OAAO,IAAI;IACZ;EAAC;EAAA;AAAA,EApEqCtB,aAAmC","names":["Gain","connectSeries","ToneAudioNode","PhaseShiftAllpass","options","context","allpassBank1Values","allpassBank2Values","_bank0","_createAllPassFilterBank","_bank1","_oneSampleDelay","createIIRFilter","input","output","offset90","bankValues","nodes","map","coefficients","value","dispose","forEach","f","disconnect"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\component\\filter\\PhaseShiftAllpass.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { connectSeries, ToneAudioNode, ToneAudioNodeOptions } from \"../../core/context/ToneAudioNode\";\n\n/**\n * PhaseShiftAllpass is an very efficient implementation of a Hilbert Transform\n * using two Allpass filter banks whose outputs have a phase difference of 90째.\n * Here the `offset90` phase is offset by +90째 in relation to `output`.\n * Coefficients and structure was developed by Olli Niemitalo.\n * For more details see: http://yehar.com/blog/?p=368\n * @category Component\n */\nexport class PhaseShiftAllpass extends ToneAudioNode<ToneAudioNodeOptions> {\n\n\treadonly name: string = \"PhaseShiftAllpass\";\n\n\treadonly input = new Gain({ context: this.context });\n\n\t/**\n\t * The Allpass filter in the first bank\n\t */\n\tprivate _bank0: IIRFilterNode[];\n\n\t/**\n\t * The Allpass filter in the seconds bank\n\t */\n\tprivate _bank1: IIRFilterNode[];\n\n\t/**\n\t * A IIR filter implementing a delay by one sample used by the first bank\n\t */\n\tprivate _oneSampleDelay: IIRFilterNode;\n\n\t/**\n\t * The phase shifted output\n\t */\n\treadonly output = new Gain({ context: this.context });\n\n\t/**\n\t * The PhaseShifted allpass output\n\t */\n\treadonly offset90 = new Gain({ context: this.context });\n\n\tconstructor(options?: Partial<ToneAudioNodeOptions>) {\n\n\t\tsuper(options);\n\n\t\tconst allpassBank1Values = [0.6923878, 0.9360654322959, 0.9882295226860, 0.9987488452737];\n\t\tconst allpassBank2Values = [0.4021921162426, 0.8561710882420, 0.9722909545651, 0.9952884791278];\n\n\t\tthis._bank0 = this._createAllPassFilterBank(allpassBank1Values);\n\t\tthis._bank1 = this._createAllPassFilterBank(allpassBank2Values);\n\t\tthis._oneSampleDelay = this.context.createIIRFilter([0.0, 1.0], [1.0, 0.0]);\n\n\t\t// connect Allpass filter banks\n\t\tconnectSeries(this.input, ...this._bank0, this._oneSampleDelay, this.output);\n\t\tconnectSeries(this.input, ...this._bank1, this.offset90);\n\t}\n\n\t/**\n\t * Create all of the IIR filters from an array of values using the coefficient calculation.\n\t */\n\tprivate _createAllPassFilterBank(bankValues: number[]): IIRFilterNode[] {\n\t\tconst nodes: IIRFilterNode[] = bankValues.map(value => {\n\t\t\tconst coefficients = [[value * value, 0, -1], [1, 0, -(value * value)]];\n\t\t\treturn this.context.createIIRFilter(coefficients[0], coefficients[1]);\n\t\t});\n\n\t\treturn nodes;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.input.dispose();\n\t\tthis.output.dispose();\n\t\tthis.offset90.dispose();\n\t\tthis._bank0.forEach(f => f.disconnect());\n\t\tthis._bank1.forEach(f => f.disconnect());\n\t\tthis._oneSampleDelay.disconnect();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nexport var createAudioParamRenderer = function createAudioParamRenderer(automationEventList) {\n  return {\n    replay: function replay(audioParam) {\n      var _iterator = _createForOfIteratorHelper(automationEventList),\n        _step;\n      try {\n        for (_iterator.s(); !(_step = _iterator.n()).done;) {\n          var automationEvent = _step.value;\n          if (automationEvent.type === 'exponentialRampToValue') {\n            var endTime = automationEvent.endTime,\n              value = automationEvent.value;\n            audioParam.exponentialRampToValueAtTime(value, endTime);\n          } else if (automationEvent.type === 'linearRampToValue') {\n            var _endTime = automationEvent.endTime,\n              _value = automationEvent.value;\n            audioParam.linearRampToValueAtTime(_value, _endTime);\n          } else if (automationEvent.type === 'setTarget') {\n            var startTime = automationEvent.startTime,\n              target = automationEvent.target,\n              timeConstant = automationEvent.timeConstant;\n            audioParam.setTargetAtTime(target, startTime, timeConstant);\n          } else if (automationEvent.type === 'setValue') {\n            var _startTime = automationEvent.startTime,\n              _value2 = automationEvent.value;\n            audioParam.setValueAtTime(_value2, _startTime);\n          } else if (automationEvent.type === 'setValueCurve') {\n            var duration = automationEvent.duration,\n              _startTime2 = automationEvent.startTime,\n              values = automationEvent.values;\n            audioParam.setValueCurveAtTime(values, _startTime2, duration);\n          } else {\n            throw new Error(\"Can't apply an unknown automation.\");\n          }\n        }\n      } catch (err) {\n        _iterator.e(err);\n      } finally {\n        _iterator.f();\n      }\n    }\n  };\n};","map":{"version":3,"mappings":";AAEA,OAAO,IAAMA,wBAAwB,GAA+B,SAAvDA,wBAAwB,CAAgCC,mBAAmB,EAAI;EACxF,OAAO;IACHC,MAAM,kBAACC,UAA6B;MAAA,2CACFF,mBAAmB;QAAA;MAAA;QAAjD,oDAAmD;UAAA,IAAxCG,eAAe;UACtB,IAAIA,eAAe,CAACC,IAAI,KAAK,wBAAwB,EAAE;YACnD,IAAQC,OAAO,GAAYF,eAAe,CAAlCE,OAAO;cAAEC,KAAK,GAAKH,eAAe,CAAzBG,KAAK;YAEtBJ,UAAU,CAACK,4BAA4B,CAACD,KAAK,EAAED,OAAO,CAAC;WAC1D,MAAM,IAAIF,eAAe,CAACC,IAAI,KAAK,mBAAmB,EAAE;YACrD,IAAQC,QAAO,GAAYF,eAAe,CAAlCE,OAAO;cAAEC,MAAK,GAAKH,eAAe,CAAzBG,KAAK;YAEtBJ,UAAU,CAACM,uBAAuB,CAACF,MAAK,EAAED,QAAO,CAAC;WACrD,MAAM,IAAIF,eAAe,CAACC,IAAI,KAAK,WAAW,EAAE;YAC7C,IAAQK,SAAS,GAA2BN,eAAe,CAAnDM,SAAS;cAAEC,MAAM,GAAmBP,eAAe,CAAxCO,MAAM;cAAEC,YAAY,GAAKR,eAAe,CAAhCQ,YAAY;YAEvCT,UAAU,CAACU,eAAe,CAACF,MAAM,EAAED,SAAS,EAAEE,YAAY,CAAC;WAC9D,MAAM,IAAIR,eAAe,CAACC,IAAI,KAAK,UAAU,EAAE;YAC5C,IAAQK,UAAS,GAAYN,eAAe,CAApCM,SAAS;cAAEH,OAAK,GAAKH,eAAe,CAAzBG,KAAK;YAExBJ,UAAU,CAACW,cAAc,CAACP,OAAK,EAAEG,UAAS,CAAC;WAC9C,MAAM,IAAIN,eAAe,CAACC,IAAI,KAAK,eAAe,EAAE;YACjD,IAAQU,QAAQ,GAAwBX,eAAe,CAA/CW,QAAQ;cAAEL,WAAS,GAAaN,eAAe,CAArCM,SAAS;cAAEM,MAAM,GAAKZ,eAAe,CAA1BY,MAAM;YAEnCb,UAAU,CAACc,mBAAmB,CAACD,MAAM,EAAEN,WAAS,EAAEK,QAAQ,CAAC;WAC9D,MAAM;YACH,MAAM,IAAIG,KAAK,CAAC,oCAAoC,CAAC;;;MAE5D;QAAA;MAAA;QAAA;MAAA;IACL;GACH;AACL,CAAC","names":["createAudioParamRenderer","automationEventList","replay","audioParam","automationEvent","type","endTime","value","exponentialRampToValueAtTime","linearRampToValueAtTime","startTime","target","timeConstant","setTargetAtTime","setValueAtTime","duration","values","setValueCurveAtTime","Error"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-param-renderer.ts"],"sourcesContent":["import { TAudioParamRendererFactory, TNativeAudioParam } from '../types';\n\nexport const createAudioParamRenderer: TAudioParamRendererFactory = (automationEventList) => {\n    return {\n        replay(audioParam: TNativeAudioParam): void {\n            for (const automationEvent of automationEventList) {\n                if (automationEvent.type === 'exponentialRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.exponentialRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'linearRampToValue') {\n                    const { endTime, value } = automationEvent;\n\n                    audioParam.linearRampToValueAtTime(value, endTime);\n                } else if (automationEvent.type === 'setTarget') {\n                    const { startTime, target, timeConstant } = automationEvent;\n\n                    audioParam.setTargetAtTime(target, startTime, timeConstant);\n                } else if (automationEvent.type === 'setValue') {\n                    const { startTime, value } = automationEvent;\n\n                    audioParam.setValueAtTime(value, startTime);\n                } else if (automationEvent.type === 'setValueCurve') {\n                    const { duration, startTime, values } = automationEvent;\n\n                    audioParam.setValueCurveAtTime(values, startTime, duration);\n                } else {\n                    throw new Error(\"Can't apply an unknown automation.\");\n                }\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
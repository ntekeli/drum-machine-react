{"ast":null,"code":"import _objectSpread from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nvar DEFAULT_OPTIONS = {\n  numberOfChannels: 1\n};\nexport var createAudioBufferConstructor = function createAudioBufferConstructor(audioBufferStore, cacheTestResult, createNotSupportedError, nativeAudioBufferConstructor, nativeOfflineAudioContextConstructor, testNativeAudioBufferConstructorSupport, wrapAudioBufferCopyChannelMethods, wrapAudioBufferCopyChannelMethodsOutOfBounds) {\n  var nativeOfflineAudioContext = null;\n  return /*#__PURE__*/function (_Symbol$hasInstance) {\n    function AudioBuffer(options) {\n      _classCallCheck(this, AudioBuffer);\n      if (nativeOfflineAudioContextConstructor === null) {\n        throw new Error('Missing the native OfflineAudioContext constructor.');\n      }\n      var _DEFAULT_OPTIONS$opti = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options),\n        length = _DEFAULT_OPTIONS$opti.length,\n        numberOfChannels = _DEFAULT_OPTIONS$opti.numberOfChannels,\n        sampleRate = _DEFAULT_OPTIONS$opti.sampleRate;\n      if (nativeOfflineAudioContext === null) {\n        nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n      }\n      /*\n       * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n       * factory function. But since Firefox also supports the constructor everything should be fine.\n       */\n      var audioBuffer = nativeAudioBufferConstructor !== null && cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport) ? new nativeAudioBufferConstructor({\n        length: length,\n        numberOfChannels: numberOfChannels,\n        sampleRate: sampleRate\n      }) : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n      // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n      if (audioBuffer.numberOfChannels === 0) {\n        throw createNotSupportedError();\n      }\n      // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n      // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n      if (typeof audioBuffer.copyFromChannel !== 'function') {\n        wrapAudioBufferCopyChannelMethods(audioBuffer);\n        wrapAudioBufferGetChannelDataMethod(audioBuffer);\n        // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n      } else if (!cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, function () {\n        return testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer);\n      })) {\n        wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n      }\n      audioBufferStore.add(audioBuffer);\n      /*\n       * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n       * (Offline)AudioContexts.\n       */\n      return audioBuffer;\n    }\n    _createClass(AudioBuffer, null, [{\n      key: _Symbol$hasInstance,\n      value: function value(instance) {\n        return instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype || audioBufferStore.has(instance);\n      }\n    }]);\n    return AudioBuffer;\n  }(Symbol.hasInstance);\n};","map":{"version":3,"mappings":";;;AAAA,SAASA,mDAAmD,QAAQ,yEAAyE;AAC7I,SAASC,mCAAmC,QAAQ,sDAAsD;AAI1G,IAAMC,eAAe,GAAG;EACpBC,gBAAgB,EAAE;CACZ;AAEV,OAAO,IAAMC,4BAA4B,GAAmC,SAA/DA,4BAA4B,CACrCC,gBAAgB,EAChBC,eAAe,EACfC,uBAAuB,EACvBC,4BAA4B,EAC5BC,oCAAoC,EACpCC,uCAAuC,EACvCC,iCAAiC,EACjCC,4CAA4C,EAC5C;EACA,IAAIC,yBAAyB,GAAsC,IAAI;EAEvE;IAsBI,qBAAYC,OAA4B;MAAA;MACpC,IAAIL,oCAAoC,KAAK,IAAI,EAAE;QAC/C,MAAM,IAAIM,KAAK,CAAC,qDAAqD,CAAC;;MAG1E,4DAAsDb,eAAe,GAAKY,OAAO;QAAzEE,MAAM,yBAANA,MAAM;QAAEb,gBAAgB,yBAAhBA,gBAAgB;QAAEc,UAAU,yBAAVA,UAAU;MAE5C,IAAIJ,yBAAyB,KAAK,IAAI,EAAE;QACpCA,yBAAyB,GAAG,IAAIJ,oCAAoC,CAAC,CAAC,EAAE,CAAC,EAAE,KAAK,CAAC;;MAGrF;;;;MAIA,IAAMS,WAAW,GACbV,4BAA4B,KAAK,IAAI,IACrCF,eAAe,CAACI,uCAAuC,EAAEA,uCAAuC,CAAC,GAC3F,IAAIF,4BAA4B,CAAC;QAAEQ,MAAM,EAANA,MAAM;QAAEb,gBAAgB,EAAhBA,gBAAgB;QAAEc,UAAU,EAAVA;MAAU,CAAE,CAAC,GAC1EJ,yBAAyB,CAACM,YAAY,CAAChB,gBAAgB,EAAEa,MAAM,EAAEC,UAAU,CAAC;MAEtF;MACA,IAAIC,WAAW,CAACf,gBAAgB,KAAK,CAAC,EAAE;QACpC,MAAMI,uBAAuB,EAAE;;MAGnC;MACA;MACA,IAAI,OAAOW,WAAW,CAACE,eAAe,KAAK,UAAU,EAAE;QACnDT,iCAAiC,CAACO,WAAW,CAAC;QAC9CjB,mCAAmC,CAACiB,WAAW,CAAC;QAChD;OACH,MAAM,IACH,CAACZ,eAAe,CAACN,mDAAmD,EAAE;QAAA,OAClEA,mDAAmD,CAACkB,WAAW,CAAC;MAAA,EACnE,EACH;QACEN,4CAA4C,CAACM,WAAW,CAAC;;MAG7Db,gBAAgB,CAACgB,GAAG,CAACH,WAAW,CAAC;MAEjC;;;;MAIA,OAAOA,WAAW;IACtB;IAAC;MAAA;MAAA,OAEM,eAA4BI,QAAiB;QAChD,OACKA,QAAQ,KAAK,IAAI,IAAI,OAAOA,QAAQ,KAAK,QAAQ,IAAIC,MAAM,CAACC,cAAc,CAACF,QAAQ,CAAC,KAAKG,WAAW,CAACC,SAAS,IAC/GrB,gBAAgB,CAACsB,GAAG,CAAML,QAAQ,CAAC;MAE3C;IAAC;IAAA;EAAA,EALcM,MAAM,CAACC,WAAW;AAOzC,CAAC","names":["testAudioBufferCopyChannelMethodsOutOfBoundsSupport","wrapAudioBufferGetChannelDataMethod","DEFAULT_OPTIONS","numberOfChannels","createAudioBufferConstructor","audioBufferStore","cacheTestResult","createNotSupportedError","nativeAudioBufferConstructor","nativeOfflineAudioContextConstructor","testNativeAudioBufferConstructorSupport","wrapAudioBufferCopyChannelMethods","wrapAudioBufferCopyChannelMethodsOutOfBounds","nativeOfflineAudioContext","options","Error","length","sampleRate","audioBuffer","createBuffer","copyFromChannel","add","instance","Object","getPrototypeOf","AudioBuffer","prototype","has","Symbol","hasInstance"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-buffer-constructor.ts"],"sourcesContent":["import { testAudioBufferCopyChannelMethodsOutOfBoundsSupport } from '../helpers/test-audio-buffer-copy-channel-methods-out-of-bounds-support';\nimport { wrapAudioBufferGetChannelDataMethod } from '../helpers/wrap-audio-buffer-get-channel-data-method';\nimport { IAudioBuffer, IAudioBufferOptions } from '../interfaces';\nimport { TAudioBufferConstructorFactory, TNativeOfflineAudioContext } from '../types';\n\nconst DEFAULT_OPTIONS = {\n    numberOfChannels: 1\n} as const;\n\nexport const createAudioBufferConstructor: TAudioBufferConstructorFactory = (\n    audioBufferStore,\n    cacheTestResult,\n    createNotSupportedError,\n    nativeAudioBufferConstructor,\n    nativeOfflineAudioContextConstructor,\n    testNativeAudioBufferConstructorSupport,\n    wrapAudioBufferCopyChannelMethods,\n    wrapAudioBufferCopyChannelMethodsOutOfBounds\n) => {\n    let nativeOfflineAudioContext: null | TNativeOfflineAudioContext = null;\n\n    return class AudioBuffer implements IAudioBuffer {\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyFromChannel!: (destination: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public copyToChannel!: (source: Float32Array, channelNumber: number, bufferOffset?: number) => void;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public duration!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public getChannelData!: (channel: number) => Float32Array;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public length!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public numberOfChannels!: number;\n\n        // This field needs to be defined to convince TypeScript that the IAudioBuffer will be implemented.\n        public sampleRate!: number;\n\n        constructor(options: IAudioBufferOptions) {\n            if (nativeOfflineAudioContextConstructor === null) {\n                throw new Error('Missing the native OfflineAudioContext constructor.');\n            }\n\n            const { length, numberOfChannels, sampleRate } = { ...DEFAULT_OPTIONS, ...options };\n\n            if (nativeOfflineAudioContext === null) {\n                nativeOfflineAudioContext = new nativeOfflineAudioContextConstructor(1, 1, 44100);\n            }\n\n            /*\n             * Bug #99: Firefox does not throw a NotSupportedError when the numberOfChannels is zero. But it only does it when using the\n             * factory function. But since Firefox also supports the constructor everything should be fine.\n             */\n            const audioBuffer =\n                nativeAudioBufferConstructor !== null &&\n                cacheTestResult(testNativeAudioBufferConstructorSupport, testNativeAudioBufferConstructorSupport)\n                    ? new nativeAudioBufferConstructor({ length, numberOfChannels, sampleRate })\n                    : nativeOfflineAudioContext.createBuffer(numberOfChannels, length, sampleRate);\n\n            // Bug #99: Safari does not throw an error when the numberOfChannels is zero.\n            if (audioBuffer.numberOfChannels === 0) {\n                throw createNotSupportedError();\n            }\n\n            // Bug #5: Safari does not support copyFromChannel() and copyToChannel().\n            // Bug #100: Safari does throw a wrong error when calling getChannelData() with an out-of-bounds value.\n            if (typeof audioBuffer.copyFromChannel !== 'function') {\n                wrapAudioBufferCopyChannelMethods(audioBuffer);\n                wrapAudioBufferGetChannelDataMethod(audioBuffer);\n                // Bug #157: Firefox does not allow the bufferOffset to be out-of-bounds.\n            } else if (\n                !cacheTestResult(testAudioBufferCopyChannelMethodsOutOfBoundsSupport, () =>\n                    testAudioBufferCopyChannelMethodsOutOfBoundsSupport(audioBuffer)\n                )\n            ) {\n                wrapAudioBufferCopyChannelMethodsOutOfBounds(audioBuffer);\n            }\n\n            audioBufferStore.add(audioBuffer);\n\n            /*\n             * This does violate all good pratices but it is necessary to allow this AudioBuffer to be used with native\n             * (Offline)AudioContexts.\n             */\n            return audioBuffer;\n        }\n\n        public static [Symbol.hasInstance](instance: unknown): boolean {\n            return (\n                (instance !== null && typeof instance === 'object' && Object.getPrototypeOf(instance) === AudioBuffer.prototype) ||\n                audioBufferStore.has(<any>instance)\n            );\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
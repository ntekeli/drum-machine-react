{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator } from \"./Oscillator\";\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport var LFO = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(LFO, _ToneAudioNode);\n  var _super = _createSuper(LFO);\n  function LFO() {\n    var _this;\n    _classCallCheck(this, LFO);\n    _this = _super.call(this, optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n    _this.name = \"LFO\";\n    /**\n     * The value that the LFO outputs when it's stopped\n     */\n    _this._stoppedValue = 0;\n    /**\n     * A private placeholder for the units\n     */\n    _this._units = \"number\";\n    /**\n     * If the input value is converted using the [[units]]\n     */\n    _this.convert = true;\n    /**\n     * Private methods borrowed from Param\n     */\n    // @ts-ignore\n    _this._fromType = Param.prototype._fromType;\n    // @ts-ignore\n    _this._toType = Param.prototype._toType;\n    // @ts-ignore\n    _this._is = Param.prototype._is;\n    // @ts-ignore\n    _this._clampValue = Param.prototype._clampValue;\n    var options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n    _this._oscillator = new Oscillator(options);\n    _this.frequency = _this._oscillator.frequency;\n    _this._amplitudeGain = new Gain({\n      context: _this.context,\n      gain: options.amplitude,\n      units: \"normalRange\"\n    });\n    _this.amplitude = _this._amplitudeGain.gain;\n    _this._stoppedSignal = new Signal({\n      context: _this.context,\n      units: \"audioRange\",\n      value: 0\n    });\n    _this._zeros = new Zero({\n      context: _this.context\n    });\n    _this._a2g = new AudioToGain({\n      context: _this.context\n    });\n    _this._scaler = _this.output = new Scale({\n      context: _this.context,\n      max: options.max,\n      min: options.min\n    });\n    _this.units = options.units;\n    _this.min = options.min;\n    _this.max = options.max;\n    // connect it up\n    _this._oscillator.chain(_this._amplitudeGain, _this._a2g, _this._scaler);\n    _this._zeros.connect(_this._a2g);\n    _this._stoppedSignal.connect(_this._a2g);\n    readOnly(_assertThisInitialized(_this), [\"amplitude\", \"frequency\"]);\n    _this.phase = options.phase;\n    return _this;\n  }\n  _createClass(LFO, [{\n    key: \"start\",\n    value:\n    /**\n     * Start the LFO.\n     * @param time The time the LFO will start\n     */\n    function start(time) {\n      time = this.toSeconds(time);\n      this._stoppedSignal.setValueAtTime(0, time);\n      this._oscillator.start(time);\n      return this;\n    }\n    /**\n     * Stop the LFO.\n     * @param  time The time the LFO will stop\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      time = this.toSeconds(time);\n      this._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n      this._oscillator.stop(time);\n      return this;\n    }\n    /**\n     * Sync the start/stop/pause to the transport\n     * and the frequency to the bpm of the transport\n     * @example\n     * const lfo = new Tone.LFO(\"8n\");\n     * lfo.sync().start(0);\n     * // the rate of the LFO will always be an eighth note, even as the tempo changes\n     */\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      this._oscillator.sync();\n      this._oscillator.syncFrequency();\n      return this;\n    }\n    /**\n     * unsync the LFO from transport control\n     */\n  }, {\n    key: \"unsync\",\n    value: function unsync() {\n      this._oscillator.unsync();\n      this._oscillator.unsyncFrequency();\n      return this;\n    }\n    /**\n     * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n     */\n  }, {\n    key: \"_setStoppedValue\",\n    value: function _setStoppedValue() {\n      this._stoppedValue = this._oscillator.getInitialValue();\n      this._stoppedSignal.value = this._stoppedValue;\n    }\n    /**\n     * The minimum output of the LFO.\n     */\n  }, {\n    key: \"min\",\n    get: function get() {\n      return this._toType(this._scaler.min);\n    },\n    set: function set(min) {\n      min = this._fromType(min);\n      this._scaler.min = min;\n    }\n    /**\n     * The maximum output of the LFO.\n     */\n  }, {\n    key: \"max\",\n    get: function get() {\n      return this._toType(this._scaler.max);\n    },\n    set: function set(max) {\n      max = this._fromType(max);\n      this._scaler.max = max;\n    }\n    /**\n     * The type of the oscillator: See [[Oscillator.type]]\n     */\n  }, {\n    key: \"type\",\n    get: function get() {\n      return this._oscillator.type;\n    },\n    set: function set(type) {\n      this._oscillator.type = type;\n      this._setStoppedValue();\n    }\n    /**\n     * The oscillator's partials array: See [[Oscillator.partials]]\n     */\n  }, {\n    key: \"partials\",\n    get: function get() {\n      return this._oscillator.partials;\n    },\n    set: function set(partials) {\n      this._oscillator.partials = partials;\n      this._setStoppedValue();\n    }\n    /**\n     * The phase of the LFO.\n     */\n  }, {\n    key: \"phase\",\n    get: function get() {\n      return this._oscillator.phase;\n    },\n    set: function set(phase) {\n      this._oscillator.phase = phase;\n      this._setStoppedValue();\n    }\n    /**\n     * The output units of the LFO.\n     */\n  }, {\n    key: \"units\",\n    get: function get() {\n      return this._units;\n    },\n    set: function set(val) {\n      var currentMin = this.min;\n      var currentMax = this.max;\n      // convert the min and the max\n      this._units = val;\n      this.min = currentMin;\n      this.max = currentMax;\n    }\n    /**\n     * Returns the playback state of the source, either \"started\" or \"stopped\".\n     */\n  }, {\n    key: \"state\",\n    get: function get() {\n      return this._oscillator.state;\n    }\n    /**\n     * @param node the destination to connect to\n     * @param outputNum the optional output number\n     * @param inputNum the input number\n     */\n  }, {\n    key: \"connect\",\n    value: function connect(node, outputNum, inputNum) {\n      if (node instanceof Param || node instanceof Signal) {\n        this.convert = node.convert;\n        this.units = node.units;\n      }\n      connectSignal(this, node, outputNum, inputNum);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(LFO.prototype), \"dispose\", this).call(this);\n      this._oscillator.dispose();\n      this._stoppedSignal.dispose();\n      this._zeros.dispose();\n      this._scaler.dispose();\n      this._a2g.dispose();\n      this._amplitudeGain.dispose();\n      this.amplitude.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Oscillator.getDefaults(), {\n        amplitude: 1,\n        frequency: \"4n\",\n        max: 1,\n        min: 0,\n        type: \"sine\",\n        units: \"number\"\n      });\n    }\n  }]);\n  return LFO;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["Gain","Param","ToneAudioNode","optionsFromArguments","readOnly","AudioToGain","Scale","connectSignal","Signal","Zero","Oscillator","LFO","getDefaults","arguments","prototype","_fromType","_toType","_is","_clampValue","options","_oscillator","frequency","_amplitudeGain","context","gain","amplitude","units","_stoppedSignal","value","_zeros","_a2g","_scaler","output","max","min","chain","connect","phase","time","toSeconds","setValueAtTime","start","_stoppedValue","stop","sync","syncFrequency","unsync","unsyncFrequency","getInitialValue","type","_setStoppedValue","partials","_units","val","currentMin","currentMax","state","node","outputNum","inputNum","convert","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\oscillator\\LFO.ts"],"sourcesContent":["import { Gain } from \"../../core/context/Gain\";\nimport { Param } from \"../../core/context/Param\";\nimport { InputNode, OutputNode, ToneAudioNode } from \"../../core/context/ToneAudioNode\";\nimport { Degrees, Frequency, NormalRange, Time, UnitName } from \"../../core/type/Units\";\nimport { optionsFromArguments } from \"../../core/util/Defaults\";\nimport { readOnly } from \"../../core/util/Interface\";\nimport { BasicPlaybackState } from \"../../core/util/StateTimeline\";\nimport { AudioToGain } from \"../../signal/AudioToGain\";\nimport { Scale } from \"../../signal/Scale\";\nimport { connectSignal, Signal } from \"../../signal/Signal\";\nimport { Zero } from \"../../signal/Zero\";\nimport { Oscillator, ToneOscillatorType } from \"./Oscillator\";\nimport { ToneOscillatorConstructorOptions, ToneOscillatorOptions } from \"./OscillatorInterface\";\n\nexport type LFOOptions = {\n\tmin: number;\n\tmax: number;\n\tamplitude: NormalRange;\n\tunits: UnitName;\n} & ToneOscillatorOptions;\n\n/**\n * LFO stands for low frequency oscillator. LFO produces an output signal\n * which can be attached to an AudioParam or Tone.Signal\n * in order to modulate that parameter with an oscillator. The LFO can\n * also be synced to the transport to start/stop and change when the tempo changes.\n * @example\n * return Tone.Offline(() => {\n * \tconst lfo = new Tone.LFO(\"4n\", 400, 4000).start().toDestination();\n * }, 0.5, 1);\n * @category Source\n */\nexport class LFO extends ToneAudioNode<LFOOptions> {\n\n\treadonly name: string = \"LFO\";\n\n\t/**\n\t * The oscillator.\n\t */\n\tprivate _oscillator: Oscillator;\n\n\t/**\n\t * The gain of the output\n\t */\n\tprivate _amplitudeGain: Gain<\"normalRange\">;\n\n\t/**\n\t * The amplitude of the LFO, which controls the output range between\n\t * the min and max output. For example if the min is -10 and the max\n\t * is 10, setting the amplitude to 0.5 would make the LFO modulate\n\t * between -5 and 5.\n\t */\n\treadonly amplitude: Param<\"normalRange\">;\n\n\t/**\n\t * The signal which is output when the LFO is stopped\n\t */\n\tprivate _stoppedSignal: Signal<\"audioRange\">;\n\n\t/**\n\t * Just outputs zeros. This is used so that scaled signal is not\n\t * optimized to silence.\n\t */\n\tprivate _zeros: Zero;\n\n\t/**\n\t * The value that the LFO outputs when it's stopped\n\t */\n\tprivate _stoppedValue = 0;\n\n\t/**\n\t * Convert the oscillators audio range to an output between 0-1 so it can be scaled\n\t */\n\tprivate _a2g: AudioToGain;\n\n\t/**\n\t * Scales the final output to the min and max value\n\t */\n\tprivate _scaler: Scale;\n\n\t/**\n\t * The output of the LFO\n\t */\n\treadonly output: OutputNode;\n\n\t/**\n\t * There is no input node\n\t */\n\treadonly input: undefined;\n\n\t/**\n\t * A private placeholder for the units\n\t */\n\tprivate _units: UnitName = \"number\";\n\n\t/**\n\t * If the input value is converted using the [[units]]\n\t */\n\tconvert = true;\n\n\t/**\n\t * The frequency value of the LFO\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * @param frequency The frequency of the oscillation.\n\t * Typically, LFOs will be in the frequency range of 0.1 to 10 hertz.\n\t * @param min The minimum output value of the LFO.\n\t * @param max The maximum value of the LFO.\n\t */\n\tconstructor(frequency?: Frequency, min?: number, max?: number);\n\tconstructor(options?: Partial<LFOOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]));\n\t\tconst options = optionsFromArguments(LFO.getDefaults(), arguments, [\"frequency\", \"min\", \"max\"]);\n\n\t\tthis._oscillator = new Oscillator(options as ToneOscillatorConstructorOptions);\n\n\t\tthis.frequency = this._oscillator.frequency;\n\n\t\tthis._amplitudeGain = new Gain({\n\t\t\tcontext: this.context,\n\t\t\tgain: options.amplitude,\n\t\t\tunits: \"normalRange\",\n\t\t});\n\t\tthis.amplitude = this._amplitudeGain.gain;\n\t\tthis._stoppedSignal = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"audioRange\",\n\t\t\tvalue: 0,\n\t\t});\n\t\tthis._zeros = new Zero({ context: this.context });\n\t\tthis._a2g = new AudioToGain({ context: this.context });\n\t\tthis._scaler = this.output = new Scale({\n\t\t\tcontext: this.context,\n\t\t\tmax: options.max,\n\t\t\tmin: options.min,\n\t\t});\n\n\t\tthis.units = options.units;\n\t\tthis.min = options.min;\n\t\tthis.max = options.max;\n\n\t\t// connect it up\n\t\tthis._oscillator.chain(this._amplitudeGain, this._a2g, this._scaler);\n\t\tthis._zeros.connect(this._a2g);\n\t\tthis._stoppedSignal.connect(this._a2g);\n\t\treadOnly(this, [\"amplitude\", \"frequency\"]);\n\t\tthis.phase = options.phase;\n\t}\n\n\tstatic getDefaults(): LFOOptions {\n\t\treturn Object.assign(Oscillator.getDefaults(), {\n\t\t\tamplitude: 1,\n\t\t\tfrequency: \"4n\",\n\t\t\tmax: 1,\n\t\t\tmin: 0,\n\t\t\ttype: \"sine\",\n\t\t\tunits: \"number\" as UnitName,\n\t\t});\n\t}\n\n\t/**\n\t * Start the LFO.\n\t * @param time The time the LFO will start\n\t */\n\tstart(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(0, time);\n\t\tthis._oscillator.start(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the LFO.\n\t * @param  time The time the LFO will stop\n\t */\n\tstop(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._stoppedSignal.setValueAtTime(this._stoppedValue, time);\n\t\tthis._oscillator.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sync the start/stop/pause to the transport\n\t * and the frequency to the bpm of the transport\n\t * @example\n\t * const lfo = new Tone.LFO(\"8n\");\n\t * lfo.sync().start(0);\n\t * // the rate of the LFO will always be an eighth note, even as the tempo changes\n\t */\n\tsync(): this {\n\t\tthis._oscillator.sync();\n\t\tthis._oscillator.syncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * unsync the LFO from transport control\n\t */\n\tunsync(): this {\n\t\tthis._oscillator.unsync();\n\t\tthis._oscillator.unsyncFrequency();\n\t\treturn this;\n\t}\n\n\t/**\n\t * After the oscillator waveform is updated, reset the `_stoppedSignal` value to match the updated waveform\n\t */\n\tprivate _setStoppedValue() {\n\t\tthis._stoppedValue = this._oscillator.getInitialValue();\n\t\tthis._stoppedSignal.value = this._stoppedValue;\n\t}\n\n\t/**\n\t * The minimum output of the LFO.\n\t */\n\tget min(): number {\n\t\treturn this._toType(this._scaler.min);\n\t}\n\tset min(min) {\n\t\tmin = this._fromType(min);\n\t\tthis._scaler.min = min;\n\t}\n\n\t/**\n\t * The maximum output of the LFO.\n\t */\n\tget max(): number {\n\t\treturn this._toType(this._scaler.max);\n\t}\n\tset max(max) {\n\t\tmax = this._fromType(max);\n\t\tthis._scaler.max = max;\n\t}\n\n\t/**\n\t * The type of the oscillator: See [[Oscillator.type]]\n\t */\n\tget type(): ToneOscillatorType {\n\t\treturn this._oscillator.type;\n\t}\n\tset type(type) {\n\t\tthis._oscillator.type = type;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The oscillator's partials array: See [[Oscillator.partials]]\n\t */\n\tget partials(): number[] {\n\t\treturn this._oscillator.partials;\n\t}\n\tset partials(partials) {\n\t\tthis._oscillator.partials = partials;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The phase of the LFO.\n\t */\n\tget phase(): Degrees {\n\t\treturn this._oscillator.phase;\n\t}\n\tset phase(phase) {\n\t\tthis._oscillator.phase = phase;\n\t\tthis._setStoppedValue();\n\t}\n\n\t/**\n\t * The output units of the LFO.\n\t */\n\tget units(): UnitName {\n\t\treturn this._units;\n\t}\n\tset units(val) {\n\t\tconst currentMin = this.min;\n\t\tconst currentMax = this.max;\n\t\t// convert the min and the max\n\t\tthis._units = val;\n\t\tthis.min = currentMin;\n\t\tthis.max = currentMax;\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\" or \"stopped\".\n\t */\n\tget state(): BasicPlaybackState {\n\t\treturn this._oscillator.state;\n\t}\n\n\t/**\n\t * @param node the destination to connect to\n\t * @param outputNum the optional output number\n\t * @param inputNum the input number\n\t */\n\tconnect(node: InputNode, outputNum?: number, inputNum?: number): this {\n\t\tif (node instanceof Param || node instanceof Signal) {\n\t\t\tthis.convert = node.convert;\n\t\t\tthis.units = node.units;\n\t\t}\n\t\tconnectSignal(this, node, outputNum, inputNum);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Private methods borrowed from Param\n\t */\n\t// @ts-ignore\n\tprivate _fromType = Param.prototype._fromType;\n\t// @ts-ignore\n\tprivate _toType = Param.prototype._toType;\n\t// @ts-ignore\n\tprivate _is = Param.prototype._is;\n\t// @ts-ignore\n\tprivate _clampValue = Param.prototype._clampValue;\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._oscillator.dispose();\n\t\tthis._stoppedSignal.dispose();\n\t\tthis._zeros.dispose();\n\t\tthis._scaler.dispose();\n\t\tthis._a2g.dispose();\n\t\tthis._amplitudeGain.dispose();\n\t\tthis.amplitude.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { Signal } from \"../../signal/Signal\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport var TickSignal = /*#__PURE__*/function (_Signal) {\n  _inherits(TickSignal, _Signal);\n  var _super = _createSuper(TickSignal);\n  function TickSignal() {\n    var _this;\n    _classCallCheck(this, TickSignal);\n    _this = _super.call(this, optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n    _this.name = \"TickSignal\";\n    var options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n    _this.input = _this._param = new TickParam({\n      context: _this.context,\n      convert: options.convert,\n      multiplier: options.multiplier,\n      param: _this._constantSource.offset,\n      units: options.units,\n      value: options.value\n    });\n    return _this;\n  }\n  _createClass(TickSignal, [{\n    key: \"ticksToTime\",\n    value: function ticksToTime(ticks, when) {\n      return this._param.ticksToTime(ticks, when);\n    }\n  }, {\n    key: \"timeToTicks\",\n    value: function timeToTicks(duration, when) {\n      return this._param.timeToTicks(duration, when);\n    }\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      return this._param.getTimeOfTick(tick);\n    }\n  }, {\n    key: \"getDurationOfTicks\",\n    value: function getDurationOfTicks(ticks, time) {\n      return this._param.getDurationOfTicks(ticks, time);\n    }\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      return this._param.getTicksAtTime(time);\n    }\n    /**\n     * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n     */\n  }, {\n    key: \"multiplier\",\n    get: function get() {\n      return this._param.multiplier;\n    },\n    set: function set(m) {\n      this._param.multiplier = m;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSignal.prototype), \"dispose\", this).call(this);\n      this._param.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Signal.getDefaults(), {\n        multiplier: 1,\n        units: \"hertz\",\n        value: 1\n      });\n    }\n  }]);\n  return TickSignal;\n}(Signal);","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,MAAM,QAAuB,qBAAqB;AAG3D,SAASC,oBAAoB,QAAQ,kBAAkB;AACvD,SAASC,SAAS,QAAQ,aAAa;AAOvC;;;;;;;;;AASA,WAAaC,UAA6C;EAAA;EAAA;EAezD;IAAA;IAAA;IAEC,0BAAMF,oBAAoB,CAACE,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;IAflE,UAAI,GAAW,YAAY;IAgBnC,IAAMC,OAAO,GAAGL,oBAAoB,CAACE,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,EAAE,CAAC,OAAO,CAAC,CAAC;IAEpF,MAAKE,KAAK,GAAG,MAAKC,MAAM,GAAG,IAAIN,SAAS,CAAC;MACxCO,OAAO,EAAE,MAAKA,OAAO;MACrBC,OAAO,EAAEJ,OAAO,CAACI,OAAO;MACxBC,UAAU,EAAEL,OAAO,CAACK,UAAU;MAC9BC,KAAK,EAAE,MAAKC,eAAe,CAACC,MAAM;MAClCC,KAAK,EAAET,OAAO,CAACS,KAAK;MACpBC,KAAK,EAAEV,OAAO,CAACU;KACf,CAAC;IAAC;EACJ;EAAC;IAAA;IAAA,OAUD,qBAAYC,KAAY,EAAEC,IAAU;MACnC,OAAO,IAAI,CAACV,MAAM,CAACW,WAAW,CAACF,KAAK,EAAEC,IAAI,CAAC;IAC5C;EAAC;IAAA;IAAA,OAED,qBAAYE,QAAc,EAAEF,IAAU;MACrC,OAAO,IAAI,CAACV,MAAM,CAACa,WAAW,CAACD,QAAQ,EAAEF,IAAI,CAAC;IAC/C;EAAC;IAAA;IAAA,OAED,uBAAcI,IAAW;MACxB,OAAO,IAAI,CAACd,MAAM,CAACe,aAAa,CAACD,IAAI,CAAC;IACvC;EAAC;IAAA;IAAA,OAED,4BAAmBL,KAAY,EAAEO,IAAU;MAC1C,OAAO,IAAI,CAAChB,MAAM,CAACiB,kBAAkB,CAACR,KAAK,EAAEO,IAAI,CAAC;IACnD;EAAC;IAAA;IAAA,OAED,wBAAeA,IAAU;MACxB,OAAO,IAAI,CAAChB,MAAM,CAACkB,cAAc,CAACF,IAAI,CAAC;IACxC;IAEA;;;EAAA;IAAA;IAAA,KAGA,eAAc;MACb,OAAO,IAAI,CAAChB,MAAM,CAACG,UAAU;IAC9B,CAAC;IAAA,KACD,aAAegB,CAAS;MACvB,IAAI,CAACnB,MAAM,CAACG,UAAU,GAAGgB,CAAC;IAC3B;EAAC;IAAA;IAAA,OAED,mBAAO;MACN;MACA,IAAI,CAACnB,MAAM,CAACoB,OAAO,EAAE;MACrB,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OA1CD,uBAAkB;MACjB,OAAOC,MAAM,CAACC,MAAM,CAAC9B,MAAM,CAACI,WAAW,EAAE,EAAE;QAC1CO,UAAU,EAAE,CAAC;QACbI,KAAK,EAAE,OAAO;QACdC,KAAK,EAAE;OACP,CAAC;IACH;EAAC;EAAA;AAAA,EApCgEhB,MAAgB","names":["Signal","optionsFromArguments","TickParam","TickSignal","getDefaults","arguments","options","input","_param","context","convert","multiplier","param","_constantSource","offset","units","value","ticks","when","ticksToTime","duration","timeToTicks","tick","getTimeOfTick","time","getDurationOfTicks","getTicksAtTime","m","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\TickSignal.ts"],"sourcesContent":["import { Signal, SignalOptions } from \"../../signal/Signal\";\nimport { InputNode } from \"../context/ToneAudioNode\";\nimport { Seconds, Ticks, Time, UnitMap, UnitName } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { TickParam } from \"./TickParam\";\n\ninterface TickSignalOptions<TypeName extends UnitName> extends SignalOptions<TypeName> {\n\tvalue: UnitMap[TypeName];\n\tmultiplier: number;\n}\n\n/**\n * TickSignal extends Tone.Signal, but adds the capability\n * to calculate the number of elapsed ticks. exponential and target curves\n * are approximated with multiple linear ramps.\n *\n * Thank you Bruno Dias, H. Sofia Pinto, and David M. Matos,\n * for your [WAC paper](https://smartech.gatech.edu/bitstream/handle/1853/54588/WAC2016-49.pdf)\n * describing integrating timing functions for tempo calculations.\n */\nexport class TickSignal<TypeName extends \"hertz\" | \"bpm\"> extends Signal<TypeName> {\n\n\treadonly name: string = \"TickSignal\";\n\n\t/**\n\t * The param which controls the output signal value\n\t */\n\tprotected _param: TickParam<TypeName>;\n\treadonly input: InputNode;\n\n\t/**\n\t * @param value The initial value of the signal\n\t */\n\tconstructor(value?: UnitMap[TypeName]);\n\tconstructor(options: Partial<TickSignalOptions<TypeName>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]));\n\t\tconst options = optionsFromArguments(TickSignal.getDefaults(), arguments, [\"value\"]);\n\n\t\tthis.input = this._param = new TickParam({\n\t\t\tcontext: this.context,\n\t\t\tconvert: options.convert,\n\t\t\tmultiplier: options.multiplier,\n\t\t\tparam: this._constantSource.offset,\n\t\t\tunits: options.units,\n\t\t\tvalue: options.value,\n\t\t});\n\t}\n\n\tstatic getDefaults(): TickSignalOptions<any> {\n\t\treturn Object.assign(Signal.getDefaults(), {\n\t\t\tmultiplier: 1,\n\t\t\tunits: \"hertz\",\n\t\t\tvalue: 1,\n\t\t});\n\t}\n\n\tticksToTime(ticks: Ticks, when: Time): Seconds {\n\t\treturn this._param.ticksToTime(ticks, when);\n\t}\n\n\ttimeToTicks(duration: Time, when: Time): Ticks {\n\t\treturn this._param.timeToTicks(duration, when);\n\t}\n\n\tgetTimeOfTick(tick: Ticks): Seconds {\n\t\treturn this._param.getTimeOfTick(tick);\n\t}\n\n\tgetDurationOfTicks(ticks: Ticks, time: Time): Seconds {\n\t\treturn this._param.getDurationOfTicks(ticks, time);\n\t}\n\n\tgetTicksAtTime(time: Time): Ticks {\n\t\treturn this._param.getTicksAtTime(time);\n\t}\n\n\t/**\n\t * A multiplier on the bpm value. Useful for setting a PPQ relative to the base frequency value.\n\t */\n\tget multiplier(): number {\n\t\treturn this._param.multiplier;\n\t}\n\tset multiplier(m: number) {\n\t\tthis._param.multiplier = m;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._param.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { Noise } from \"../source/Noise\";\nimport { Instrument } from \"./Instrument\";\nimport { ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Envelope } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]].\n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport var NoiseSynth = /*#__PURE__*/function (_Instrument) {\n  _inherits(NoiseSynth, _Instrument);\n  var _super = _createSuper(NoiseSynth);\n  function NoiseSynth() {\n    var _this;\n    _classCallCheck(this, NoiseSynth);\n    _this = _super.call(this, optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n    _this.name = \"NoiseSynth\";\n    var options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n    _this.noise = new Noise(Object.assign({\n      context: _this.context\n    }, options.noise));\n    _this.envelope = new AmplitudeEnvelope(Object.assign({\n      context: _this.context\n    }, options.envelope));\n    // connect the noise to the output\n    _this.noise.chain(_this.envelope, _this.output);\n    return _this;\n  }\n  _createClass(NoiseSynth, [{\n    key: \"triggerAttack\",\n    value:\n    /**\n     * Start the attack portion of the envelopes. Unlike other\n     * instruments, Tone.NoiseSynth doesn't have a note.\n     * @example\n     * const noiseSynth = new Tone.NoiseSynth().toDestination();\n     * noiseSynth.triggerAttack();\n     */\n    function triggerAttack(time) {\n      var velocity = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 1;\n      time = this.toSeconds(time);\n      // the envelopes\n      this.envelope.triggerAttack(time, velocity);\n      // start the noise\n      this.noise.start(time);\n      if (this.envelope.sustain === 0) {\n        this.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n      }\n      return this;\n    }\n    /**\n     * Start the release portion of the envelopes.\n     */\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(time) {\n      time = this.toSeconds(time);\n      this.envelope.triggerRelease(time);\n      this.noise.stop(time + this.toSeconds(this.envelope.release));\n      return this;\n    }\n  }, {\n    key: \"sync\",\n    value: function sync() {\n      if (this._syncState()) {\n        this._syncMethod(\"triggerAttack\", 0);\n        this._syncMethod(\"triggerRelease\", 0);\n      }\n      return this;\n    }\n  }, {\n    key: \"triggerAttackRelease\",\n    value: function triggerAttackRelease(duration, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      time = this.toSeconds(time);\n      duration = this.toSeconds(duration);\n      this.triggerAttack(time, velocity);\n      this.triggerRelease(time + duration);\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(NoiseSynth.prototype), \"dispose\", this).call(this);\n      this.noise.dispose();\n      this.envelope.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        envelope: Object.assign(omitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())), {\n          decay: 0.1,\n          sustain: 0.0\n        }),\n        noise: Object.assign(omitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())), {\n          type: \"white\"\n        })\n      });\n    }\n  }]);\n  return NoiseSynth;\n}(Instrument);","map":{"version":3,"mappings":"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","names":["AmplitudeEnvelope","omitFromObject","optionsFromArguments","Noise","Instrument","ToneAudioNode","Envelope","Source","NoiseSynth","getDefaults","arguments","options","noise","Object","assign","context","envelope","chain","output","time","velocity","toSeconds","triggerAttack","start","sustain","stop","attack","decay","triggerRelease","release","_syncState","_syncMethod","duration","dispose","keys","type"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\instrument\\NoiseSynth.ts"],"sourcesContent":["import { AmplitudeEnvelope } from \"../component/envelope/AmplitudeEnvelope\";\nimport { NormalRange, Time } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { RecursivePartial } from \"../core/util/Interface\";\nimport { Noise, NoiseOptions } from \"../source/Noise\";\nimport { Instrument, InstrumentOptions } from \"./Instrument\";\nimport { ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Envelope, EnvelopeOptions } from \"../component/envelope/Envelope\";\nimport { Source } from \"../source/Source\";\n\nexport interface NoiseSynthOptions extends InstrumentOptions {\n\tenvelope: Omit<EnvelopeOptions, keyof ToneAudioNodeOptions>;\n\tnoise: Omit<NoiseOptions, keyof ToneAudioNodeOptions>;\n}\n\n/**\n * Tone.NoiseSynth is composed of [[Noise]] through an [[AmplitudeEnvelope]]. \n * ```\n * +-------+   +-------------------+\n * | Noise +>--> AmplitudeEnvelope +>--> Output\n * +-------+   +-------------------+\n * ```\n * @example\n * const noiseSynth = new Tone.NoiseSynth().toDestination();\n * noiseSynth.triggerAttackRelease(\"8n\", 0.05);\n * @category Instrument\n */\nexport class NoiseSynth extends Instrument<NoiseSynthOptions> {\n\n\treadonly name = \"NoiseSynth\";\n\n\t/**\n\t * The noise source.\n\t */\n\treadonly noise: Noise;\n\n\t/**\n\t * The amplitude envelope.\n\t */\n\treadonly envelope: AmplitudeEnvelope;\n\n\tconstructor(options?: RecursivePartial<NoiseSynthOptions>)\n\tconstructor() {\n\t\tsuper(optionsFromArguments(NoiseSynth.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(NoiseSynth.getDefaults(), arguments);\n\t\tthis.noise = new Noise(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.noise));\n\n\t\tthis.envelope = new AmplitudeEnvelope(Object.assign({\n\t\t\tcontext: this.context,\n\t\t}, options.envelope));\n\n\t\t// connect the noise to the output\n\t\tthis.noise.chain(this.envelope, this.output);\n\t}\n\n\tstatic getDefaults(): NoiseSynthOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tenvelope: Object.assign(\n\t\t\t\tomitFromObject(Envelope.getDefaults(), Object.keys(ToneAudioNode.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\tdecay: 0.1,\n\t\t\t\t\tsustain: 0.0,\n\t\t\t\t},\n\t\t\t),\n\t\t\tnoise: Object.assign(\n\t\t\t\tomitFromObject(Noise.getDefaults(), Object.keys(Source.getDefaults())),\n\t\t\t\t{\n\t\t\t\t\ttype: \"white\",\n\t\t\t\t},\n\t\t\t),\n\t\t});\n\t}\n\n\t/**\n\t * Start the attack portion of the envelopes. Unlike other\n\t * instruments, Tone.NoiseSynth doesn't have a note.\n\t * @example\n\t * const noiseSynth = new Tone.NoiseSynth().toDestination();\n\t * noiseSynth.triggerAttack();\n\t */\n\ttriggerAttack(time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\t// the envelopes\n\t\tthis.envelope.triggerAttack(time, velocity);\n\t\t// start the noise\n\t\tthis.noise.start(time);\n\t\tif (this.envelope.sustain === 0) {\n\t\t\tthis.noise.stop(time + this.toSeconds(this.envelope.attack) + this.toSeconds(this.envelope.decay));\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the release portion of the envelopes.\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis.envelope.triggerRelease(time);\n\t\tthis.noise.stop(time + this.toSeconds(this.envelope.release));\n\t\treturn this;\n\t}\n\n\tsync(): this {\n\t\tif (this._syncState()) {\n\t\t\tthis._syncMethod(\"triggerAttack\", 0);\n\t\t\tthis._syncMethod(\"triggerRelease\", 0);\n\t\t}\n\t\treturn this;\n\t}\n\n\ttriggerAttackRelease(duration: Time, time?: Time, velocity: NormalRange = 1): this {\n\t\ttime = this.toSeconds(time);\n\t\tduration = this.toSeconds(duration);\n\t\tthis.triggerAttack(time, velocity);\n\t\tthis.triggerRelease(time + duration);\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.noise.dispose();\n\t\tthis.envelope.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
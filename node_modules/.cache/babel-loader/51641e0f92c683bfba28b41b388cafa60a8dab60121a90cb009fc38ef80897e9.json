{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { Timeline } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport var Draw = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(Draw, _ToneWithContext);\n  var _super = _createSuper(Draw);\n  function Draw() {\n    var _this;\n    _classCallCheck(this, Draw);\n    _this = _super.apply(this, arguments);\n    _this.name = \"Draw\";\n    /**\n     * The duration after which events are not invoked.\n     */\n    _this.expiration = 0.25;\n    /**\n     * The amount of time before the scheduled time\n     * that the callback can be invoked. Default is\n     * half the time of an animation frame (0.008 seconds).\n     */\n    _this.anticipation = 0.008;\n    /**\n     * All of the events.\n     */\n    _this._events = new Timeline();\n    /**\n     * The draw loop\n     */\n    _this._boundDrawLoop = _this._drawLoop.bind(_assertThisInitialized(_this));\n    /**\n     * The animation frame id\n     */\n    _this._animationFrame = -1;\n    return _this;\n  }\n  /**\n   * Schedule a function at the given time to be invoked\n   * on the nearest animation frame.\n   * @param  callback  Callback is invoked at the given time.\n   * @param  time      The time relative to the AudioContext time to invoke the callback.\n   * @example\n   * Tone.Transport.scheduleRepeat(time => {\n   * \tTone.Draw.schedule(() => console.log(time), time);\n   * }, 1);\n   * Tone.Transport.start();\n   */\n  _createClass(Draw, [{\n    key: \"schedule\",\n    value: function schedule(callback, time) {\n      this._events.add({\n        callback: callback,\n        time: this.toSeconds(time)\n      });\n      // start the draw loop on the first event\n      if (this._events.length === 1) {\n        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n      }\n      return this;\n    }\n    /**\n     * Cancel events scheduled after the given time\n     * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      this._events.cancel(this.toSeconds(after));\n      return this;\n    }\n    /**\n     * The draw loop\n     */\n  }, {\n    key: \"_drawLoop\",\n    value: function _drawLoop() {\n      var now = this.context.currentTime;\n      while (this._events.length && this._events.peek().time - this.anticipation <= now) {\n        var event = this._events.shift();\n        if (event && now - event.time <= this.expiration) {\n          event.callback();\n        }\n      }\n      if (this._events.length > 0) {\n        this._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n      }\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Draw.prototype), \"dispose\", this).call(this);\n      this._events.dispose();\n      cancelAnimationFrame(this._animationFrame);\n      return this;\n    }\n  }]);\n  return Draw;\n}(ToneWithContext);\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\nonContextInit(function (context) {\n  context.draw = new Draw({\n    context: context\n  });\n});\nonContextClose(function (context) {\n  context.draw.dispose();\n});","map":{"version":3,"mappings":";;;;;;;AAAA,SAASA,eAAe,QAAgC,4BAA4B;AAEpF,SAASC,QAAQ,QAAuB,YAAY;AACpD,SAASC,cAAc,EAAEC,aAAa,QAAQ,kCAAkC;AAMhF;;;;;;;;;;;;;;;;;;AAkBA,WAAaC,IAAK;EAAA;EAAA;EAAlB;IAAA;IAAA;;IAEU,UAAI,GAAW,MAAM;IAE9B;;;IAGA,gBAAU,GAAY,IAAI;IAE1B;;;;;IAKA,kBAAY,GAAY,KAAK;IAE7B;;;IAGQ,aAAO,GAAwB,IAAIH,QAAQ,EAAE;IAErD;;;IAGQ,oBAAc,GAAG,MAAKI,SAAS,CAACC,IAAI,+BAAM;IAElD;;;IAGQ,qBAAe,GAAG,CAAC,CAAC;IAAC;EAwD9B;EAtDC;;;;;;;;;;;EAAA;IAAA;IAAA,OAWA,kBAASC,QAAoB,EAAEC,IAAU;MACxC,IAAI,CAACC,OAAO,CAACC,GAAG,CAAC;QAChBH,QAAQ,EAARA,QAAQ;QACRC,IAAI,EAAE,IAAI,CAACG,SAAS,CAACH,IAAI;OACzB,CAAC;MACF;MACA,IAAI,IAAI,CAACC,OAAO,CAACG,MAAM,KAAK,CAAC,EAAE;QAC9B,IAAI,CAACC,eAAe,GAAGC,qBAAqB,CAAC,IAAI,CAACC,cAAc,CAAC;;MAElE,OAAO,IAAI;IACZ;IAEA;;;;EAAA;IAAA;IAAA,OAIA,gBAAOC,KAAY;MAClB,IAAI,CAACP,OAAO,CAACQ,MAAM,CAAC,IAAI,CAACN,SAAS,CAACK,KAAK,CAAC,CAAC;MAC1C,OAAO,IAAI;IACZ;IAEA;;;EAAA;IAAA;IAAA,OAGQ,qBAAS;MAChB,IAAME,GAAG,GAAG,IAAI,CAACC,OAAO,CAACC,WAAW;MACpC,OAAO,IAAI,CAACX,OAAO,CAACG,MAAM,IAAK,IAAI,CAACH,OAAO,CAACY,IAAI,EAAgB,CAACb,IAAI,GAAG,IAAI,CAACc,YAAY,IAAIJ,GAAG,EAAE;QACjG,IAAMK,KAAK,GAAG,IAAI,CAACd,OAAO,CAACe,KAAK,EAAE;QAClC,IAAID,KAAK,IAAIL,GAAG,GAAGK,KAAK,CAACf,IAAI,IAAI,IAAI,CAACiB,UAAU,EAAE;UACjDF,KAAK,CAAChB,QAAQ,EAAE;;;MAGlB,IAAI,IAAI,CAACE,OAAO,CAACG,MAAM,GAAG,CAAC,EAAE;QAC5B,IAAI,CAACC,eAAe,GAAGC,qBAAqB,CAAC,IAAI,CAACC,cAAc,CAAC;;IAEnE;EAAC;IAAA;IAAA,OAED,mBAAO;MACN;MACA,IAAI,CAACN,OAAO,CAACiB,OAAO,EAAE;MACtBC,oBAAoB,CAAC,IAAI,CAACd,eAAe,CAAC;MAC1C,OAAO,IAAI;IACZ;EAAC;EAAA;AAAA,EApFwBb,eAAuC;AAuFjE;AACA;AACA;AAEAG,aAAa,CAAC,iBAAO,EAAG;EACvBgB,OAAO,CAACS,IAAI,GAAG,IAAIxB,IAAI,CAAC;IAAEe,OAAO,EAAPA;EAAO,CAAE,CAAC;AACrC,CAAC,CAAC;AAEFjB,cAAc,CAAC,iBAAO,EAAG;EACxBiB,OAAO,CAACS,IAAI,CAACF,OAAO,EAAE;AACvB,CAAC,CAAC","names":["ToneWithContext","Timeline","onContextClose","onContextInit","Draw","_drawLoop","bind","callback","time","_events","add","toSeconds","length","_animationFrame","requestAnimationFrame","_boundDrawLoop","after","cancel","now","context","currentTime","peek","anticipation","event","shift","expiration","dispose","cancelAnimationFrame","draw"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\util\\Draw.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Time } from \"../type/Units\";\nimport { Timeline, TimelineEvent } from \"./Timeline\";\nimport { onContextClose, onContextInit } from \"../context/ContextInitialization\";\n\ninterface DrawEvent extends TimelineEvent {\n\tcallback: () => void;\n}\n\n/**\n * Draw is useful for synchronizing visuals and audio events.\n * Callbacks from Tone.Transport or any of the Tone.Event classes\n * always happen _before_ the scheduled time and are not synchronized\n * to the animation frame so they are not good for triggering tightly\n * synchronized visuals and sound. Draw makes it easy to schedule\n * callbacks using the AudioContext time and uses requestAnimationFrame.\n * @example\n * Tone.Transport.schedule((time) => {\n * \t// use the time argument to schedule a callback with Draw\n * \tTone.Draw.schedule(() => {\n * \t\t// do drawing or DOM manipulation here\n * \t\tconsole.log(time);\n * \t}, time);\n * }, \"+0.5\");\n * Tone.Transport.start();\n * @category Core\n */\nexport class Draw extends ToneWithContext<ToneWithContextOptions> {\n\n\treadonly name: string = \"Draw\";\n\n\t/**\n\t * The duration after which events are not invoked.\n\t */\n\texpiration: Seconds = 0.25;\n\n\t/**\n\t * The amount of time before the scheduled time\n\t * that the callback can be invoked. Default is\n\t * half the time of an animation frame (0.008 seconds).\n\t */\n\tanticipation: Seconds = 0.008;\n\n\t/**\n\t * All of the events.\n\t */\n\tprivate _events: Timeline<DrawEvent> = new Timeline();\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _boundDrawLoop = this._drawLoop.bind(this);\n\n\t/**\n\t * The animation frame id\n\t */\n\tprivate _animationFrame = -1;\n\n\t/**\n\t * Schedule a function at the given time to be invoked\n\t * on the nearest animation frame.\n\t * @param  callback  Callback is invoked at the given time.\n\t * @param  time      The time relative to the AudioContext time to invoke the callback.\n\t * @example\n\t * Tone.Transport.scheduleRepeat(time => {\n\t * \tTone.Draw.schedule(() => console.log(time), time);\n\t * }, 1);\n\t * Tone.Transport.start();\n\t */\n\tschedule(callback: () => void, time: Time): this {\n\t\tthis._events.add({\n\t\t\tcallback,\n\t\t\ttime: this.toSeconds(time),\n\t\t});\n\t\t// start the draw loop on the first event\n\t\tif (this._events.length === 1) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel events scheduled after the given time\n\t * @param  after  Time after which scheduled events will be removed from the scheduling timeline.\n\t */\n\tcancel(after?: Time): this {\n\t\tthis._events.cancel(this.toSeconds(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * The draw loop\n\t */\n\tprivate _drawLoop(): void {\n\t\tconst now = this.context.currentTime;\n\t\twhile (this._events.length && (this._events.peek() as DrawEvent).time - this.anticipation <= now) {\n\t\t\tconst event = this._events.shift();\n\t\t\tif (event && now - event.time <= this.expiration) {\n\t\t\t\tevent.callback();\n\t\t\t}\n\t\t}\n\t\tif (this._events.length > 0) {\n\t\t\tthis._animationFrame = requestAnimationFrame(this._boundDrawLoop);\n\t\t}\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._events.dispose();\n\t\tcancelAnimationFrame(this._animationFrame);\n\t\treturn this;\n\t}\n}\n\n//-------------------------------------\n// \tINITIALIZATION\n//-------------------------------------\n\nonContextInit(context => {\n\tcontext.draw = new Draw({ context });\n});\n\nonContextClose(context => {\n\tcontext.draw.dispose();\n});\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
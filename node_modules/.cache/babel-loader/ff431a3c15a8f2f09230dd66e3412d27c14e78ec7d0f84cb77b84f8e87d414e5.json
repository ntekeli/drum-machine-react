{"ast":null,"code":"import _objectSpread from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/objectSpread2.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nvar DEFAULT_OPTIONS = {\n  buffer: null,\n  channelCount: 2,\n  channelCountMode: 'max',\n  channelInterpretation: 'speakers',\n  // Bug #149: Safari does not yet support the detune AudioParam.\n  loop: false,\n  loopEnd: 0,\n  loopStart: 0,\n  playbackRate: 1\n};\nexport var createAudioBufferSourceNodeConstructor = function createAudioBufferSourceNodeConstructor(audioNodeConstructor, createAudioBufferSourceNodeRenderer, createAudioParam, createInvalidStateError, createNativeAudioBufferSourceNode, getNativeContext, isNativeOfflineAudioContext, wrapEventListener) {\n  return /*#__PURE__*/function (_audioNodeConstructor) {\n    _inherits(AudioBufferSourceNode, _audioNodeConstructor);\n    var _super = _createSuper(AudioBufferSourceNode);\n    function AudioBufferSourceNode(context, options) {\n      var _this;\n      _classCallCheck(this, AudioBufferSourceNode);\n      var nativeContext = getNativeContext(context);\n      var mergedOptions = _objectSpread(_objectSpread({}, DEFAULT_OPTIONS), options);\n      var nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n      var isOffline = isNativeOfflineAudioContext(nativeContext);\n      var audioBufferSourceNodeRenderer = isOffline ? createAudioBufferSourceNodeRenderer() : null;\n      _this = _super.call(this, context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n      _this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n      _this._isBufferNullified = false;\n      _this._isBufferSet = mergedOptions.buffer !== null;\n      _this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n      _this._onended = null;\n      // Bug #73: Safari does not export the correct values for maxValue and minValue.\n      _this._playbackRate = createAudioParam(_assertThisInitialized(_this), isOffline, nativeAudioBufferSourceNode.playbackRate, MOST_POSITIVE_SINGLE_FLOAT, MOST_NEGATIVE_SINGLE_FLOAT);\n      return _this;\n    }\n    _createClass(AudioBufferSourceNode, [{\n      key: \"buffer\",\n      get: function get() {\n        if (this._isBufferNullified) {\n          return null;\n        }\n        return this._nativeAudioBufferSourceNode.buffer;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.buffer = value;\n        // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n        if (value !== null) {\n          if (this._isBufferSet) {\n            throw createInvalidStateError();\n          }\n          this._isBufferSet = true;\n        }\n      }\n    }, {\n      key: \"loop\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loop;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loop = value;\n      }\n    }, {\n      key: \"loopEnd\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loopEnd;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loopEnd = value;\n      }\n    }, {\n      key: \"loopStart\",\n      get: function get() {\n        return this._nativeAudioBufferSourceNode.loopStart;\n      },\n      set: function set(value) {\n        this._nativeAudioBufferSourceNode.loopStart = value;\n      }\n    }, {\n      key: \"onended\",\n      get: function get() {\n        return this._onended;\n      },\n      set: function set(value) {\n        var wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n        this._nativeAudioBufferSourceNode.onended = wrappedListener;\n        var nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n        this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n      }\n    }, {\n      key: \"playbackRate\",\n      get: function get() {\n        return this._playbackRate;\n      }\n    }, {\n      key: \"start\",\n      value: function start() {\n        var _this2 = this;\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        var offset = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : 0;\n        var duration = arguments.length > 2 ? arguments[2] : undefined;\n        this._nativeAudioBufferSourceNode.start(when, offset, duration);\n        if (this._audioBufferSourceNodeRenderer !== null) {\n          this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n        }\n        if (this.context.state !== 'closed') {\n          setInternalStateToActive(this);\n          var resetInternalStateToPassive = function resetInternalStateToPassive() {\n            _this2._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n            if (isActiveAudioNode(_this2)) {\n              setInternalStateToPassive(_this2);\n            }\n          };\n          this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n        }\n      }\n    }, {\n      key: \"stop\",\n      value: function stop() {\n        var when = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : 0;\n        this._nativeAudioBufferSourceNode.stop(when);\n        if (this._audioBufferSourceNodeRenderer !== null) {\n          this._audioBufferSourceNodeRenderer.stop = when;\n        }\n      }\n    }]);\n    return AudioBufferSourceNode;\n  }(audioNodeConstructor);\n};","map":{"version":3,"mappings":";;;;;;AAAA,SAASA,0BAA0B,EAAEC,0BAA0B,QAAQ,cAAc;AACrF,SAASC,iBAAiB,QAAQ,iCAAiC;AACnE,SAASC,wBAAwB,QAAQ,yCAAyC;AAClF,SAASC,yBAAyB,QAAQ,0CAA0C;AAWpF,IAAMC,eAAe,GAAG;EACpBC,MAAM,EAAE,IAAI;EACZC,YAAY,EAAE,CAAC;EACfC,gBAAgB,EAAE,KAAK;EACvBC,qBAAqB,EAAE,UAAU;EACjC;EACAC,IAAI,EAAE,KAAK;EACXC,OAAO,EAAE,CAAC;EACVC,SAAS,EAAE,CAAC;EACZC,YAAY,EAAE;CACR;AAEV,OAAO,IAAMC,sCAAsC,GAA6C,SAAnFA,sCAAsC,CAC/CC,oBAAoB,EACpBC,mCAAmC,EACnCC,gBAAgB,EAChBC,uBAAuB,EACvBC,iCAAiC,EACjCC,gBAAgB,EAChBC,2BAA2B,EAC3BC,iBAAiB,EACjB;EACA;IAAA;IAAA;IAgBI,+BAAYC,OAAU,EAAEC,OAA4C;MAAA;MAAA;MAChE,IAAMC,aAAa,GAAGL,gBAAgB,CAACG,OAAO,CAAC;MAC/C,IAAMG,aAAa,mCAAQrB,eAAe,GAAKmB,OAAO,CAAE;MACxD,IAAMG,2BAA2B,GAAGR,iCAAiC,CAACM,aAAa,EAAEC,aAAa,CAAC;MACnG,IAAME,SAAS,GAAGP,2BAA2B,CAACI,aAAa,CAAC;MAC5D,IAAMI,6BAA6B,GAC9BD,SAAS,GAAGZ,mCAAmC,EAAE,GAAG,IACxD;MAED,0BAAMO,OAAO,EAAE,KAAK,EAAEI,2BAA2B,EAAEE,6BAA6B;MAEhF,MAAKC,8BAA8B,GAAGD,6BAA6B;MACnE,MAAKE,kBAAkB,GAAG,KAAK;MAC/B,MAAKC,YAAY,GAAGN,aAAa,CAACpB,MAAM,KAAK,IAAI;MACjD,MAAK2B,4BAA4B,GAAGN,2BAA2B;MAC/D,MAAKO,QAAQ,GAAG,IAAI;MACpB;MACA,MAAKC,aAAa,GAAGlB,gBAAgB,gCAEjCW,SAAS,EACTD,2BAA2B,CAACd,YAAY,EACxCZ,0BAA0B,EAC1BD,0BAA0B,CAC7B;MAAC;IACN;IAAC;MAAA;MAAA,KAED,eAAU;QACN,IAAI,IAAI,CAAC+B,kBAAkB,EAAE;UACzB,OAAO,IAAI;;QAGf,OAAO,IAAI,CAACE,4BAA4B,CAAC3B,MAAM;MACnD,CAAC;MAAA,KAED,aAAW8B,KAAK;QACZ,IAAI,CAACH,4BAA4B,CAAC3B,MAAM,GAAG8B,KAAK;QAEhD;QACA,IAAIA,KAAK,KAAK,IAAI,EAAE;UAChB,IAAI,IAAI,CAACJ,YAAY,EAAE;YACnB,MAAMd,uBAAuB,EAAE;;UAGnC,IAAI,CAACc,YAAY,GAAG,IAAI;;MAEhC;IAAC;MAAA;MAAA,KAED,eAAQ;QACJ,OAAO,IAAI,CAACC,4BAA4B,CAACvB,IAAI;MACjD,CAAC;MAAA,KAED,aAAS0B,KAAK;QACV,IAAI,CAACH,4BAA4B,CAACvB,IAAI,GAAG0B,KAAK;MAClD;IAAC;MAAA;MAAA,KAED,eAAW;QACP,OAAO,IAAI,CAACH,4BAA4B,CAACtB,OAAO;MACpD,CAAC;MAAA,KAED,aAAYyB,KAAK;QACb,IAAI,CAACH,4BAA4B,CAACtB,OAAO,GAAGyB,KAAK;MACrD;IAAC;MAAA;MAAA,KAED,eAAa;QACT,OAAO,IAAI,CAACH,4BAA4B,CAACrB,SAAS;MACtD,CAAC;MAAA,KAED,aAAcwB,KAAK;QACf,IAAI,CAACH,4BAA4B,CAACrB,SAAS,GAAGwB,KAAK;MACvD;IAAC;MAAA;MAAA,KAED,eAAW;QACP,OAAO,IAAI,CAACF,QAAQ;MACxB,CAAC;MAAA,KAED,aAAYE,KAAK;QACb,IAAMC,eAAe,GAAG,OAAOD,KAAK,KAAK,UAAU,GAAGd,iBAAiB,CAAC,IAAI,EAAEc,KAAK,CAAC,GAAG,IAAI;QAE3F,IAAI,CAACH,4BAA4B,CAACK,OAAO,GAAGD,eAAe;QAE3D,IAAME,aAAa,GAAG,IAAI,CAACN,4BAA4B,CAACK,OAAO;QAE/D,IAAI,CAACJ,QAAQ,GAAGK,aAAa,KAAK,IAAI,IAAIA,aAAa,KAAKF,eAAe,GAAGD,KAAK,GAAGG,aAAa;MACvG;IAAC;MAAA;MAAA,KAED,eAAgB;QACZ,OAAO,IAAI,CAACJ,aAAa;MAC7B;IAAC;MAAA;MAAA,OAEM,iBAA6C;QAAA;QAAA,IAAvCK,IAAI,uEAAG,CAAC;QAAA,IAAEC,MAAM,uEAAG,CAAC;QAAA,IAAEC,QAAiB;QAChD,IAAI,CAACT,4BAA4B,CAACU,KAAK,CAACH,IAAI,EAAEC,MAAM,EAAEC,QAAQ,CAAC;QAE/D,IAAI,IAAI,CAACZ,8BAA8B,KAAK,IAAI,EAAE;UAC9C,IAAI,CAACA,8BAA8B,CAACa,KAAK,GAAGD,QAAQ,KAAKE,SAAS,GAAG,CAACJ,IAAI,EAAEC,MAAM,CAAC,GAAG,CAACD,IAAI,EAAEC,MAAM,EAAEC,QAAQ,CAAC;;QAGlH,IAAI,IAAI,CAACnB,OAAO,CAACsB,KAAK,KAAK,QAAQ,EAAE;UACjC1C,wBAAwB,CAAC,IAAI,CAAC;UAE9B,IAAM2C,2BAA2B,GAAG,SAA9BA,2BAA2B,GAAQ;YACrC,MAAI,CAACb,4BAA4B,CAACc,mBAAmB,CAAC,OAAO,EAAED,2BAA2B,CAAC;YAE3F,IAAI5C,iBAAiB,CAAC,MAAI,CAAC,EAAE;cACzBE,yBAAyB,CAAC,MAAI,CAAC;;UAEvC,CAAC;UAED,IAAI,CAAC6B,4BAA4B,CAACe,gBAAgB,CAAC,OAAO,EAAEF,2BAA2B,CAAC;;MAEhG;IAAC;MAAA;MAAA,OAEM,gBAAa;QAAA,IAARN,IAAI,uEAAG,CAAC;QAChB,IAAI,CAACP,4BAA4B,CAACgB,IAAI,CAACT,IAAI,CAAC;QAE5C,IAAI,IAAI,CAACV,8BAA8B,KAAK,IAAI,EAAE;UAC9C,IAAI,CAACA,8BAA8B,CAACmB,IAAI,GAAGT,IAAI;;MAEvD;IAAC;IAAA;EAAA,EApIOzB,oBAA0D;AAsI1E,CAAC","names":["MOST_NEGATIVE_SINGLE_FLOAT","MOST_POSITIVE_SINGLE_FLOAT","isActiveAudioNode","setInternalStateToActive","setInternalStateToPassive","DEFAULT_OPTIONS","buffer","channelCount","channelCountMode","channelInterpretation","loop","loopEnd","loopStart","playbackRate","createAudioBufferSourceNodeConstructor","audioNodeConstructor","createAudioBufferSourceNodeRenderer","createAudioParam","createInvalidStateError","createNativeAudioBufferSourceNode","getNativeContext","isNativeOfflineAudioContext","wrapEventListener","context","options","nativeContext","mergedOptions","nativeAudioBufferSourceNode","isOffline","audioBufferSourceNodeRenderer","_audioBufferSourceNodeRenderer","_isBufferNullified","_isBufferSet","_nativeAudioBufferSourceNode","_onended","_playbackRate","value","wrappedListener","onended","nativeOnEnded","when","offset","duration","start","undefined","state","resetInternalStateToPassive","removeEventListener","addEventListener","stop"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\standardized-audio-context\\src\\factories\\audio-buffer-source-node-constructor.ts"],"sourcesContent":["import { MOST_NEGATIVE_SINGLE_FLOAT, MOST_POSITIVE_SINGLE_FLOAT } from '../constants';\nimport { isActiveAudioNode } from '../helpers/is-active-audio-node';\nimport { setInternalStateToActive } from '../helpers/set-internal-state-to-active';\nimport { setInternalStateToPassive } from '../helpers/set-internal-state-to-passive';\nimport { IAudioBufferSourceNode, IAudioBufferSourceOptions, IAudioParam, IAudioScheduledSourceNodeEventMap } from '../interfaces';\nimport {\n    TAnyAudioBuffer,\n    TAudioBufferSourceNodeConstructorFactory,\n    TAudioBufferSourceNodeRenderer,\n    TContext,\n    TEventHandler,\n    TNativeAudioBufferSourceNode\n} from '../types';\n\nconst DEFAULT_OPTIONS = {\n    buffer: null,\n    channelCount: 2,\n    channelCountMode: 'max',\n    channelInterpretation: 'speakers',\n    // Bug #149: Safari does not yet support the detune AudioParam.\n    loop: false,\n    loopEnd: 0,\n    loopStart: 0,\n    playbackRate: 1\n} as const;\n\nexport const createAudioBufferSourceNodeConstructor: TAudioBufferSourceNodeConstructorFactory = (\n    audioNodeConstructor,\n    createAudioBufferSourceNodeRenderer,\n    createAudioParam,\n    createInvalidStateError,\n    createNativeAudioBufferSourceNode,\n    getNativeContext,\n    isNativeOfflineAudioContext,\n    wrapEventListener\n) => {\n    return class AudioBufferSourceNode<T extends TContext>\n        extends audioNodeConstructor<T, IAudioScheduledSourceNodeEventMap>\n        implements IAudioBufferSourceNode<T>\n    {\n        private _audioBufferSourceNodeRenderer: TAudioBufferSourceNodeRenderer<T>;\n\n        private _isBufferNullified: boolean;\n\n        private _isBufferSet: boolean;\n\n        private _nativeAudioBufferSourceNode: TNativeAudioBufferSourceNode;\n\n        private _onended: null | TEventHandler<this>;\n\n        private _playbackRate: IAudioParam;\n\n        constructor(context: T, options?: Partial<IAudioBufferSourceOptions>) {\n            const nativeContext = getNativeContext(context);\n            const mergedOptions = { ...DEFAULT_OPTIONS, ...options };\n            const nativeAudioBufferSourceNode = createNativeAudioBufferSourceNode(nativeContext, mergedOptions);\n            const isOffline = isNativeOfflineAudioContext(nativeContext);\n            const audioBufferSourceNodeRenderer = <TAudioBufferSourceNodeRenderer<T>>(\n                (isOffline ? createAudioBufferSourceNodeRenderer() : null)\n            );\n\n            super(context, false, nativeAudioBufferSourceNode, audioBufferSourceNodeRenderer);\n\n            this._audioBufferSourceNodeRenderer = audioBufferSourceNodeRenderer;\n            this._isBufferNullified = false;\n            this._isBufferSet = mergedOptions.buffer !== null;\n            this._nativeAudioBufferSourceNode = nativeAudioBufferSourceNode;\n            this._onended = null;\n            // Bug #73: Safari does not export the correct values for maxValue and minValue.\n            this._playbackRate = createAudioParam(\n                this,\n                isOffline,\n                nativeAudioBufferSourceNode.playbackRate,\n                MOST_POSITIVE_SINGLE_FLOAT,\n                MOST_NEGATIVE_SINGLE_FLOAT\n            );\n        }\n\n        get buffer(): null | TAnyAudioBuffer {\n            if (this._isBufferNullified) {\n                return null;\n            }\n\n            return this._nativeAudioBufferSourceNode.buffer;\n        }\n\n        set buffer(value) {\n            this._nativeAudioBufferSourceNode.buffer = value;\n\n            // Bug #72: Only Chrome & Edge do not allow to reassign the buffer yet.\n            if (value !== null) {\n                if (this._isBufferSet) {\n                    throw createInvalidStateError();\n                }\n\n                this._isBufferSet = true;\n            }\n        }\n\n        get loop(): boolean {\n            return this._nativeAudioBufferSourceNode.loop;\n        }\n\n        set loop(value) {\n            this._nativeAudioBufferSourceNode.loop = value;\n        }\n\n        get loopEnd(): number {\n            return this._nativeAudioBufferSourceNode.loopEnd;\n        }\n\n        set loopEnd(value) {\n            this._nativeAudioBufferSourceNode.loopEnd = value;\n        }\n\n        get loopStart(): number {\n            return this._nativeAudioBufferSourceNode.loopStart;\n        }\n\n        set loopStart(value) {\n            this._nativeAudioBufferSourceNode.loopStart = value;\n        }\n\n        get onended(): null | TEventHandler<this> {\n            return this._onended;\n        }\n\n        set onended(value) {\n            const wrappedListener = typeof value === 'function' ? wrapEventListener(this, value) : null;\n\n            this._nativeAudioBufferSourceNode.onended = wrappedListener;\n\n            const nativeOnEnded = this._nativeAudioBufferSourceNode.onended;\n\n            this._onended = nativeOnEnded !== null && nativeOnEnded === wrappedListener ? value : nativeOnEnded;\n        }\n\n        get playbackRate(): IAudioParam {\n            return this._playbackRate;\n        }\n\n        public start(when = 0, offset = 0, duration?: number): void {\n            this._nativeAudioBufferSourceNode.start(when, offset, duration);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.start = duration === undefined ? [when, offset] : [when, offset, duration];\n            }\n\n            if (this.context.state !== 'closed') {\n                setInternalStateToActive(this);\n\n                const resetInternalStateToPassive = () => {\n                    this._nativeAudioBufferSourceNode.removeEventListener('ended', resetInternalStateToPassive);\n\n                    if (isActiveAudioNode(this)) {\n                        setInternalStateToPassive(this);\n                    }\n                };\n\n                this._nativeAudioBufferSourceNode.addEventListener('ended', resetInternalStateToPassive);\n            }\n        }\n\n        public stop(when = 0): void {\n            this._nativeAudioBufferSourceNode.stop(when);\n\n            if (this._audioBufferSourceNodeRenderer !== null) {\n                this._audioBufferSourceNodeRenderer.stop = when;\n            }\n        }\n    };\n};\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
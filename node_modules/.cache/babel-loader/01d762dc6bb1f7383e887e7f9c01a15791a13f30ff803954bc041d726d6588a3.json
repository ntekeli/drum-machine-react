{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport var FrequencyShifter = /*#__PURE__*/function (_Effect) {\n  _inherits(FrequencyShifter, _Effect);\n  var _super = _createSuper(FrequencyShifter);\n  function FrequencyShifter() {\n    var _this;\n    _classCallCheck(this, FrequencyShifter);\n    _this = _super.call(this, optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"FrequencyShifter\";\n    var options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new Signal({\n      context: _this.context,\n      units: \"frequency\",\n      value: options.frequency,\n      minValue: -_this.context.sampleRate / 2,\n      maxValue: _this.context.sampleRate / 2\n    });\n    _this._sine = new ToneOscillatorNode({\n      context: _this.context,\n      type: \"sine\"\n    });\n    _this._cosine = new Oscillator({\n      context: _this.context,\n      phase: -90,\n      type: \"sine\"\n    });\n    _this._sineMultiply = new Multiply({\n      context: _this.context\n    });\n    _this._cosineMultiply = new Multiply({\n      context: _this.context\n    });\n    _this._negate = new Negate({\n      context: _this.context\n    });\n    _this._add = new Add({\n      context: _this.context\n    });\n    _this._phaseShifter = new PhaseShiftAllpass({\n      context: _this.context\n    });\n    _this.effectSend.connect(_this._phaseShifter);\n    // connect the carrier frequency signal to the two oscillators\n    _this.frequency.fan(_this._sine.frequency, _this._cosine.frequency);\n    _this._phaseShifter.offset90.connect(_this._cosineMultiply);\n    _this._cosine.connect(_this._cosineMultiply.factor);\n    _this._phaseShifter.connect(_this._sineMultiply);\n    _this._sine.connect(_this._sineMultiply.factor);\n    _this._sineMultiply.connect(_this._negate);\n    _this._cosineMultiply.connect(_this._add);\n    _this._negate.connect(_this._add.addend);\n    _this._add.connect(_this.effectReturn);\n    // start the oscillators at the same time\n    var now = _this.immediate();\n    _this._sine.start(now);\n    _this._cosine.start(now);\n    return _this;\n  }\n  _createClass(FrequencyShifter, [{\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(FrequencyShifter.prototype), \"dispose\", this).call(this);\n      this.frequency.dispose();\n      this._add.dispose();\n      this._cosine.dispose();\n      this._cosineMultiply.dispose();\n      this._negate.dispose();\n      this._phaseShifter.dispose();\n      this._sine.dispose();\n      this._sineMultiply.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Effect.getDefaults(), {\n        frequency: 0\n      });\n    }\n  }]);\n  return FrequencyShifter;\n}(Effect);","map":{"version":3,"mappings":"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","names":["PhaseShiftAllpass","optionsFromArguments","Effect","Add","Multiply","Negate","Signal","Oscillator","ToneOscillatorNode","FrequencyShifter","getDefaults","arguments","options","frequency","context","units","value","minValue","sampleRate","maxValue","_sine","type","_cosine","phase","_sineMultiply","_cosineMultiply","_negate","_add","_phaseShifter","effectSend","connect","fan","offset90","factor","addend","effectReturn","now","immediate","start","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\effect\\FrequencyShifter.ts"],"sourcesContent":["import { PhaseShiftAllpass } from \"../component/filter/PhaseShiftAllpass\";\nimport { Frequency } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { Effect, EffectOptions } from \"../effect/Effect\";\nimport { Add } from \"../signal/Add\";\nimport { Multiply } from \"../signal/Multiply\";\nimport { Negate } from \"../signal/Negate\";\nimport { Signal } from \"../signal/Signal\";\nimport { Oscillator } from \"../source/oscillator/Oscillator\";\nimport { ToneOscillatorNode } from \"../source/oscillator/ToneOscillatorNode\";\n\ninterface FrequencyShifterOptions extends EffectOptions {\n\tfrequency: Frequency;\n}\n\n/**\n * FrequencyShifter can be used to shift all frequencies of a signal by a fixed amount.\n * The amount can be changed at audio rate and the effect is applied in real time.\n * The frequency shifting is implemented with a technique called single side band modulation using a ring modulator.\n * Note: Contrary to pitch shifting, all frequencies are shifted by the same amount,\n * destroying the harmonic relationship between them. This leads to the classic ring modulator timbre distortion.\n * The algorithm will produces some aliasing towards the high end, especially if your source material\n * contains a lot of high frequencies. Unfortunatelly the webaudio API does not support resampling\n * buffers in real time, so it is not possible to fix it properly. Depending on the use case it might\n * be an option to low pass filter your input before frequency shifting it to get ride of the aliasing.\n * You can find a very detailed description of the algorithm here: https://larzeitlin.github.io/RMFS/\n *\n * @example\n * const input = new Tone.Oscillator(230, \"sawtooth\").start();\n * const shift = new Tone.FrequencyShifter(42).toDestination();\n * input.connect(shift);\n * @category Effect\n */\nexport class FrequencyShifter extends Effect<FrequencyShifterOptions> {\n\n\treadonly name: string = \"FrequencyShifter\";\n\n\t/**\n\t * The ring modulators carrier frequency. This frequency determines\n\t * by how many Hertz the input signal will be shifted up or down. Default is 0.\n\t */\n\treadonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The ring modulators sine carrier\n\t */\n\tprivate _sine: ToneOscillatorNode;\n\n\t/**\n\t * The ring modulators cosine carrier\n\t */\n\tprivate _cosine: Oscillator;\n\n\t/**\n\t * The sine multiply operator\n\t */\n\tprivate _sineMultiply: Multiply;\n\n\t/**\n\t * The cosine multiply operator\n\t */\n\tprivate _cosineMultiply: Multiply;\n\n\t/**\n\t * The negate operator\n\t */\n\tprivate _negate: Negate;\n\n\t/**\n\t * The final add operator\n\t */\n\tprivate _add: Add;\n\n\t/**\n\t * The phase shifter to create the initial 90° phase offset\n\t */\n\tprivate _phaseShifter: PhaseShiftAllpass;\n\n\t/**\n\t * @param frequency The incoming signal is shifted by this frequency value.\n\t */\n\tconstructor(frequency?: Frequency);\n\tconstructor(options?: Partial<FrequencyShifterOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(FrequencyShifter.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new Signal({\n\t\t\tcontext: this.context,\n\t\t\tunits: \"frequency\",\n\t\t\tvalue: options.frequency,\n\t\t\tminValue: -this.context.sampleRate / 2,\n\t\t\tmaxValue: this.context.sampleRate / 2,\n\t\t});\n\n\t\tthis._sine = new ToneOscillatorNode({\n\t\t\tcontext: this.context,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._cosine = new Oscillator({\n\t\t\tcontext: this.context,\n\t\t\tphase: -90,\n\t\t\ttype: \"sine\",\n\t\t});\n\n\t\tthis._sineMultiply = new Multiply({ context: this.context });\n\t\tthis._cosineMultiply = new Multiply({ context: this.context });\n\t\tthis._negate = new Negate({ context: this.context });\n\t\tthis._add = new Add({ context: this.context });\n\n\t\tthis._phaseShifter = new PhaseShiftAllpass({ context: this.context });\n\t\tthis.effectSend.connect(this._phaseShifter);\n\n\t\t// connect the carrier frequency signal to the two oscillators\n\t\tthis.frequency.fan(this._sine.frequency, this._cosine.frequency);\n\n\t\tthis._phaseShifter.offset90.connect(this._cosineMultiply);\n\t\tthis._cosine.connect(this._cosineMultiply.factor);\n\n\t\tthis._phaseShifter.connect(this._sineMultiply);\n\t\tthis._sine.connect(this._sineMultiply.factor);\n\t\tthis._sineMultiply.connect(this._negate);\n\n\t\tthis._cosineMultiply.connect(this._add);\n\t\tthis._negate.connect(this._add.addend);\n\n\t\tthis._add.connect(this.effectReturn);\n\n\t\t// start the oscillators at the same time\n\t\tconst now = this.immediate();\n\t\tthis._sine.start(now);\n\t\tthis._cosine.start(now);\n\t}\n\n\tstatic getDefaults(): FrequencyShifterOptions {\n\t\treturn Object.assign(Effect.getDefaults(), {\n\t\t\tfrequency: 0,\n\t\t});\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.frequency.dispose();\n\t\tthis._add.dispose();\n\t\tthis._cosine.dispose();\n\t\tthis._cosineMultiply.dispose();\n\t\tthis._negate.dispose();\n\t\tthis._phaseShifter.dispose();\n\t\tthis._sine.dispose();\n\t\tthis._sineMultiply.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
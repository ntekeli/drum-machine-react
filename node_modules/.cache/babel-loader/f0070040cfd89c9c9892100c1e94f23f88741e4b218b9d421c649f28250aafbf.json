{"ast":null,"code":"import _createForOfIteratorHelper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createForOfIteratorHelper.js\";\nimport _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport var ToneAudioBuffer = /*#__PURE__*/function (_Tone) {\n  _inherits(ToneAudioBuffer, _Tone);\n  var _super = _createSuper(ToneAudioBuffer);\n  function ToneAudioBuffer() {\n    var _this;\n    _classCallCheck(this, ToneAudioBuffer);\n    _this = _super.call(this);\n    _this.name = \"ToneAudioBuffer\";\n    /**\n     * Callback when the buffer is loaded.\n     */\n    _this.onload = noOp;\n    var options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n    _this.reverse = options.reverse;\n    _this.onload = options.onload;\n    if (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n      _this.set(options.url);\n    } else if (isString(options.url)) {\n      // initiate the download\n      _this.load(options.url).catch(options.onerror);\n    }\n    return _this;\n  }\n  _createClass(ToneAudioBuffer, [{\n    key: \"sampleRate\",\n    get:\n    /**\n     * The sample rate of the AudioBuffer\n     */\n    function get() {\n      if (this._buffer) {\n        return this._buffer.sampleRate;\n      } else {\n        return getContext().sampleRate;\n      }\n    }\n    /**\n     * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n     */\n  }, {\n    key: \"set\",\n    value: function set(buffer) {\n      var _this2 = this;\n      if (buffer instanceof ToneAudioBuffer) {\n        // if it's loaded, set it\n        if (buffer.loaded) {\n          this._buffer = buffer.get();\n        } else {\n          // otherwise when it's loaded, invoke it's callback\n          buffer.onload = function () {\n            _this2.set(buffer);\n            _this2.onload(_this2);\n          };\n        }\n      } else {\n        this._buffer = buffer;\n      }\n      // reverse it initially\n      if (this._reversed) {\n        this._reverse();\n      }\n      return this;\n    }\n    /**\n     * The audio buffer stored in the object.\n     */\n  }, {\n    key: \"get\",\n    value: function get() {\n      return this._buffer;\n    }\n    /**\n     * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n     * Invokes the callback once the audio buffer loads.\n     * @param url The url of the buffer to load. filetype support depends on the browser.\n     * @returns A Promise which resolves with this ToneAudioBuffer\n     */\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var _this3 = this;\n        var doneLoading, index;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              doneLoading = ToneAudioBuffer.load(url).then(function (audioBuffer) {\n                _this3.set(audioBuffer);\n                // invoke the onload method\n                _this3.onload(_this3);\n              });\n              ToneAudioBuffer.downloads.push(doneLoading);\n              _context.prev = 2;\n              _context.next = 5;\n              return doneLoading;\n            case 5:\n              _context.prev = 5;\n              // remove the downloaded file\n              index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n              ToneAudioBuffer.downloads.splice(index, 1);\n              return _context.finish(5);\n            case 9:\n              return _context.abrupt(\"return\", this);\n            case 10:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this, [[2,, 5, 9]]);\n      }));\n    }\n    /**\n     * clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(ToneAudioBuffer.prototype), \"dispose\", this).call(this);\n      this._buffer = undefined;\n      return this;\n    }\n    /**\n     * Set the audio buffer from the array.\n     * To create a multichannel AudioBuffer, pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     */\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      var isMultidimensional = isArray(array) && array[0].length > 0;\n      var channels = isMultidimensional ? array.length : 1;\n      var len = isMultidimensional ? array[0].length : array.length;\n      var context = getContext();\n      var buffer = context.createBuffer(channels, len, context.sampleRate);\n      var multiChannelArray = !isMultidimensional && channels === 1 ? [array] : array;\n      for (var c = 0; c < channels; c++) {\n        buffer.copyToChannel(multiChannelArray[c], c);\n      }\n      this._buffer = buffer;\n      return this;\n    }\n    /**\n     * Sums multiple channels into 1 channel\n     * @param chanNum Optionally only copy a single channel from the array.\n     */\n  }, {\n    key: \"toMono\",\n    value: function toMono(chanNum) {\n      if (isNumber(chanNum)) {\n        this.fromArray(this.toArray(chanNum));\n      } else {\n        var outputArray = new Float32Array(this.length);\n        var numChannels = this.numberOfChannels;\n        for (var channel = 0; channel < numChannels; channel++) {\n          var channelArray = this.toArray(channel);\n          for (var i = 0; i < channelArray.length; i++) {\n            outputArray[i] += channelArray[i];\n          }\n        }\n        // divide by the number of channels\n        outputArray = outputArray.map(function (sample) {\n          return sample / numChannels;\n        });\n        this.fromArray(outputArray);\n      }\n      return this;\n    }\n    /**\n     * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n     * Float32Array, and multichannel buffers will return multidimensional arrays.\n     * @param channel Optionally only copy a single channel from the array.\n     */\n  }, {\n    key: \"toArray\",\n    value: function toArray(channel) {\n      if (isNumber(channel)) {\n        return this.getChannelData(channel);\n      } else if (this.numberOfChannels === 1) {\n        return this.toArray(0);\n      } else {\n        var ret = [];\n        for (var c = 0; c < this.numberOfChannels; c++) {\n          ret[c] = this.getChannelData(c);\n        }\n        return ret;\n      }\n    }\n    /**\n     * Returns the Float32Array representing the PCM audio data for the specific channel.\n     * @param  channel  The channel number to return\n     * @return The audio as a TypedArray\n     */\n  }, {\n    key: \"getChannelData\",\n    value: function getChannelData(channel) {\n      if (this._buffer) {\n        return this._buffer.getChannelData(channel);\n      } else {\n        return new Float32Array(0);\n      }\n    }\n    /**\n     * Cut a subsection of the array and return a buffer of the\n     * subsection. Does not modify the original buffer\n     * @param start The time to start the slice\n     * @param end The end time to slice. If none is given will default to the end of the buffer\n     */\n  }, {\n    key: \"slice\",\n    value: function slice(start) {\n      var end = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.duration;\n      var startSamples = Math.floor(start * this.sampleRate);\n      var endSamples = Math.floor(end * this.sampleRate);\n      assert(startSamples < endSamples, \"The start time must be less than the end time\");\n      var length = endSamples - startSamples;\n      var retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n      for (var channel = 0; channel < this.numberOfChannels; channel++) {\n        retBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n      }\n      return new ToneAudioBuffer(retBuffer);\n    }\n    /**\n     * Reverse the buffer.\n     */\n  }, {\n    key: \"_reverse\",\n    value: function _reverse() {\n      if (this.loaded) {\n        for (var i = 0; i < this.numberOfChannels; i++) {\n          this.getChannelData(i).reverse();\n        }\n      }\n      return this;\n    }\n    /**\n     * If the buffer is loaded or not\n     */\n  }, {\n    key: \"loaded\",\n    get: function get() {\n      return this.length > 0;\n    }\n    /**\n     * The duration of the buffer in seconds.\n     */\n  }, {\n    key: \"duration\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.duration;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The length of the buffer in samples\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.length;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n     */\n  }, {\n    key: \"numberOfChannels\",\n    get: function get() {\n      if (this._buffer) {\n        return this._buffer.numberOfChannels;\n      } else {\n        return 0;\n      }\n    }\n    /**\n     * Reverse the buffer.\n     */\n  }, {\n    key: \"reverse\",\n    get: function get() {\n      return this._reversed;\n    },\n    set: function set(rev) {\n      if (this._reversed !== rev) {\n        this._reversed = rev;\n        this._reverse();\n      }\n    }\n    /**\n     * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n     * pass in a multidimensional array.\n     * @param array The array to fill the audio buffer\n     * @return A ToneAudioBuffer created from the array\n     */\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return {\n        onerror: noOp,\n        onload: noOp,\n        reverse: false\n      };\n    }\n  }, {\n    key: \"fromArray\",\n    value: function fromArray(array) {\n      return new ToneAudioBuffer().fromArray(array);\n    }\n    /**\n     * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n     * @param  url The url to load.\n     * @return A promise which resolves to a ToneAudioBuffer\n     */\n  }, {\n    key: \"fromUrl\",\n    value: function fromUrl(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var buffer;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              buffer = new ToneAudioBuffer();\n              _context2.next = 3;\n              return buffer.load(url);\n            case 3:\n              return _context2.abrupt(\"return\", _context2.sent);\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n    }\n    /**\n     * Loads a url using fetch and returns the AudioBuffer.\n     */\n  }, {\n    key: \"load\",\n    value: function load(url) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee3() {\n        var matches, extensions, extension, _iterator, _step, ext, baseUrl, response, arrayBuffer, audioBuffer;\n        return _regeneratorRuntime().wrap(function _callee3$(_context3) {\n          while (1) switch (_context3.prev = _context3.next) {\n            case 0:\n              // test if the url contains multiple extensions\n              matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n              if (!matches) {\n                _context3.next = 23;\n                break;\n              }\n              extensions = matches[1].split(\"|\");\n              extension = extensions[0];\n              _iterator = _createForOfIteratorHelper(extensions);\n              _context3.prev = 5;\n              _iterator.s();\n            case 7:\n              if ((_step = _iterator.n()).done) {\n                _context3.next = 14;\n                break;\n              }\n              ext = _step.value;\n              if (!ToneAudioBuffer.supportsType(ext)) {\n                _context3.next = 12;\n                break;\n              }\n              extension = ext;\n              return _context3.abrupt(\"break\", 14);\n            case 12:\n              _context3.next = 7;\n              break;\n            case 14:\n              _context3.next = 19;\n              break;\n            case 16:\n              _context3.prev = 16;\n              _context3.t0 = _context3[\"catch\"](5);\n              _iterator.e(_context3.t0);\n            case 19:\n              _context3.prev = 19;\n              _iterator.f();\n              return _context3.finish(19);\n            case 22:\n              url = url.replace(matches[0], extension);\n            case 23:\n              // make sure there is a slash between the baseUrl and the url\n              baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n              _context3.next = 26;\n              return fetch(baseUrl + url);\n            case 26:\n              response = _context3.sent;\n              if (response.ok) {\n                _context3.next = 29;\n                break;\n              }\n              throw new Error(\"could not load url: \".concat(url));\n            case 29:\n              _context3.next = 31;\n              return response.arrayBuffer();\n            case 31:\n              arrayBuffer = _context3.sent;\n              _context3.next = 34;\n              return getContext().decodeAudioData(arrayBuffer);\n            case 34:\n              audioBuffer = _context3.sent;\n              return _context3.abrupt(\"return\", audioBuffer);\n            case 36:\n            case \"end\":\n              return _context3.stop();\n          }\n        }, _callee3, null, [[5, 16, 19, 22]]);\n      }));\n    }\n    /**\n     * Checks a url's extension to see if the current browser can play that file type.\n     * @param url The url/extension to test\n     * @return If the file extension can be played\n     * @static\n     * @example\n     * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n     * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n     */\n  }, {\n    key: \"supportsType\",\n    value: function supportsType(url) {\n      var extensions = url.split(\".\");\n      var extension = extensions[extensions.length - 1];\n      var response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n      return response !== \"\";\n    }\n    /**\n     * Returns a Promise which resolves when all of the buffers have loaded\n     */\n  }, {\n    key: \"loaded\",\n    value: function loaded() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee4() {\n        return _regeneratorRuntime().wrap(function _callee4$(_context4) {\n          while (1) switch (_context4.prev = _context4.next) {\n            case 0:\n              _context4.next = 2;\n              return Promise.resolve();\n            case 2:\n              if (!ToneAudioBuffer.downloads.length) {\n                _context4.next = 7;\n                break;\n              }\n              _context4.next = 5;\n              return ToneAudioBuffer.downloads[0];\n            case 5:\n              _context4.next = 2;\n              break;\n            case 7:\n            case \"end\":\n              return _context4.stop();\n          }\n        }, _callee4);\n      }));\n    }\n  }]);\n  return ToneAudioBuffer;\n}(Tone);\n//-------------------------------------\n// STATIC METHODS\n//-------------------------------------\n/**\n * A path which is prefixed before every url.\n */\nToneAudioBuffer.baseUrl = \"\";\n/**\n * All of the downloads\n */\nToneAudioBuffer.downloads = [];","map":{"version":3,"mappings":"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","names":["getContext","Tone","isAudioBuffer","optionsFromArguments","noOp","isArray","isNumber","isString","assert","ToneAudioBuffer","options","getDefaults","arguments","reverse","onload","url","set","load","catch","onerror","_buffer","sampleRate","buffer","loaded","get","_reversed","_reverse","doneLoading","then","audioBuffer","downloads","push","index","indexOf","splice","undefined","array","isMultidimensional","length","channels","len","context","createBuffer","multiChannelArray","c","copyToChannel","chanNum","fromArray","toArray","outputArray","Float32Array","numChannels","numberOfChannels","channel","channelArray","i","map","sample","getChannelData","ret","start","end","duration","startSamples","Math","floor","endSamples","retBuffer","subarray","rev","matches","match","extensions","split","extension","ext","supportsType","replace","baseUrl","endsWith","fetch","response","ok","Error","arrayBuffer","decodeAudioData","document","createElement","canPlayType","Promise","resolve"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\context\\ToneAudioBuffer.ts"],"sourcesContent":["import { getContext } from \"../Global\";\nimport { Tone } from \"../Tone\";\nimport { Samples, Seconds } from \"../type/Units\";\nimport { isAudioBuffer } from \"../util/AdvancedTypeCheck\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { noOp } from \"../util/Interface\";\nimport { isArray, isNumber, isString } from \"../util/TypeCheck\";\nimport { assert } from \"../util/Debug\";\n\ninterface ToneAudioBufferOptions {\n\turl?: string | AudioBuffer | ToneAudioBuffer;\n\treverse: boolean;\n\tonload: (buffer?: ToneAudioBuffer) => void;\n\tonerror: (error: Error) => void;\n}\n\n/**\n * AudioBuffer loading and storage. ToneAudioBuffer is used internally by all\n * classes that make requests for audio files such as Tone.Player,\n * Tone.Sampler and Tone.Convolver.\n * @example\n * const buffer = new Tone.ToneAudioBuffer(\"https://tonejs.github.io/audio/casio/A1.mp3\", () => {\n * \tconsole.log(\"loaded\");\n * });\n * @category Core\n */\nexport class ToneAudioBuffer extends Tone {\n\n\treadonly name: string = \"ToneAudioBuffer\";\n\n\t/**\n\t * stores the loaded AudioBuffer\n\t */\n\tprivate _buffer?: AudioBuffer;\n\n\t/**\n\t * indicates if the buffer should be reversed or not\n\t */\n\tprivate _reversed!: boolean;\n\n\t/**\n\t * Callback when the buffer is loaded.\n\t */\n\tonload: (buffer: ToneAudioBuffer) => void = noOp;\n\n\t/**\n\t *\n\t * @param url The url to load, or the audio buffer to set.\n\t * @param onload A callback which is invoked after the buffer is loaded.\n\t *                           It's recommended to use `ToneAudioBuffer.on('load', callback)` instead\n\t *                           since it will give you a callback when _all_ buffers are loaded.\n\t * @param onerror The callback to invoke if there is an error\n\t */\n\tconstructor(\n\t\turl?: string | ToneAudioBuffer | AudioBuffer,\n\t\tonload?: (buffer: ToneAudioBuffer) => void,\n\t\tonerror?: (error: Error) => void,\n\t);\n\tconstructor(options?: Partial<ToneAudioBufferOptions>);\n\tconstructor() {\n\n\t\tsuper();\n\n\t\tconst options = optionsFromArguments(ToneAudioBuffer.getDefaults(), arguments, [\"url\", \"onload\", \"onerror\"]);\n\n\t\tthis.reverse = options.reverse;\n\t\tthis.onload = options.onload;\n\n\t\tif (options.url && isAudioBuffer(options.url) || options.url instanceof ToneAudioBuffer) {\n\t\t\tthis.set(options.url);\n\t\t} else if (isString(options.url)) {\n\t\t\t// initiate the download\n\t\t\tthis.load(options.url).catch(options.onerror);\n\t\t}\n\t}\n\n\tstatic getDefaults(): ToneAudioBufferOptions {\n\t\treturn {\n\t\t\tonerror: noOp,\n\t\t\tonload: noOp,\n\t\t\treverse: false,\n\t\t};\n\t}\n\n\t/**\n\t * The sample rate of the AudioBuffer\n\t */\n\tget sampleRate(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.sampleRate;\n\t\t} else {\n\t\t\treturn getContext().sampleRate;\n\t\t}\n\t}\n\n\t/**\n\t * Pass in an AudioBuffer or ToneAudioBuffer to set the value of this buffer.\n\t */\n\tset(buffer: AudioBuffer | ToneAudioBuffer): this {\n\t\tif (buffer instanceof ToneAudioBuffer) {\n\t\t\t// if it's loaded, set it\n\t\t\tif (buffer.loaded) {\n\t\t\t\tthis._buffer = buffer.get();\n\t\t\t} else {\n\t\t\t\t// otherwise when it's loaded, invoke it's callback\n\t\t\t\tbuffer.onload = () => {\n\t\t\t\t\tthis.set(buffer);\n\t\t\t\t\tthis.onload(this);\n\t\t\t\t};\n\t\t\t}\n\t\t} else {\n\t\t\tthis._buffer = buffer;\n\t\t}\n\t\t// reverse it initially\n\t\tif (this._reversed) {\n\t\t\tthis._reverse();\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * The audio buffer stored in the object.\n\t */\n\tget(): AudioBuffer | undefined {\n\t\treturn this._buffer;\n\t}\n\n\t/**\n\t * Makes an fetch request for the selected url then decodes the file as an audio buffer.\n\t * Invokes the callback once the audio buffer loads.\n\t * @param url The url of the buffer to load. filetype support depends on the browser.\n\t * @returns A Promise which resolves with this ToneAudioBuffer\n\t */\n\tasync load(url: string): Promise<this> {\n\t\tconst doneLoading: Promise<void> = ToneAudioBuffer.load(url).then(audioBuffer => {\n\t\t\tthis.set(audioBuffer);\n\t\t\t// invoke the onload method\n\t\t\tthis.onload(this);\n\t\t});\n\t\tToneAudioBuffer.downloads.push(doneLoading);\n\t\ttry {\n\t\t\tawait doneLoading;\n\t\t} finally {\n\t\t\t// remove the downloaded file\n\t\t\tconst index = ToneAudioBuffer.downloads.indexOf(doneLoading);\n\t\t\tToneAudioBuffer.downloads.splice(index, 1);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._buffer = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the audio buffer from the array.\n\t * To create a multichannel AudioBuffer, pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t */\n\tfromArray(array: Float32Array | Float32Array[]): this {\n\t\tconst isMultidimensional = isArray(array) && array[0].length > 0;\n\t\tconst channels = isMultidimensional ? array.length : 1;\n\t\tconst len = isMultidimensional ? (array[0] as Float32Array).length : array.length;\n\t\tconst context = getContext();\n\t\tconst buffer = context.createBuffer(channels, len, context.sampleRate);\n\t\tconst multiChannelArray: Float32Array[] = !isMultidimensional && channels === 1 ?\n\t\t\t[array as Float32Array] : array as Float32Array[];\n\n\t\tfor (let c = 0; c < channels; c++) {\n\t\t\tbuffer.copyToChannel(multiChannelArray[c], c);\n\t\t}\n\t\tthis._buffer = buffer;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Sums multiple channels into 1 channel\n\t * @param chanNum Optionally only copy a single channel from the array.\n\t */\n\ttoMono(chanNum?: number): this {\n\t\tif (isNumber(chanNum)) {\n\t\t\tthis.fromArray(this.toArray(chanNum));\n\t\t} else {\n\t\t\tlet outputArray = new Float32Array(this.length as number);\n\t\t\tconst numChannels = this.numberOfChannels;\n\t\t\tfor (let channel = 0; channel < numChannels; channel++) {\n\t\t\t\tconst channelArray = this.toArray(channel) as Float32Array;\n\t\t\t\tfor (let i = 0; i < channelArray.length; i++) {\n\t\t\t\t\toutputArray[i] += channelArray[i];\n\t\t\t\t}\n\t\t\t}\n\t\t\t// divide by the number of channels\n\t\t\toutputArray = outputArray.map(sample => sample / numChannels);\n\t\t\tthis.fromArray(outputArray);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the buffer as an array. Single channel buffers will return a 1-dimensional\n\t * Float32Array, and multichannel buffers will return multidimensional arrays.\n\t * @param channel Optionally only copy a single channel from the array.\n\t */\n\ttoArray(channel?: number): Float32Array | Float32Array[] {\n\t\tif (isNumber(channel)) {\n\t\t\treturn this.getChannelData(channel);\n\t\t} else if (this.numberOfChannels === 1) {\n\t\t\treturn this.toArray(0);\n\t\t} else {\n\t\t\tconst ret: Float32Array[] = [];\n\t\t\tfor (let c = 0; c < this.numberOfChannels; c++) {\n\t\t\t\tret[c] = this.getChannelData(c);\n\t\t\t}\n\t\t\treturn ret;\n\t\t}\n\t}\n\n\t/**\n\t * Returns the Float32Array representing the PCM audio data for the specific channel.\n\t * @param  channel  The channel number to return\n\t * @return The audio as a TypedArray\n\t */\n\tgetChannelData(channel: number): Float32Array {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.getChannelData(channel);\n\t\t} else {\n\t\t\treturn new Float32Array(0);\n\t\t}\n\t}\n\n\t/**\n\t * Cut a subsection of the array and return a buffer of the\n\t * subsection. Does not modify the original buffer\n\t * @param start The time to start the slice\n\t * @param end The end time to slice. If none is given will default to the end of the buffer\n\t */\n\tslice(start: Seconds, end: Seconds = this.duration): ToneAudioBuffer {\n\t\tconst startSamples = Math.floor(start * this.sampleRate);\n\t\tconst endSamples = Math.floor(end * this.sampleRate);\n\t\tassert(startSamples < endSamples, \"The start time must be less than the end time\");\n\t\tconst length = endSamples - startSamples;\n\t\tconst retBuffer = getContext().createBuffer(this.numberOfChannels, length, this.sampleRate);\n\t\tfor (let channel = 0; channel < this.numberOfChannels; channel++) {\n\t\t\tretBuffer.copyToChannel(this.getChannelData(channel).subarray(startSamples, endSamples), channel);\n\t\t}\n\t\treturn new ToneAudioBuffer(retBuffer);\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tprivate _reverse(): this {\n\t\tif (this.loaded) {\n\t\t\tfor (let i = 0; i < this.numberOfChannels; i++) {\n\t\t\t\tthis.getChannelData(i).reverse();\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * If the buffer is loaded or not\n\t */\n\tget loaded(): boolean {\n\t\treturn this.length > 0;\n\t}\n\n\t/**\n\t * The duration of the buffer in seconds.\n\t */\n\tget duration(): Seconds {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.duration;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The length of the buffer in samples\n\t */\n\tget length(): Samples {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.length;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * The number of discrete audio channels. Returns 0 if no buffer is loaded.\n\t */\n\tget numberOfChannels(): number {\n\t\tif (this._buffer) {\n\t\t\treturn this._buffer.numberOfChannels;\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\n\n\t/**\n\t * Reverse the buffer.\n\t */\n\tget reverse(): boolean {\n\t\treturn this._reversed;\n\t}\n\tset reverse(rev: boolean) {\n\t\tif (this._reversed !== rev) {\n\t\t\tthis._reversed = rev;\n\t\t\tthis._reverse();\n\t\t}\n\t}\n\n\t//-------------------------------------\n\t// STATIC METHODS\n\t//-------------------------------------\n\n\t/**\n\t * A path which is prefixed before every url.\n\t */\n\tstatic baseUrl = \"\";\n\n\t/**\n\t * Create a ToneAudioBuffer from the array. To create a multichannel AudioBuffer,\n\t * pass in a multidimensional array.\n\t * @param array The array to fill the audio buffer\n\t * @return A ToneAudioBuffer created from the array\n\t */\n\tstatic fromArray(array: Float32Array | Float32Array[]): ToneAudioBuffer {\n\t\treturn (new ToneAudioBuffer()).fromArray(array);\n\t}\n\n\t/**\n\t * Creates a ToneAudioBuffer from a URL, returns a promise which resolves to a ToneAudioBuffer\n\t * @param  url The url to load.\n\t * @return A promise which resolves to a ToneAudioBuffer\n\t */\n\tstatic async fromUrl(url: string): Promise<ToneAudioBuffer> {\n\t\tconst buffer = new ToneAudioBuffer();\n\t\treturn await buffer.load(url);\n\t}\n\n\t/**\n\t * All of the downloads\n\t */\n\tstatic downloads: Array<Promise<void>> = [];\n\n\t/**\n\t * Loads a url using fetch and returns the AudioBuffer.\n\t */\n\tstatic async load(url: string): Promise<AudioBuffer> {\n\n\t\t// test if the url contains multiple extensions\n\t\tconst matches = url.match(/\\[([^\\]\\[]+\\|.+)\\]$/);\n\t\tif (matches) {\n\t\t\tconst extensions = matches[1].split(\"|\");\n\t\t\tlet extension = extensions[0];\n\t\t\tfor (const ext of extensions) {\n\t\t\t\tif (ToneAudioBuffer.supportsType(ext)) {\n\t\t\t\t\textension = ext;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\turl = url.replace(matches[0], extension);\n\t\t}\n\n\t\t// make sure there is a slash between the baseUrl and the url\n\t\tconst baseUrl = ToneAudioBuffer.baseUrl === \"\" || ToneAudioBuffer.baseUrl.endsWith(\"/\") ? ToneAudioBuffer.baseUrl : ToneAudioBuffer.baseUrl + \"/\";\n\t\tconst response = await fetch(baseUrl + url);\n\t\tif (!response.ok) {\n\t\t\tthrow new Error(`could not load url: ${url}`);\n\t\t}\n\t\tconst arrayBuffer = await response.arrayBuffer();\n\n\t\tconst audioBuffer = await getContext().decodeAudioData(arrayBuffer);\n\n\t\treturn audioBuffer;\n\t}\n\n\t/**\n\t * Checks a url's extension to see if the current browser can play that file type.\n\t * @param url The url/extension to test\n\t * @return If the file extension can be played\n\t * @static\n\t * @example\n\t * Tone.ToneAudioBuffer.supportsType(\"wav\"); // returns true\n\t * Tone.ToneAudioBuffer.supportsType(\"path/to/file.wav\"); // returns true\n\t */\n\tstatic supportsType(url: string): boolean {\n\t\tconst extensions = url.split(\".\");\n\t\tconst extension = extensions[extensions.length - 1];\n\t\tconst response = document.createElement(\"audio\").canPlayType(\"audio/\" + extension);\n\t\treturn response !== \"\";\n\t}\n\n\t/**\n\t * Returns a Promise which resolves when all of the buffers have loaded\n\t */\n\tstatic async loaded(): Promise<void> {\n\t\t// this makes sure that the function is always async\n\t\tawait Promise.resolve();\n\t\twhile (ToneAudioBuffer.downloads.length) {\n\t\t\tawait ToneAudioBuffer.downloads[0];\n\t\t}\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
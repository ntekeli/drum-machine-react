{"ast":null,"code":"import _regeneratorRuntime from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/regeneratorRuntime.js\";\nimport _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __awaiter } from \"tslib\";\nimport { connect, ToneAudioNode } from \"../core/context/ToneAudioNode\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input.\n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\nexport var UserMedia = /*#__PURE__*/function (_ToneAudioNode) {\n  _inherits(UserMedia, _ToneAudioNode);\n  var _super = _createSuper(UserMedia);\n  function UserMedia() {\n    var _this;\n    _classCallCheck(this, UserMedia);\n    _this = _super.call(this, optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n    _this.name = \"UserMedia\";\n    var options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n    _this._volume = _this.output = new Volume({\n      context: _this.context,\n      volume: options.volume\n    });\n    _this.volume = _this._volume.volume;\n    readOnly(_assertThisInitialized(_this), \"volume\");\n    _this.mute = options.mute;\n    return _this;\n  }\n  _createClass(UserMedia, [{\n    key: \"open\",\n    value:\n    /**\n     * Open the media stream. If a string is passed in, it is assumed\n     * to be the label or id of the stream, if a number is passed in,\n     * it is the input number of the stream.\n     * @param  labelOrId The label or id of the audio input media device.\n     *                   With no argument, the default stream is opened.\n     * @return The promise is resolved when the stream is open.\n     */\n    function open(labelOrId) {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee() {\n        var devices, constraints, stream, mediaStreamNode;\n        return _regeneratorRuntime().wrap(function _callee$(_context) {\n          while (1) switch (_context.prev = _context.next) {\n            case 0:\n              assert(UserMedia.supported, \"UserMedia is not supported\");\n              // close the previous stream\n              if (this.state === \"started\") {\n                this.close();\n              }\n              _context.next = 4;\n              return UserMedia.enumerateDevices();\n            case 4:\n              devices = _context.sent;\n              if (isNumber(labelOrId)) {\n                this._device = devices[labelOrId];\n              } else {\n                this._device = devices.find(function (device) {\n                  return device.label === labelOrId || device.deviceId === labelOrId;\n                });\n                // didn't find a matching device\n                if (!this._device && devices.length > 0) {\n                  this._device = devices[0];\n                }\n                assert(isDefined(this._device), \"No matching device \".concat(labelOrId));\n              }\n              // do getUserMedia\n              constraints = {\n                audio: {\n                  echoCancellation: false,\n                  sampleRate: this.context.sampleRate,\n                  noiseSuppression: false,\n                  mozNoiseSuppression: false\n                }\n              };\n              if (this._device) {\n                // @ts-ignore\n                constraints.audio.deviceId = this._device.deviceId;\n              }\n              _context.next = 10;\n              return navigator.mediaDevices.getUserMedia(constraints);\n            case 10:\n              stream = _context.sent;\n              // start a new source only if the previous one is closed\n              if (!this._stream) {\n                this._stream = stream;\n                // Wrap a MediaStreamSourceNode around the live input stream.\n                mediaStreamNode = this.context.createMediaStreamSource(stream); // Connect the MediaStreamSourceNode to a gate gain node\n                connect(mediaStreamNode, this.output);\n                this._mediaStream = mediaStreamNode;\n              }\n              return _context.abrupt(\"return\", this);\n            case 13:\n            case \"end\":\n              return _context.stop();\n          }\n        }, _callee, this);\n      }));\n    }\n    /**\n     * Close the media stream\n     */\n  }, {\n    key: \"close\",\n    value: function close() {\n      if (this._stream && this._mediaStream) {\n        this._stream.getAudioTracks().forEach(function (track) {\n          track.stop();\n        });\n        this._stream = undefined;\n        // remove the old media stream\n        this._mediaStream.disconnect();\n        this._mediaStream = undefined;\n      }\n      this._device = undefined;\n      return this;\n    }\n    /**\n     * Returns a promise which resolves with the list of audio input devices available.\n     * @return The promise that is resolved with the devices\n     * @example\n     * Tone.UserMedia.enumerateDevices().then((devices) => {\n     * \t// print the device labels\n     * \tconsole.log(devices.map(device => device.label));\n     * });\n     */\n  }, {\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, \"started\" when the microphone is open\n     * and \"stopped\" when the mic is closed.\n     */\n    function get() {\n      return this._stream && this._stream.active ? \"started\" : \"stopped\";\n    }\n    /**\n     * Returns an identifier for the represented device that is\n     * persisted across sessions. It is un-guessable by other applications and\n     * unique to the origin of the calling application. It is reset when the\n     * user clears cookies (for Private Browsing, a different identifier is\n     * used that is not persisted across sessions). Returns undefined when the\n     * device is not open.\n     */\n  }, {\n    key: \"deviceId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.deviceId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a group identifier. Two devices have the\n     * same group identifier if they belong to the same physical device.\n     * Returns null  when the device is not open.\n     */\n  }, {\n    key: \"groupId\",\n    get: function get() {\n      if (this._device) {\n        return this._device.groupId;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Returns a label describing this device (for example \"Built-in Microphone\").\n     * Returns undefined when the device is not open or label is not available\n     * because of permissions.\n     */\n  }, {\n    key: \"label\",\n    get: function get() {\n      if (this._device) {\n        return this._device.label;\n      } else {\n        return undefined;\n      }\n    }\n    /**\n     * Mute the output.\n     * @example\n     * const mic = new Tone.UserMedia();\n     * mic.open().then(() => {\n     * \t// promise resolves when input is available\n     * });\n     * // mute the output\n     * mic.mute = true;\n     */\n  }, {\n    key: \"mute\",\n    get: function get() {\n      return this._volume.mute;\n    },\n    set: function set(mute) {\n      this._volume.mute = mute;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(UserMedia.prototype), \"dispose\", this).call(this);\n      this.close();\n      this._volume.dispose();\n      this.volume.dispose();\n      return this;\n    }\n    /**\n     * If getUserMedia is supported by the browser.\n     */\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneAudioNode.getDefaults(), {\n        mute: false,\n        volume: 0\n      });\n    }\n  }, {\n    key: \"enumerateDevices\",\n    value: function enumerateDevices() {\n      return __awaiter(this, void 0, void 0, /*#__PURE__*/_regeneratorRuntime().mark(function _callee2() {\n        var allDevices;\n        return _regeneratorRuntime().wrap(function _callee2$(_context2) {\n          while (1) switch (_context2.prev = _context2.next) {\n            case 0:\n              _context2.next = 2;\n              return navigator.mediaDevices.enumerateDevices();\n            case 2:\n              allDevices = _context2.sent;\n              return _context2.abrupt(\"return\", allDevices.filter(function (device) {\n                return device.kind === \"audioinput\";\n              }));\n            case 4:\n            case \"end\":\n              return _context2.stop();\n          }\n        }, _callee2);\n      }));\n    }\n  }, {\n    key: \"supported\",\n    get: function get() {\n      return isDefined(navigator.mediaDevices) && isDefined(navigator.mediaDevices.getUserMedia);\n    }\n  }]);\n  return UserMedia;\n}(ToneAudioNode);","map":{"version":3,"mappings":"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","names":["connect","ToneAudioNode","Volume","optionsFromArguments","assert","readOnly","isDefined","isNumber","UserMedia","getDefaults","arguments","options","_volume","output","context","volume","mute","labelOrId","supported","state","close","enumerateDevices","devices","_device","find","device","label","deviceId","length","constraints","audio","echoCancellation","sampleRate","noiseSuppression","mozNoiseSuppression","navigator","mediaDevices","getUserMedia","stream","_stream","mediaStreamNode","createMediaStreamSource","_mediaStream","getAudioTracks","forEach","track","stop","undefined","disconnect","active","groupId","dispose","Object","assign","allDevices","filter","kind"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\source\\UserMedia.ts"],"sourcesContent":["import { connect, OutputNode, ToneAudioNode, ToneAudioNodeOptions } from \"../core/context/ToneAudioNode\";\nimport { Decibels } from \"../core/type/Units\";\nimport { Volume } from \"../component/channel/Volume\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { assert } from \"../core/util/Debug\";\nimport { Param } from \"../core/context/Param\";\nimport { readOnly } from \"../core/util/Interface\";\nimport { isDefined, isNumber } from \"../core/util/TypeCheck\";\n\nexport interface UserMediaOptions extends ToneAudioNodeOptions {\n\tvolume: Decibels;\n\tmute: boolean;\n}\n/**\n * UserMedia uses MediaDevices.getUserMedia to open up and external microphone or audio input. \n * Check [MediaDevices API Support](https://developer.mozilla.org/en-US/docs/Web/API/MediaDevices/getUserMedia)\n * to see which browsers are supported. Access to an external input\n * is limited to secure (HTTPS) connections.\n * @example\n * const meter = new Tone.Meter();\n * const mic = new Tone.UserMedia().connect(meter);\n * mic.open().then(() => {\n * \t// promise resolves when input is available\n * \tconsole.log(\"mic open\");\n * \t// print the incoming mic levels in decibels\n * \tsetInterval(() => console.log(meter.getValue()), 100);\n * }).catch(e => {\n * \t// promise is rejected when the user doesn't have or allow mic access\n * \tconsole.log(\"mic not open\");\n * });\n * @category Source\n */\n\nexport class UserMedia extends ToneAudioNode<UserMediaOptions> {\n\n\treadonly name: string = \"UserMedia\";\n\n\treadonly input: undefined;\n\treadonly output: OutputNode;\n\n\t/**\n\t * The MediaStreamNode\n\t */\n\tprivate _mediaStream?: MediaStreamAudioSourceNode;\n\n\t/**\n\t * The media stream created by getUserMedia.\n\t */\n\tprivate _stream?: MediaStream;\n\n\t/**\n\t * The open device\n\t */\n\tprivate _device?: MediaDeviceInfo;\n\n\t/**\n\t * The output volume node\n\t */\n\tprivate _volume: Volume;\n\n\t/**\n\t * The volume of the output in decibels.\n\t */\n\treadonly volume: Param<\"decibels\">;\n\n\t/**\n\t * @param volume The level of the input in decibels\n\t */\n\tconstructor(volume?: Decibels);\n\tconstructor(options?: Partial<UserMediaOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]));\n\t\tconst options = optionsFromArguments(UserMedia.getDefaults(), arguments, [\"volume\"]);\n\n\t\tthis._volume = this.output = new Volume({\n\t\t\tcontext: this.context,\n\t\t\tvolume: options.volume,\n\t\t});\n\t\tthis.volume = this._volume.volume;\n\t\treadOnly(this, \"volume\");\n\t\tthis.mute = options.mute;\n\t}\n\n\tstatic getDefaults(): UserMediaOptions {\n\t\treturn Object.assign(ToneAudioNode.getDefaults(), {\n\t\t\tmute: false,\n\t\t\tvolume: 0\n\t\t});\n\t}\n\n\t/**\n\t * Open the media stream. If a string is passed in, it is assumed\n\t * to be the label or id of the stream, if a number is passed in,\n\t * it is the input number of the stream.\n\t * @param  labelOrId The label or id of the audio input media device.\n\t *                   With no argument, the default stream is opened.\n\t * @return The promise is resolved when the stream is open.\n\t */\n\tasync open(labelOrId?: string | number): Promise<this> {\n\t\tassert(UserMedia.supported, \"UserMedia is not supported\");\n\t\t// close the previous stream\n\t\tif (this.state === \"started\") {\n\t\t\tthis.close();\n\t\t}\n\t\tconst devices = await UserMedia.enumerateDevices();\n\t\tif (isNumber(labelOrId)) {\n\t\t\tthis._device = devices[labelOrId];\n\t\t} else {\n\t\t\tthis._device = devices.find((device) => {\n\t\t\t\treturn device.label === labelOrId || device.deviceId === labelOrId;\n\t\t\t});\n\t\t\t// didn't find a matching device\n\t\t\tif (!this._device && devices.length > 0) {\n\t\t\t\tthis._device = devices[0];\n\t\t\t}\n\t\t\tassert(isDefined(this._device), `No matching device ${labelOrId}`);\n\t\t}\n\t\t// do getUserMedia\n\t\tconst constraints = {\n\t\t\taudio: {\n\t\t\t\techoCancellation: false,\n\t\t\t\tsampleRate: this.context.sampleRate,\n\t\t\t\tnoiseSuppression: false,\n\t\t\t\tmozNoiseSuppression: false,\n\t\t\t}\n\t\t};\n\t\tif (this._device) {\n\t\t\t// @ts-ignore\n\t\t\tconstraints.audio.deviceId = this._device.deviceId;\n\t\t}\n\t\tconst stream = await navigator.mediaDevices.getUserMedia(constraints);\n\t\t// start a new source only if the previous one is closed\n\t\tif (!this._stream) {\n\t\t\tthis._stream = stream;\n\t\t\t// Wrap a MediaStreamSourceNode around the live input stream.\n\t\t\tconst mediaStreamNode = this.context.createMediaStreamSource(stream);\n\t\t\t// Connect the MediaStreamSourceNode to a gate gain node\n\t\t\tconnect(mediaStreamNode, this.output);\n\t\t\tthis._mediaStream = mediaStreamNode;\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Close the media stream\n\t */\n\tclose(): this {\n\t\tif (this._stream && this._mediaStream) {\n\t\t\tthis._stream.getAudioTracks().forEach((track) => {\n\t\t\t\ttrack.stop();\n\t\t\t});\n\t\t\tthis._stream = undefined;\n\t\t\t// remove the old media stream\n\t\t\tthis._mediaStream.disconnect();\n\t\t\tthis._mediaStream = undefined;\n\t\t}\n\t\tthis._device = undefined;\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns a promise which resolves with the list of audio input devices available.\n\t * @return The promise that is resolved with the devices\n\t * @example\n\t * Tone.UserMedia.enumerateDevices().then((devices) => {\n\t * \t// print the device labels\n\t * \tconsole.log(devices.map(device => device.label));\n\t * });\n\t */\n\tstatic async enumerateDevices(): Promise<MediaDeviceInfo[]> {\n\t\tconst allDevices = await navigator.mediaDevices.enumerateDevices();\n\t\treturn allDevices.filter(device => {\n\t\t\treturn device.kind === \"audioinput\";\n\t\t});\n\t}\n\n\t/**\n\t * Returns the playback state of the source, \"started\" when the microphone is open\n\t * and \"stopped\" when the mic is closed.\n\t */\n\tget state() {\n\t\treturn this._stream && this._stream.active ? \"started\" : \"stopped\";\n\t}\n\n\t/**\n\t * Returns an identifier for the represented device that is\n\t * persisted across sessions. It is un-guessable by other applications and\n\t * unique to the origin of the calling application. It is reset when the\n\t * user clears cookies (for Private Browsing, a different identifier is\n\t * used that is not persisted across sessions). Returns undefined when the\n\t * device is not open.\n\t */\n\tget deviceId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.deviceId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a group identifier. Two devices have the\n\t * same group identifier if they belong to the same physical device.\n\t * Returns null  when the device is not open.\n\t */\n\tget groupId(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.groupId;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Returns a label describing this device (for example \"Built-in Microphone\").\n\t * Returns undefined when the device is not open or label is not available\n\t * because of permissions.\n\t */\n\tget label(): string | undefined {\n\t\tif (this._device) {\n\t\t\treturn this._device.label;\n\t\t} else {\n\t\t\treturn undefined;\n\t\t}\n\t}\n\n\t/**\n\t * Mute the output.\n\t * @example\n\t * const mic = new Tone.UserMedia();\n\t * mic.open().then(() => {\n\t * \t// promise resolves when input is available\n\t * });\n\t * // mute the output\n\t * mic.mute = true;\n\t */\n\tget mute(): boolean {\n\t\treturn this._volume.mute;\n\t}\n\tset mute(mute) {\n\t\tthis._volume.mute = mute;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.close();\n\t\tthis._volume.dispose();\n\t\tthis.volume.dispose();\n\t\treturn this;\n\t}\n\n\t/**\n\t * If getUserMedia is supported by the browser.\n\t */\n\tstatic get supported(): boolean {\n\t\treturn isDefined(navigator.mediaDevices) &&\n\t\t\tisDefined(navigator.mediaDevices.getUserMedia);\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
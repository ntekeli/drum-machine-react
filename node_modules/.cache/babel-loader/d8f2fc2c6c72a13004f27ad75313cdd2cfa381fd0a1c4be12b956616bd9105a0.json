{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport var Part = /*#__PURE__*/function (_ToneEvent) {\n  _inherits(Part, _ToneEvent);\n  var _super = _createSuper(Part);\n  function Part() {\n    var _this;\n    _classCallCheck(this, Part);\n    _this = _super.call(this, optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n    _this.name = \"Part\";\n    /**\n     * Tracks the scheduled events\n     */\n    _this._state = new StateTimeline(\"stopped\");\n    /**\n     * The events that belong to this part\n     */\n    _this._events = new Set();\n    var options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n    // make sure things are assigned in the right order\n    _this._state.increasing = true;\n    // add the events\n    options.events.forEach(function (event) {\n      if (isArray(event)) {\n        _this.add(event[0], event[1]);\n      } else {\n        _this.add(event);\n      }\n    });\n    return _this;\n  }\n  _createClass(Part, [{\n    key: \"start\",\n    value:\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset from the start of the part to begin playing at.\n     */\n    function start(time, offset) {\n      var _this2 = this;\n      var ticks = this.toTicks(time);\n      if (this._state.getValueAtTime(ticks) !== \"started\") {\n        offset = defaultArg(offset, this._loop ? this._loopStart : 0);\n        if (this._loop) {\n          offset = defaultArg(offset, this._loopStart);\n        } else {\n          offset = defaultArg(offset, 0);\n        }\n        var computedOffset = this.toTicks(offset);\n        this._state.add({\n          id: -1,\n          offset: computedOffset,\n          state: \"started\",\n          time: ticks\n        });\n        this._forEach(function (event) {\n          _this2._startNote(event, ticks, computedOffset);\n        });\n      }\n      return this;\n    }\n    /**\n     * Start the event in the given event at the correct time given\n     * the ticks and offset and looping.\n     * @param  event\n     * @param  ticks\n     * @param  offset\n     */\n  }, {\n    key: \"_startNote\",\n    value: function _startNote(event, ticks, offset) {\n      ticks -= offset;\n      if (this._loop) {\n        if (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n          if (event.startOffset < offset) {\n            // start it on the next loop\n            ticks += this._getLoopDuration();\n          }\n          event.start(new TicksClass(this.context, ticks));\n        } else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n          event.loop = false;\n          event.start(new TicksClass(this.context, ticks));\n        }\n      } else if (event.startOffset >= offset) {\n        event.start(new TicksClass(this.context, ticks));\n      }\n    }\n  }, {\n    key: \"startOffset\",\n    get: function get() {\n      return this._startOffset;\n    },\n    set: function set(offset) {\n      var _this3 = this;\n      this._startOffset = offset;\n      this._forEach(function (event) {\n        event.startOffset += _this3._startOffset;\n      });\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var ticks = this.toTicks(time);\n      this._state.cancel(ticks);\n      this._state.setStateAtTime(\"stopped\", ticks);\n      this._forEach(function (event) {\n        event.stop(time);\n      });\n      return this;\n    }\n    /**\n     * Get/Set an Event's value at the given time.\n     * If a value is passed in and no event exists at\n     * the given time, one will be created with that value.\n     * If two events are at the same time, the first one will\n     * be returned.\n     * @example\n     * const part = new Tone.Part();\n     * part.at(\"1m\"); // returns the part at the first measure\n     * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n     * // if an event didn't exist at that time, it will be created.\n     * @param time The time of the event to get or set.\n     * @param value If a value is passed in, the value of the event at the given time will be set to it.\n     */\n  }, {\n    key: \"at\",\n    value: function at(time, value) {\n      var timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n      var tickTime = new TicksClass(this.context, 1).toSeconds();\n      var iterator = this._events.values();\n      var result = iterator.next();\n      while (!result.done) {\n        var event = result.value;\n        if (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n          if (isDefined(value)) {\n            event.value = value;\n          }\n          return event;\n        }\n        result = iterator.next();\n      }\n      // if there was no event at that time, create one\n      if (isDefined(value)) {\n        this.add(time, value);\n        // return the new event\n        return this.at(time);\n      } else {\n        return null;\n      }\n    }\n  }, {\n    key: \"add\",\n    value: function add(time, value) {\n      // extract the parameters\n      if (time instanceof Object && Reflect.has(time, \"time\")) {\n        value = time;\n        time = value.time;\n      }\n      var ticks = this.toTicks(time);\n      var event;\n      if (value instanceof ToneEvent) {\n        event = value;\n        event.callback = this._tick.bind(this);\n      } else {\n        event = new ToneEvent({\n          callback: this._tick.bind(this),\n          context: this.context,\n          value: value\n        });\n      }\n      // the start offset\n      event.startOffset = ticks;\n      // initialize the values\n      event.set({\n        humanize: this.humanize,\n        loop: this.loop,\n        loopEnd: this.loopEnd,\n        loopStart: this.loopStart,\n        playbackRate: this.playbackRate,\n        probability: this.probability\n      });\n      this._events.add(event);\n      // start the note if it should be played right now\n      this._restartEvent(event);\n      return this;\n    }\n    /**\n     * Restart the given event\n     */\n  }, {\n    key: \"_restartEvent\",\n    value: function _restartEvent(event) {\n      var _this4 = this;\n      this._state.forEach(function (stateEvent) {\n        if (stateEvent.state === \"started\") {\n          _this4._startNote(event, stateEvent.time, stateEvent.offset);\n        } else {\n          // stop the note\n          event.stop(new TicksClass(_this4.context, stateEvent.time));\n        }\n      });\n    }\n  }, {\n    key: \"remove\",\n    value: function remove(time, value) {\n      var _this5 = this;\n      // extract the parameters\n      if (isObject(time) && time.hasOwnProperty(\"time\")) {\n        value = time;\n        time = value.time;\n      }\n      time = this.toTicks(time);\n      this._events.forEach(function (event) {\n        if (event.startOffset === time) {\n          if (isUndef(value) || isDefined(value) && event.value === value) {\n            _this5._events.delete(event);\n            event.dispose();\n          }\n        }\n      });\n      return this;\n    }\n    /**\n     * Remove all of the notes from the group.\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._forEach(function (event) {\n        return event.dispose();\n      });\n      this._events.clear();\n      return this;\n    }\n    /**\n     * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n     * @param after The time after which to cancel the scheduled events.\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(after) {\n      this._forEach(function (event) {\n        return event.cancel(after);\n      });\n      this._state.cancel(this.toTicks(after));\n      return this;\n    }\n    /**\n     * Iterate over all of the events\n     */\n  }, {\n    key: \"_forEach\",\n    value: function _forEach(callback) {\n      if (this._events) {\n        this._events.forEach(function (event) {\n          if (event instanceof Part) {\n            event._forEach(callback);\n          } else {\n            callback(event);\n          }\n        });\n      }\n      return this;\n    }\n    /**\n     * Set the attribute of all of the events\n     * @param  attr  the attribute to set\n     * @param  value      The value to set it to\n     */\n  }, {\n    key: \"_setAll\",\n    value: function _setAll(attr, value) {\n      this._forEach(function (event) {\n        event[attr] = value;\n      });\n    }\n    /**\n     * Internal tick method\n     * @param  time  The time of the event in seconds\n     */\n  }, {\n    key: \"_tick\",\n    value: function _tick(time, value) {\n      if (!this.mute) {\n        this.callback(time, value);\n      }\n    }\n    /**\n     * Determine if the event should be currently looping\n     * given the loop boundries of this Part.\n     * @param  event  The event to test\n     */\n  }, {\n    key: \"_testLoopBoundries\",\n    value: function _testLoopBoundries(event) {\n      if (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n        event.cancel(0);\n      } else if (event.state === \"stopped\") {\n        // reschedule it if it's stopped\n        this._restartEvent(event);\n      }\n    }\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._probability;\n    },\n    set: function set(prob) {\n      this._probability = prob;\n      this._setAll(\"probability\", prob);\n    }\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._humanize;\n    },\n    set: function set(variation) {\n      this._humanize = variation;\n      this._setAll(\"humanize\", variation);\n    }\n    /**\n     * If the part should loop or not\n     * between Part.loopStart and\n     * Part.loopEnd. If set to true,\n     * the part will loop indefinitely,\n     * if set to a number greater than 1\n     * it will play a specific number of\n     * times, if set to false, 0 or 1, the\n     * part will only play once.\n     * @example\n     * const part = new Tone.Part();\n     * // loop the part 8 times\n     * part.loop = 8;\n     */\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._loop;\n    },\n    set: function set(loop) {\n      var _this6 = this;\n      this._loop = loop;\n      this._forEach(function (event) {\n        event.loopStart = _this6.loopStart;\n        event.loopEnd = _this6.loopEnd;\n        event.loop = loop;\n        _this6._testLoopBoundries(event);\n      });\n    }\n    /**\n     * The loopEnd point determines when it will\n     * loop if Part.loop is true.\n     */\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return new TicksClass(this.context, this._loopEnd).toSeconds();\n    },\n    set: function set(loopEnd) {\n      var _this7 = this;\n      this._loopEnd = this.toTicks(loopEnd);\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopEnd = loopEnd;\n          _this7._testLoopBoundries(event);\n        });\n      }\n    }\n    /**\n     * The loopStart point determines when it will\n     * loop if Part.loop is true.\n     */\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return new TicksClass(this.context, this._loopStart).toSeconds();\n    },\n    set: function set(loopStart) {\n      var _this8 = this;\n      this._loopStart = this.toTicks(loopStart);\n      if (this._loop) {\n        this._forEach(function (event) {\n          event.loopStart = _this8.loopStart;\n          _this8._testLoopBoundries(event);\n        });\n      }\n    }\n    /**\n     * The playback rate of the part\n     */\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._playbackRate;\n    },\n    set: function set(rate) {\n      this._playbackRate = rate;\n      this._setAll(\"playbackRate\", rate);\n    }\n    /**\n     * The number of scheduled notes in the part.\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._events.size;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Part.prototype), \"dispose\", this).call(this);\n      this.clear();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(ToneEvent.getDefaults(), {\n        events: []\n      });\n    }\n  }]);\n  return Part;\n}(ToneEvent);","map":{"version":3,"mappings":"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","names":["TicksClass","TransportTimeClass","defaultArg","optionsFromArguments","StateTimeline","isArray","isDefined","isObject","isUndef","ToneEvent","Part","getDefaults","arguments","Set","options","_state","increasing","events","forEach","event","add","time","offset","ticks","toTicks","getValueAtTime","_loop","_loopStart","computedOffset","id","state","_forEach","_startNote","startOffset","_loopEnd","_getLoopDuration","start","context","loop","_startOffset","cancel","setStateAtTime","stop","value","timeInTicks","tickTime","toSeconds","iterator","_events","values","result","next","done","Math","abs","at","Object","Reflect","has","callback","_tick","bind","set","humanize","loopEnd","loopStart","playbackRate","probability","_restartEvent","stateEvent","hasOwnProperty","delete","dispose","clear","after","attr","mute","_probability","prob","_setAll","_humanize","variation","_testLoopBoundries","_playbackRate","rate","size","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\event\\Part.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { TransportTimeClass } from \"../core/type/TransportTime\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { defaultArg, optionsFromArguments } from \"../core/util/Defaults\";\nimport { StateTimeline } from \"../core/util/StateTimeline\";\nimport { isArray, isDefined, isObject, isUndef } from \"../core/util/TypeCheck\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype CallbackType<T> =\n\tT extends {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t} ? T :\n\t\tT extends ArrayLike<any> ? T[1] :\n\t\t\tT extends Time ? null : never;\n\ninterface PartOptions<T> extends Omit<ToneEventOptions<CallbackType<T>>, \"value\"> {\n\tevents: T[];\n}\n\n/**\n * Part is a collection ToneEvents which can be started/stopped and looped as a single unit.\n *\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const part = new Tone.Part(((time, note) => {\n * \t// the notes given as the second element in the array\n * \t// will be passed in as the second argument\n * \tsynth.triggerAttackRelease(note, \"8n\", time);\n * }), [[0, \"C2\"], [\"0:2\", \"C3\"], [\"0:3:2\", \"G2\"]]);\n * Tone.Transport.start();\n * @example\n * const synth = new Tone.Synth().toDestination();\n * // use an array of objects as long as the object has a \"time\" attribute\n * const part = new Tone.Part(((time, value) => {\n * \t// the value is an object which contains both the note and the velocity\n * \tsynth.triggerAttackRelease(value.note, \"8n\", time, value.velocity);\n * }), [{ time: 0, note: \"C3\", velocity: 0.9 },\n * \t{ time: \"0:2\", note: \"C4\", velocity: 0.5 }\n * ]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Part<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Part\";\n\n\t/**\n\t * Tracks the scheduled events\n\t */\n\tprotected _state: StateTimeline<{\n\t\tid: number;\n\t\toffset: number;\n\t}> = new StateTimeline(\"stopped\");\n\n\t/**\n\t * The events that belong to this part\n\t */\n\tprivate _events: Set<ToneEvent> = new Set();\n\n\t/**\n\t * @param callback The callback to invoke on each event\n\t * @param events the array of events\n\t */\n\tconstructor(callback?: ToneEventCallback<CallbackType<ValueType>>, value?: ValueType[]);\n\tconstructor(options?: Partial<PartOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]));\n\t\tconst options = optionsFromArguments(Part.getDefaults(), arguments, [\"callback\", \"events\"]);\n\n\t\t// make sure things are assigned in the right order\n\t\tthis._state.increasing = true;\n\n\t\t// add the events\n\t\toptions.events.forEach(event => {\n\t\t\tif (isArray(event)) {\n\t\t\t\tthis.add(event[0], event[1]);\n\t\t\t} else {\n\t\t\t\tthis.add(event);\n\t\t\t}\n\t\t});\n\t}\n\n\tstatic getDefaults(): PartOptions<any> {\n\t\treturn Object.assign(ToneEvent.getDefaults(), {\n\t\t\tevents: [],\n\t\t});\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset from the start of the part to begin playing at.\n\t */\n\tstart(time?: TransportTime, offset?: Time): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tif (this._state.getValueAtTime(ticks) !== \"started\") {\n\t\t\toffset = defaultArg(offset, this._loop ? this._loopStart : 0);\n\t\t\tif (this._loop) {\n\t\t\t\toffset = defaultArg(offset, this._loopStart);\n\t\t\t} else {\n\t\t\t\toffset = defaultArg(offset, 0);\n\t\t\t}\n\t\t\tconst computedOffset = this.toTicks(offset);\n\t\t\tthis._state.add({\n\t\t\t\tid: -1,\n\t\t\t\toffset: computedOffset,\n\t\t\t\tstate: \"started\",\n\t\t\t\ttime: ticks,\n\t\t\t});\n\t\t\tthis._forEach(event => {\n\t\t\t\tthis._startNote(event, ticks, computedOffset);\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Start the event in the given event at the correct time given\n\t * the ticks and offset and looping.\n\t * @param  event\n\t * @param  ticks\n\t * @param  offset\n\t */\n\tprivate _startNote(event: ToneEvent, ticks: Ticks, offset: Ticks): void {\n\t\tticks -= offset;\n\t\tif (this._loop) {\n\t\t\tif (event.startOffset >= this._loopStart && event.startOffset < this._loopEnd) {\n\t\t\t\tif (event.startOffset < offset) {\n\t\t\t\t\t// start it on the next loop\n\t\t\t\t\tticks += this._getLoopDuration();\n\t\t\t\t}\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t} else if (event.startOffset < this._loopStart && event.startOffset >= offset) {\n\t\t\t\tevent.loop = false;\n\t\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t\t}\n\t\t} else if (event.startOffset >= offset) {\n\t\t\tevent.start(new TicksClass(this.context, ticks));\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._startOffset;\n\t}\n\tset startOffset(offset) {\n\t\tthis._startOffset = offset;\n\t\tthis._forEach(event => {\n\t\t\tevent.startOffset += this._startOffset;\n\t\t});\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tconst ticks = this.toTicks(time);\n\t\tthis._state.cancel(ticks);\n\t\tthis._state.setStateAtTime(\"stopped\", ticks);\n\t\tthis._forEach(event => {\n\t\t\tevent.stop(time);\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get/Set an Event's value at the given time.\n\t * If a value is passed in and no event exists at\n\t * the given time, one will be created with that value.\n\t * If two events are at the same time, the first one will\n\t * be returned.\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.at(\"1m\"); // returns the part at the first measure\n\t * part.at(\"2m\", \"C2\"); // set the value at \"2m\" to C2.\n\t * // if an event didn't exist at that time, it will be created.\n\t * @param time The time of the event to get or set.\n\t * @param value If a value is passed in, the value of the event at the given time will be set to it.\n\t */\n\tat(time: Time, value?: any): ToneEvent | null {\n\t\tconst timeInTicks = new TransportTimeClass(this.context, time).toTicks();\n\t\tconst tickTime = new TicksClass(this.context, 1).toSeconds();\n\n\t\tconst iterator = this._events.values();\n\t\tlet result = iterator.next();\n\t\twhile (!result.done) {\n\t\t\tconst event = result.value;\n\t\t\tif (Math.abs(timeInTicks - event.startOffset) < tickTime) {\n\t\t\t\tif (isDefined(value)) {\n\t\t\t\t\tevent.value = value;\n\t\t\t\t}\n\t\t\t\treturn event;\n\t\t\t}\n\t\t\tresult = iterator.next();\n\t\t}\n\t\t// if there was no event at that time, create one\n\t\tif (isDefined(value)) {\n\t\t\tthis.add(time, value);\n\t\t\t// return the new event\n\t\t\treturn this.at(time);\n\t\t} else {\n\t\t\treturn null;\n\t\t}\n\t}\n\n\t/**\n\t * Add a an event to the part.\n\t * @param time The time the note should start. If an object is passed in, it should\n\t * \t\thave a 'time' attribute and the rest of the object will be used as the 'value'.\n\t * @param  value\n\t * @example\n\t * const part = new Tone.Part();\n\t * part.add(\"1m\", \"C#+11\");\n\t */\n\tadd(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tadd(time: Time, value?: any): this;\n\tadd(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (time instanceof Object && Reflect.has(time, \"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\tconst ticks = this.toTicks(time);\n\t\tlet event: ToneEvent;\n\t\tif (value instanceof ToneEvent) {\n\t\t\tevent = value;\n\t\t\tevent.callback = this._tick.bind(this);\n\t\t} else {\n\t\t\tevent = new ToneEvent({\n\t\t\t\tcallback: this._tick.bind(this),\n\t\t\t\tcontext: this.context,\n\t\t\t\tvalue,\n\t\t\t});\n\t\t}\n\t\t// the start offset\n\t\tevent.startOffset = ticks;\n\n\t\t// initialize the values\n\t\tevent.set({\n\t\t\thumanize: this.humanize,\n\t\t\tloop: this.loop,\n\t\t\tloopEnd: this.loopEnd,\n\t\t\tloopStart: this.loopStart,\n\t\t\tplaybackRate: this.playbackRate,\n\t\t\tprobability: this.probability,\n\t\t});\n\n\t\tthis._events.add(event);\n\n\t\t// start the note if it should be played right now\n\t\tthis._restartEvent(event);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Restart the given event\n\t */\n\tprivate _restartEvent(event: ToneEvent): void {\n\t\tthis._state.forEach((stateEvent) => {\n\t\t\tif (stateEvent.state === \"started\") {\n\t\t\t\tthis._startNote(event, stateEvent.time, stateEvent.offset);\n\t\t\t} else {\n\t\t\t\t// stop the note\n\t\t\t\tevent.stop(new TicksClass(this.context, stateEvent.time));\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Remove an event from the part. If the event at that time is a Part,\n\t * it will remove the entire part.\n\t * @param time The time of the event\n\t * @param value Optionally select only a specific event value\n\t */\n\tremove(obj: {\n\t\ttime: Time;\n\t\t[key: string]: any;\n\t}): this;\n\tremove(time: Time, value?: any): this;\n\tremove(time: Time | object, value?: any): this {\n\t\t// extract the parameters\n\t\tif (isObject(time) && time.hasOwnProperty(\"time\")) {\n\t\t\tvalue = time;\n\t\t\ttime = value.time;\n\t\t}\n\t\ttime = this.toTicks(time);\n\t\tthis._events.forEach(event => {\n\t\t\tif (event.startOffset === time) {\n\t\t\t\tif (isUndef(value) || (isDefined(value) && event.value === value)) {\n\t\t\t\t\tthis._events.delete(event);\n\t\t\t\t\tevent.dispose();\n\t\t\t\t}\n\t\t\t}\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Remove all of the notes from the group.\n\t */\n\tclear(): this {\n\t\tthis._forEach(event => event.dispose());\n\t\tthis._events.clear();\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel scheduled state change events: i.e. \"start\" and \"stop\".\n\t * @param after The time after which to cancel the scheduled events.\n\t */\n\tcancel(after?: TransportTime | TransportTimeClass): this {\n\t\tthis._forEach(event => event.cancel(after));\n\t\tthis._state.cancel(this.toTicks(after));\n\t\treturn this;\n\t}\n\n\t/**\n\t * Iterate over all of the events\n\t */\n\tprivate _forEach(callback: (event: ToneEvent) => void): this {\n\t\tif (this._events) {\n\t\t\tthis._events.forEach(event => {\n\t\t\t\tif (event instanceof Part) {\n\t\t\t\t\tevent._forEach(callback);\n\t\t\t\t} else {\n\t\t\t\t\tcallback(event);\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Set the attribute of all of the events\n\t * @param  attr  the attribute to set\n\t * @param  value      The value to set it to\n\t */\n\tprivate _setAll(attr: string, value: any): void {\n\t\tthis._forEach(event => {\n\t\t\tevent[attr] = value;\n\t\t});\n\t}\n\n\t/**\n\t * Internal tick method\n\t * @param  time  The time of the event in seconds\n\t */\n\tprotected _tick(time: Seconds, value?: any): void {\n\t\tif (!this.mute) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * Determine if the event should be currently looping\n\t * given the loop boundries of this Part.\n\t * @param  event  The event to test\n\t */\n\tprivate _testLoopBoundries(event: ToneEvent): void {\n\t\tif (this._loop && (event.startOffset < this._loopStart || event.startOffset >= this._loopEnd)) {\n\t\t\tevent.cancel(0);\n\t\t} else if (event.state === \"stopped\") {\n\t\t\t// reschedule it if it's stopped\n\t\t\tthis._restartEvent(event);\n\t\t}\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._probability;\n\t}\n\tset probability(prob) {\n\t\tthis._probability = prob;\n\t\tthis._setAll(\"probability\", prob);\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._humanize = variation;\n\t\tthis._setAll(\"humanize\", variation);\n\t}\n\n\t/**\n\t * If the part should loop or not\n\t * between Part.loopStart and\n\t * Part.loopEnd. If set to true,\n\t * the part will loop indefinitely,\n\t * if set to a number greater than 1\n\t * it will play a specific number of\n\t * times, if set to false, 0 or 1, the\n\t * part will only play once.\n\t * @example\n\t * const part = new Tone.Part();\n\t * // loop the part 8 times\n\t * part.loop = 8;\n\t */\n\tget loop(): boolean | number {\n\t\treturn this._loop;\n\t}\n\tset loop(loop) {\n\t\tthis._loop = loop;\n\t\tthis._forEach(event => {\n\t\t\tevent.loopStart = this.loopStart;\n\t\t\tevent.loopEnd = this.loopEnd;\n\t\t\tevent.loop = loop;\n\t\t\tthis._testLoopBoundries(event);\n\t\t});\n\t}\n\n\t/**\n\t * The loopEnd point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopEnd(): Time {\n\t\treturn new TicksClass(this.context, this._loopEnd).toSeconds();\n\t}\n\tset loopEnd(loopEnd) {\n\t\tthis._loopEnd = this.toTicks(loopEnd);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopEnd = loopEnd;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The loopStart point determines when it will\n\t * loop if Part.loop is true.\n\t */\n\tget loopStart(): Time {\n\t\treturn new TicksClass(this.context, this._loopStart).toSeconds();\n\t}\n\tset loopStart(loopStart) {\n\t\tthis._loopStart = this.toTicks(loopStart);\n\t\tif (this._loop) {\n\t\t\tthis._forEach(event => {\n\t\t\t\tevent.loopStart = this.loopStart;\n\t\t\t\tthis._testLoopBoundries(event);\n\t\t\t});\n\t\t}\n\t}\n\n\t/**\n\t * The playback rate of the part\n\t */\n\tget playbackRate(): Positive {\n\t\treturn this._playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._playbackRate = rate;\n\t\tthis._setAll(\"playbackRate\", rate);\n\t}\n\n\t/**\n\t * The number of scheduled notes in the part.\n\t */\n\tget length(): number {\n\t\treturn this._events.size;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis.clear();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
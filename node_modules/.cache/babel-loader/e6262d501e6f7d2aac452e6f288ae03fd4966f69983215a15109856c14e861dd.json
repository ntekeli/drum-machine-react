{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { ToneWithContext } from \"../context/ToneWithContext\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { StateTimeline } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport var TickSource = /*#__PURE__*/function (_ToneWithContext) {\n  _inherits(TickSource, _ToneWithContext);\n  var _super = _createSuper(TickSource);\n  function TickSource() {\n    var _this;\n    _classCallCheck(this, TickSource);\n    _this = _super.call(this, optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n    _this.name = \"TickSource\";\n    /**\n     * The state timeline\n     */\n    _this._state = new StateTimeline();\n    /**\n     * The offset values of the ticks\n     */\n    _this._tickOffset = new Timeline();\n    var options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n    _this.frequency = new TickSignal({\n      context: _this.context,\n      units: options.units,\n      value: options.frequency\n    });\n    readOnly(_assertThisInitialized(_this), \"frequency\");\n    // set the initial state\n    _this._state.setStateAtTime(\"stopped\", 0);\n    // add the first event\n    _this.setTicksAtTime(0, 0);\n    return _this;\n  }\n  _createClass(TickSource, [{\n    key: \"state\",\n    get:\n    /**\n     * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n     */\n    function get() {\n      return this.getStateAtTime(this.now());\n    }\n    /**\n     * Start the clock at the given time. Optionally pass in an offset\n     * of where to start the tick counter from.\n     * @param  time    The time the clock should start\n     * @param offset The number of ticks to start the source at\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      var computedTime = this.toSeconds(time);\n      if (this._state.getValueAtTime(computedTime) !== \"started\") {\n        this._state.setStateAtTime(\"started\", computedTime);\n        if (isDefined(offset)) {\n          this.setTicksAtTime(offset, computedTime);\n        }\n      }\n      return this;\n    }\n    /**\n     * Stop the clock. Stopping the clock resets the tick counter to 0.\n     * @param time The time when the clock should stop.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      var computedTime = this.toSeconds(time);\n      // cancel the previous stop\n      if (this._state.getValueAtTime(computedTime) === \"stopped\") {\n        var event = this._state.get(computedTime);\n        if (event && event.time > 0) {\n          this._tickOffset.cancel(event.time);\n          this._state.cancel(event.time);\n        }\n      }\n      this._state.cancel(computedTime);\n      this._state.setStateAtTime(\"stopped\", computedTime);\n      this.setTicksAtTime(0, computedTime);\n      return this;\n    }\n    /**\n     * Pause the clock. Pausing does not reset the tick counter.\n     * @param time The time when the clock should stop.\n     */\n  }, {\n    key: \"pause\",\n    value: function pause(time) {\n      var computedTime = this.toSeconds(time);\n      if (this._state.getValueAtTime(computedTime) === \"started\") {\n        this._state.setStateAtTime(\"paused\", computedTime);\n      }\n      return this;\n    }\n    /**\n     * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n     * @param time When to clear the events after\n     */\n  }, {\n    key: \"cancel\",\n    value: function cancel(time) {\n      time = this.toSeconds(time);\n      this._state.cancel(time);\n      this._tickOffset.cancel(time);\n      return this;\n    }\n    /**\n     * Get the elapsed ticks at the given time\n     * @param  time  When to get the tick value\n     * @return The number of ticks\n     */\n  }, {\n    key: \"getTicksAtTime\",\n    value: function getTicksAtTime(time) {\n      var _this2 = this;\n      var computedTime = this.toSeconds(time);\n      var stopEvent = this._state.getLastState(\"stopped\", computedTime);\n      // this event allows forEachBetween to iterate until the current time\n      var tmpEvent = {\n        state: \"paused\",\n        time: computedTime\n      };\n      this._state.add(tmpEvent);\n      // keep track of the previous offset event\n      var lastState = stopEvent;\n      var elapsedTicks = 0;\n      // iterate through all the events since the last stop\n      this._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time;\n        // if there is an offset event in this period use that\n        var offsetEvent = _this2._tickOffset.get(e.time);\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedTicks = offsetEvent.ticks;\n          periodStartTime = offsetEvent.time;\n        }\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedTicks += _this2.frequency.getTicksAtTime(e.time) - _this2.frequency.getTicksAtTime(periodStartTime);\n        }\n        lastState = e;\n      });\n      // remove the temporary event\n      this._state.remove(tmpEvent);\n      // return the ticks\n      return elapsedTicks;\n    }\n    /**\n     * The number of times the callback was invoked. Starts counting at 0\n     * and increments after the callback was invoked. Returns -1 when stopped.\n     */\n  }, {\n    key: \"ticks\",\n    get: function get() {\n      return this.getTicksAtTime(this.now());\n    },\n    set: function set(t) {\n      this.setTicksAtTime(t, this.now());\n    }\n    /**\n     * The time since ticks=0 that the TickSource has been running. Accounts\n     * for tempo curves\n     */\n  }, {\n    key: \"seconds\",\n    get: function get() {\n      return this.getSecondsAtTime(this.now());\n    },\n    set: function set(s) {\n      var now = this.now();\n      var ticks = this.frequency.timeToTicks(s, now);\n      this.setTicksAtTime(ticks, now);\n    }\n    /**\n     * Return the elapsed seconds at the given time.\n     * @param  time  When to get the elapsed seconds\n     * @return  The number of elapsed seconds\n     */\n  }, {\n    key: \"getSecondsAtTime\",\n    value: function getSecondsAtTime(time) {\n      var _this3 = this;\n      time = this.toSeconds(time);\n      var stopEvent = this._state.getLastState(\"stopped\", time);\n      // this event allows forEachBetween to iterate until the current time\n      var tmpEvent = {\n        state: \"paused\",\n        time: time\n      };\n      this._state.add(tmpEvent);\n      // keep track of the previous offset event\n      var lastState = stopEvent;\n      var elapsedSeconds = 0;\n      // iterate through all the events since the last stop\n      this._state.forEachBetween(stopEvent.time, time + this.sampleTime, function (e) {\n        var periodStartTime = lastState.time;\n        // if there is an offset event in this period use that\n        var offsetEvent = _this3._tickOffset.get(e.time);\n        if (offsetEvent && offsetEvent.time >= lastState.time) {\n          elapsedSeconds = offsetEvent.seconds;\n          periodStartTime = offsetEvent.time;\n        }\n        if (lastState.state === \"started\" && e.state !== \"started\") {\n          elapsedSeconds += e.time - periodStartTime;\n        }\n        lastState = e;\n      });\n      // remove the temporary event\n      this._state.remove(tmpEvent);\n      // return the ticks\n      return elapsedSeconds;\n    }\n    /**\n     * Set the clock's ticks at the given time.\n     * @param  ticks The tick value to set\n     * @param  time  When to set the tick value\n     */\n  }, {\n    key: \"setTicksAtTime\",\n    value: function setTicksAtTime(ticks, time) {\n      time = this.toSeconds(time);\n      this._tickOffset.cancel(time);\n      this._tickOffset.add({\n        seconds: this.frequency.getDurationOfTicks(ticks, time),\n        ticks: ticks,\n        time: time\n      });\n      return this;\n    }\n    /**\n     * Returns the scheduled state at the given time.\n     * @param  time  The time to query.\n     */\n  }, {\n    key: \"getStateAtTime\",\n    value: function getStateAtTime(time) {\n      time = this.toSeconds(time);\n      return this._state.getValueAtTime(time);\n    }\n    /**\n     * Get the time of the given tick. The second argument\n     * is when to test before. Since ticks can be set (with setTicksAtTime)\n     * there may be multiple times for a given tick value.\n     * @param  tick The tick number.\n     * @param  before When to measure the tick value from.\n     * @return The time of the tick\n     */\n  }, {\n    key: \"getTimeOfTick\",\n    value: function getTimeOfTick(tick) {\n      var before = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : this.now();\n      var offset = this._tickOffset.get(before);\n      var event = this._state.get(before);\n      var startTime = Math.max(offset.time, event.time);\n      var absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n      return this.frequency.getTimeOfTick(absoluteTicks);\n    }\n    /**\n     * Invoke the callback event at all scheduled ticks between the\n     * start time and the end time\n     * @param  startTime  The beginning of the search range\n     * @param  endTime    The end of the search range\n     * @param  callback   The callback to invoke with each tick\n     */\n  }, {\n    key: \"forEachTickBetween\",\n    value: function forEachTickBetween(startTime, endTime, callback) {\n      var _this4 = this;\n      // only iterate through the sections where it is \"started\"\n      var lastStateEvent = this._state.get(startTime);\n      this._state.forEachBetween(startTime, endTime, function (event) {\n        if (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n          _this4.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - _this4.sampleTime, callback);\n        }\n        lastStateEvent = event;\n      });\n      var error = null;\n      if (lastStateEvent && lastStateEvent.state === \"started\") {\n        var maxStartTime = Math.max(lastStateEvent.time, startTime);\n        // figure out the difference between the frequency ticks and the\n        var startTicks = this.frequency.getTicksAtTime(maxStartTime);\n        var ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n        var diff = startTicks - ticksAtStart;\n        var offset = Math.ceil(diff) - diff;\n        // guard against floating point issues\n        offset = EQ(offset, 1) ? 0 : offset;\n        var nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n        while (nextTickTime < endTime) {\n          try {\n            callback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n          } catch (e) {\n            error = e;\n            break;\n          }\n          nextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n        }\n      }\n      if (error) {\n        throw error;\n      }\n      return this;\n    }\n    /**\n     * Clean up\n     */\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(TickSource.prototype), \"dispose\", this).call(this);\n      this._state.dispose();\n      this._tickOffset.dispose();\n      this.frequency.dispose();\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign({\n        frequency: 1,\n        units: \"hertz\"\n      }, ToneWithContext.getDefaults());\n    }\n  }]);\n  return TickSource;\n}(ToneWithContext);","map":{"version":3,"mappings":"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","names":["ToneWithContext","optionsFromArguments","readOnly","StateTimeline","Timeline","isDefined","TickSignal","EQ","TickSource","getDefaults","arguments","options","frequency","context","units","value","_state","setStateAtTime","setTicksAtTime","getStateAtTime","now","time","offset","computedTime","toSeconds","getValueAtTime","event","get","_tickOffset","cancel","stopEvent","getLastState","tmpEvent","state","add","lastState","elapsedTicks","forEachBetween","sampleTime","periodStartTime","offsetEvent","e","ticks","getTicksAtTime","remove","t","getSecondsAtTime","s","timeToTicks","elapsedSeconds","seconds","getDurationOfTicks","tick","before","startTime","Math","max","absoluteTicks","getTimeOfTick","endTime","callback","lastStateEvent","forEachTickBetween","error","maxStartTime","startTicks","ticksAtStart","diff","ceil","nextTickTime","round","dispose","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\core\\clock\\TickSource.ts"],"sourcesContent":["import { ToneWithContext, ToneWithContextOptions } from \"../context/ToneWithContext\";\nimport { Seconds, Ticks, Time } from \"../type/Units\";\nimport { optionsFromArguments } from \"../util/Defaults\";\nimport { readOnly } from \"../util/Interface\";\nimport { PlaybackState, StateTimeline, StateTimelineEvent } from \"../util/StateTimeline\";\nimport { Timeline } from \"../util/Timeline\";\nimport { isDefined } from \"../util/TypeCheck\";\nimport { TickSignal } from \"./TickSignal\";\nimport { EQ } from \"../util/Math\";\n\ninterface TickSourceOptions extends ToneWithContextOptions {\n\tfrequency: number;\n\tunits: \"bpm\" | \"hertz\";\n}\n\ninterface TickSourceOffsetEvent {\n\tticks: number;\n\ttime: number;\n\tseconds: number;\n}\n\n/**\n * Uses [TickSignal](TickSignal) to track elapsed ticks with complex automation curves.\n */\nexport class TickSource<TypeName extends \"bpm\" | \"hertz\"> extends ToneWithContext<TickSourceOptions> {\n\n\treadonly name: string = \"TickSource\";\n\n\t/**\n\t * The frequency the callback function should be invoked.\n\t */\n\treadonly frequency: TickSignal<TypeName>;\n\n\t/**\n\t * The state timeline\n\t */\n\tprivate _state: StateTimeline = new StateTimeline();\n\n\t/**\n\t * The offset values of the ticks\n\t */\n\tprivate _tickOffset: Timeline<TickSourceOffsetEvent> = new Timeline();\n\n\t/**\n\t * @param frequency The initial frequency that the signal ticks at\n\t */\n\tconstructor(frequency?: number);\n\tconstructor(options?: Partial<TickSourceOptions>);\n\tconstructor() {\n\t\tsuper(optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]));\n\t\tconst options = optionsFromArguments(TickSource.getDefaults(), arguments, [\"frequency\"]);\n\n\t\tthis.frequency = new TickSignal({\n\t\t\tcontext: this.context,\n\t\t\tunits: options.units as TypeName,\n\t\t\tvalue: options.frequency,\n\t\t});\n\t\treadOnly(this, \"frequency\");\n\n\t\t// set the initial state\n\t\tthis._state.setStateAtTime(\"stopped\", 0);\n\t\t// add the first event\n\t\tthis.setTicksAtTime(0, 0);\n\t}\n\n\tstatic getDefaults(): TickSourceOptions {\n\t\treturn Object.assign({\n\t\t\tfrequency: 1,\n\t\t\tunits: \"hertz\" as \"hertz\",\n\t\t}, ToneWithContext.getDefaults());\n\t}\n\n\t/**\n\t * Returns the playback state of the source, either \"started\", \"stopped\" or \"paused\".\n\t */\n\tget state(): PlaybackState {\n\t\treturn this.getStateAtTime(this.now());\n\t}\n\n\t/**\n\t * Start the clock at the given time. Optionally pass in an offset\n\t * of where to start the tick counter from.\n\t * @param  time    The time the clock should start\n\t * @param offset The number of ticks to start the source at\n\t */\n\tstart(time: Time, offset?: Ticks): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) !== \"started\") {\n\t\t\tthis._state.setStateAtTime(\"started\", computedTime);\n\t\t\tif (isDefined(offset)) {\n\t\t\t\tthis.setTicksAtTime(offset, computedTime);\n\t\t\t}\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the clock. Stopping the clock resets the tick counter to 0.\n\t * @param time The time when the clock should stop.\n\t */\n\tstop(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\t// cancel the previous stop\n\t\tif (this._state.getValueAtTime(computedTime) === \"stopped\") {\n\t\t\tconst event = this._state.get(computedTime);\n\t\t\tif (event && event.time > 0) {\n\t\t\t\tthis._tickOffset.cancel(event.time);\n\t\t\t\tthis._state.cancel(event.time);\n\t\t\t}\n\t\t}\n\t\tthis._state.cancel(computedTime);\n\t\tthis._state.setStateAtTime(\"stopped\", computedTime);\n\t\tthis.setTicksAtTime(0, computedTime);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Pause the clock. Pausing does not reset the tick counter.\n\t * @param time The time when the clock should stop.\n\t */\n\tpause(time: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tif (this._state.getValueAtTime(computedTime) === \"started\") {\n\t\t\tthis._state.setStateAtTime(\"paused\", computedTime);\n\t\t}\n\t\treturn this;\n\t}\n\n\t/**\n\t * Cancel start/stop/pause and setTickAtTime events scheduled after the given time.\n\t * @param time When to clear the events after\n\t */\n\tcancel(time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._state.cancel(time);\n\t\tthis._tickOffset.cancel(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Get the elapsed ticks at the given time\n\t * @param  time  When to get the tick value\n\t * @return The number of ticks\n\t */\n\tgetTicksAtTime(time?: Time): Ticks {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", computedTime) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time: computedTime };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedTicks = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, computedTime + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedTicks = offsetEvent.ticks;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedTicks += this.frequency.getTicksAtTime(e.time) - this.frequency.getTicksAtTime(periodStartTime);\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedTicks;\n\t}\n\n\t/**\n\t * The number of times the callback was invoked. Starts counting at 0\n\t * and increments after the callback was invoked. Returns -1 when stopped.\n\t */\n\tget ticks(): Ticks {\n\t\treturn this.getTicksAtTime(this.now());\n\t}\n\tset ticks(t: Ticks) {\n\t\tthis.setTicksAtTime(t, this.now());\n\t}\n\n\t/**\n\t * The time since ticks=0 that the TickSource has been running. Accounts\n\t * for tempo curves\n\t */\n\tget seconds(): Seconds {\n\t\treturn this.getSecondsAtTime(this.now());\n\t}\n\tset seconds(s: Seconds) {\n\t\tconst now = this.now();\n\t\tconst ticks = this.frequency.timeToTicks(s, now);\n\t\tthis.setTicksAtTime(ticks, now);\n\t}\n\n\t/**\n\t * Return the elapsed seconds at the given time.\n\t * @param  time  When to get the elapsed seconds\n\t * @return  The number of elapsed seconds\n\t */\n\tgetSecondsAtTime(time: Time): Seconds {\n\t\ttime = this.toSeconds(time);\n\t\tconst stopEvent = this._state.getLastState(\"stopped\", time) as StateTimelineEvent;\n\t\t// this event allows forEachBetween to iterate until the current time\n\t\tconst tmpEvent: StateTimelineEvent = { state: \"paused\", time };\n\t\tthis._state.add(tmpEvent);\n\n\t\t// keep track of the previous offset event\n\t\tlet lastState = stopEvent;\n\t\tlet elapsedSeconds = 0;\n\n\t\t// iterate through all the events since the last stop\n\t\tthis._state.forEachBetween(stopEvent.time, time + this.sampleTime, e => {\n\t\t\tlet periodStartTime = lastState.time;\n\t\t\t// if there is an offset event in this period use that\n\t\t\tconst offsetEvent = this._tickOffset.get(e.time);\n\t\t\tif (offsetEvent && offsetEvent.time >= lastState.time) {\n\t\t\t\telapsedSeconds = offsetEvent.seconds;\n\t\t\t\tperiodStartTime = offsetEvent.time;\n\t\t\t}\n\t\t\tif (lastState.state === \"started\" && e.state !== \"started\") {\n\t\t\t\telapsedSeconds += e.time - periodStartTime;\n\t\t\t}\n\t\t\tlastState = e;\n\t\t});\n\n\t\t// remove the temporary event\n\t\tthis._state.remove(tmpEvent);\n\n\t\t// return the ticks\n\t\treturn elapsedSeconds;\n\t}\n\n\t/**\n\t * Set the clock's ticks at the given time.\n\t * @param  ticks The tick value to set\n\t * @param  time  When to set the tick value\n\t */\n\tsetTicksAtTime(ticks: Ticks, time: Time): this {\n\t\ttime = this.toSeconds(time);\n\t\tthis._tickOffset.cancel(time);\n\t\tthis._tickOffset.add({\n\t\t\tseconds: this.frequency.getDurationOfTicks(ticks, time),\n\t\t\tticks,\n\t\t\ttime,\n\t\t});\n\t\treturn this;\n\t}\n\n\t/**\n\t * Returns the scheduled state at the given time.\n\t * @param  time  The time to query.\n\t */\n\tgetStateAtTime(time: Time): PlaybackState {\n\t\ttime = this.toSeconds(time);\n\t\treturn this._state.getValueAtTime(time);\n\t}\n\n\t/**\n\t * Get the time of the given tick. The second argument\n\t * is when to test before. Since ticks can be set (with setTicksAtTime)\n\t * there may be multiple times for a given tick value.\n\t * @param  tick The tick number.\n\t * @param  before When to measure the tick value from.\n\t * @return The time of the tick\n\t */\n\tgetTimeOfTick(tick: Ticks, before = this.now()): Seconds {\n\t\tconst offset = this._tickOffset.get(before) as TickSourceOffsetEvent;\n\t\tconst event = this._state.get(before) as StateTimelineEvent;\n\t\tconst startTime = Math.max(offset.time, event.time);\n\t\tconst absoluteTicks = this.frequency.getTicksAtTime(startTime) + tick - offset.ticks;\n\t\treturn this.frequency.getTimeOfTick(absoluteTicks);\n\t}\n\n\t/**\n\t * Invoke the callback event at all scheduled ticks between the\n\t * start time and the end time\n\t * @param  startTime  The beginning of the search range\n\t * @param  endTime    The end of the search range\n\t * @param  callback   The callback to invoke with each tick\n\t */\n\tforEachTickBetween(startTime: number, endTime: number, callback: (when: Seconds, ticks: Ticks) => void): this {\n\t\t// only iterate through the sections where it is \"started\"\n\t\tlet lastStateEvent = this._state.get(startTime);\n\t\tthis._state.forEachBetween(startTime, endTime, event => {\n\t\t\tif (lastStateEvent && lastStateEvent.state === \"started\" && event.state !== \"started\") {\n\t\t\t\tthis.forEachTickBetween(Math.max(lastStateEvent.time, startTime), event.time - this.sampleTime, callback);\n\t\t\t}\n\t\t\tlastStateEvent = event;\n\t\t});\n\n\t\tlet error: Error | null = null;\n\n\t\tif (lastStateEvent && lastStateEvent.state === \"started\") {\n\t\t\tconst maxStartTime = Math.max(lastStateEvent.time, startTime);\n\t\t\t// figure out the difference between the frequency ticks and the\n\t\t\tconst startTicks = this.frequency.getTicksAtTime(maxStartTime);\n\t\t\tconst ticksAtStart = this.frequency.getTicksAtTime(lastStateEvent.time);\n\t\t\tconst diff = startTicks - ticksAtStart;\n\t\t\tlet offset = Math.ceil(diff) - diff;\n\t\t\t// guard against floating point issues\n\t\t\toffset = EQ(offset, 1) ? 0 : offset;\n\t\t\tlet nextTickTime = this.frequency.getTimeOfTick(startTicks + offset);\n\t\t\twhile (nextTickTime < endTime) {\n\t\t\t\ttry {\n\t\t\t\t\tcallback(nextTickTime, Math.round(this.getTicksAtTime(nextTickTime)));\n\t\t\t\t} catch (e) {\n\t\t\t\t\terror = e;\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t\tnextTickTime += this.frequency.getDurationOfTicks(1, nextTickTime);\n\t\t\t}\n\t\t}\n\n\t\tif (error) {\n\t\t\tthrow error;\n\t\t}\n\n\t\treturn this;\n\t}\n\n\t/**\n\t * Clean up\n\t */\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._state.dispose();\n\t\tthis._tickOffset.dispose();\n\t\tthis.frequency.dispose();\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
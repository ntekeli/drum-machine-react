{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _assertThisInitialized from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/assertThisInitialized.js\";\nimport _get from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/get.js\";\nimport _getPrototypeOf from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/getPrototypeOf.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { TicksClass } from \"../core/type/Ticks\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent } from \"./ToneEvent\";\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport var Sequence = /*#__PURE__*/function (_ToneEvent) {\n  _inherits(Sequence, _ToneEvent);\n  var _super = _createSuper(Sequence);\n  function Sequence() {\n    var _this;\n    _classCallCheck(this, Sequence);\n    _this = _super.call(this, optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n    _this.name = \"Sequence\";\n    /**\n     * The object responsible for scheduling all of the events\n     */\n    _this._part = new Part({\n      callback: _this._seqCallback.bind(_assertThisInitialized(_this)),\n      context: _this.context\n    });\n    /**\n     * private reference to all of the sequence proxies\n     */\n    _this._events = [];\n    /**\n     * The proxied array\n     */\n    _this._eventsArray = [];\n    var options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n    _this._subdivision = _this.toTicks(options.subdivision);\n    _this.events = options.events;\n    // set all of the values\n    _this.loop = options.loop;\n    _this.loopStart = options.loopStart;\n    _this.loopEnd = options.loopEnd;\n    _this.playbackRate = options.playbackRate;\n    _this.probability = options.probability;\n    _this.humanize = options.humanize;\n    _this.mute = options.mute;\n    _this.playbackRate = options.playbackRate;\n    return _this;\n  }\n  _createClass(Sequence, [{\n    key: \"_seqCallback\",\n    value:\n    /**\n     * The internal callback for when an event is invoked\n     */\n    function _seqCallback(time, value) {\n      if (value !== null) {\n        this.callback(time, value);\n      }\n    }\n    /**\n     * The sequence\n     */\n  }, {\n    key: \"events\",\n    get: function get() {\n      return this._events;\n    },\n    set: function set(s) {\n      this.clear();\n      this._eventsArray = s;\n      this._events = this._createSequence(this._eventsArray);\n      this._eventsUpdated();\n    }\n    /**\n     * Start the part at the given time.\n     * @param  time    When to start the part.\n     * @param  offset  The offset index to start at\n     */\n  }, {\n    key: \"start\",\n    value: function start(time, offset) {\n      this._part.start(time, offset ? this._indexTime(offset) : offset);\n      return this;\n    }\n    /**\n     * Stop the part at the given time.\n     * @param  time  When to stop the part.\n     */\n  }, {\n    key: \"stop\",\n    value: function stop(time) {\n      this._part.stop(time);\n      return this;\n    }\n    /**\n     * The subdivision of the sequence. This can only be\n     * set in the constructor. The subdivision is the\n     * interval between successive steps.\n     */\n  }, {\n    key: \"subdivision\",\n    get: function get() {\n      return new TicksClass(this.context, this._subdivision).toSeconds();\n    }\n    /**\n     * Create a sequence proxy which can be monitored to create subsequences\n     */\n  }, {\n    key: \"_createSequence\",\n    value: function _createSequence(array) {\n      var _this2 = this;\n      return new Proxy(array, {\n        get: function get(target, property) {\n          // property is index in this case\n          return target[property];\n        },\n        set: function set(target, property, value) {\n          if (isString(property) && isFinite(parseInt(property, 10))) {\n            if (isArray(value)) {\n              target[property] = _this2._createSequence(value);\n            } else {\n              target[property] = value;\n            }\n          } else {\n            target[property] = value;\n          }\n          _this2._eventsUpdated();\n          // return true to accept the changes\n          return true;\n        }\n      });\n    }\n    /**\n     * When the sequence has changed, all of the events need to be recreated\n     */\n  }, {\n    key: \"_eventsUpdated\",\n    value: function _eventsUpdated() {\n      this._part.clear();\n      this._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n      // update the loopEnd\n      this.loopEnd = this.loopEnd;\n    }\n    /**\n     * reschedule all of the events that need to be rescheduled\n     */\n  }, {\n    key: \"_rescheduleSequence\",\n    value: function _rescheduleSequence(sequence, subdivision, startOffset) {\n      var _this3 = this;\n      sequence.forEach(function (value, index) {\n        var eventOffset = index * subdivision + startOffset;\n        if (isArray(value)) {\n          _this3._rescheduleSequence(value, subdivision / value.length, eventOffset);\n        } else {\n          var startTime = new TicksClass(_this3.context, eventOffset, \"i\").toSeconds();\n          _this3._part.add(startTime, value);\n        }\n      });\n    }\n    /**\n     * Get the time of the index given the Sequence's subdivision\n     * @param  index\n     * @return The time of that index\n     */\n  }, {\n    key: \"_indexTime\",\n    value: function _indexTime(index) {\n      return new TicksClass(this.context, index * this._subdivision + this.startOffset).toSeconds();\n    }\n    /**\n     * Clear all of the events\n     */\n  }, {\n    key: \"clear\",\n    value: function clear() {\n      this._part.clear();\n      return this;\n    }\n  }, {\n    key: \"dispose\",\n    value: function dispose() {\n      _get(_getPrototypeOf(Sequence.prototype), \"dispose\", this).call(this);\n      this._part.dispose();\n      return this;\n    }\n    //-------------------------------------\n    // PROXY CALLS\n    //-------------------------------------\n  }, {\n    key: \"loop\",\n    get: function get() {\n      return this._part.loop;\n    },\n    set: function set(l) {\n      this._part.loop = l;\n    }\n    /**\n     * The index at which the sequence should start looping\n     */\n  }, {\n    key: \"loopStart\",\n    get: function get() {\n      return this._loopStart;\n    },\n    set: function set(index) {\n      this._loopStart = index;\n      this._part.loopStart = this._indexTime(index);\n    }\n    /**\n     * The index at which the sequence should end looping\n     */\n  }, {\n    key: \"loopEnd\",\n    get: function get() {\n      return this._loopEnd;\n    },\n    set: function set(index) {\n      this._loopEnd = index;\n      if (index === 0) {\n        this._part.loopEnd = this._indexTime(this._eventsArray.length);\n      } else {\n        this._part.loopEnd = this._indexTime(index);\n      }\n    }\n  }, {\n    key: \"startOffset\",\n    get: function get() {\n      return this._part.startOffset;\n    },\n    set: function set(start) {\n      this._part.startOffset = start;\n    }\n  }, {\n    key: \"playbackRate\",\n    get: function get() {\n      return this._part.playbackRate;\n    },\n    set: function set(rate) {\n      this._part.playbackRate = rate;\n    }\n  }, {\n    key: \"probability\",\n    get: function get() {\n      return this._part.probability;\n    },\n    set: function set(prob) {\n      this._part.probability = prob;\n    }\n  }, {\n    key: \"progress\",\n    get: function get() {\n      return this._part.progress;\n    }\n  }, {\n    key: \"humanize\",\n    get: function get() {\n      return this._part.humanize;\n    },\n    set: function set(variation) {\n      this._part.humanize = variation;\n    }\n    /**\n     * The number of scheduled events\n     */\n  }, {\n    key: \"length\",\n    get: function get() {\n      return this._part.length;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n        events: [],\n        loop: true,\n        loopEnd: 0,\n        loopStart: 0,\n        subdivision: \"8n\"\n      });\n    }\n  }]);\n  return Sequence;\n}(ToneEvent);","map":{"version":3,"mappings":"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","names":["TicksClass","omitFromObject","optionsFromArguments","isArray","isString","Part","ToneEvent","Sequence","getDefaults","arguments","callback","_seqCallback","bind","context","options","_subdivision","toTicks","subdivision","events","loop","loopStart","loopEnd","playbackRate","probability","humanize","mute","time","value","_events","s","clear","_eventsArray","_createSequence","_eventsUpdated","offset","_part","start","_indexTime","stop","toSeconds","array","Proxy","get","target","property","set","isFinite","parseInt","_rescheduleSequence","startOffset","sequence","forEach","index","eventOffset","length","startTime","add","dispose","l","_loopStart","_loopEnd","rate","prob","progress","variation","Object","assign"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\event\\Sequence.ts"],"sourcesContent":["import { TicksClass } from \"../core/type/Ticks\";\nimport { NormalRange, Positive, Seconds, Ticks, Time, TransportTime } from \"../core/type/Units\";\nimport { omitFromObject, optionsFromArguments } from \"../core/util/Defaults\";\nimport { isArray, isString } from \"../core/util/TypeCheck\";\nimport { Part } from \"./Part\";\nimport { ToneEvent, ToneEventCallback, ToneEventOptions } from \"./ToneEvent\";\n\ntype SequenceEventDescription<T> = Array<T | Array<T | Array<T | Array<T | Array<T | T[]>>>>>;\n\ninterface SequenceOptions<T> extends Omit<ToneEventOptions<T>, \"value\"> {\n\tloopStart: number;\n\tloopEnd: number;\n\tsubdivision: Time;\n\tevents: SequenceEventDescription<T>;\n}\n\n/**\n * A sequence is an alternate notation of a part. Instead\n * of passing in an array of [time, event] pairs, pass\n * in an array of events which will be spaced at the\n * given subdivision. Sub-arrays will subdivide that beat\n * by the number of items are in the array.\n * Sequence notation inspiration from [Tidal](http://yaxu.org/tidal/)\n * @example\n * const synth = new Tone.Synth().toDestination();\n * const seq = new Tone.Sequence((time, note) => {\n * \tsynth.triggerAttackRelease(note, 0.1, time);\n * \t// subdivisions are given as subarrays\n * }, [\"C4\", [\"E4\", \"D4\", \"E4\"], \"G4\", [\"A4\", \"G4\"]]).start(0);\n * Tone.Transport.start();\n * @category Event\n */\nexport class Sequence<ValueType = any> extends ToneEvent<ValueType> {\n\n\treadonly name: string = \"Sequence\";\n\n\t/**\n\t * The subdivison of each note\n\t */\n\tprivate _subdivision: Ticks;\n\n\t/**\n\t * The object responsible for scheduling all of the events\n\t */\n\tprivate _part: Part = new Part({\n\t\tcallback: this._seqCallback.bind(this),\n\t\tcontext: this.context,\n\t});\n\n\t/**\n\t * private reference to all of the sequence proxies\n\t */\n\tprivate _events: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * The proxied array\n\t */\n\tprivate _eventsArray: SequenceEventDescription<ValueType> = [];\n\n\t/**\n\t * @param  callback  The callback to invoke with every note\n\t * @param  sequence  The sequence\n\t * @param  subdivision  The subdivision between which events are placed.\n\t */\n\tconstructor(\n\t\tcallback?: ToneEventCallback<ValueType>,\n\t\tevents?: SequenceEventDescription<ValueType>,\n\t\tsubdivision?: Time,\n\t);\n\tconstructor(options?: Partial<SequenceOptions<ValueType>>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]));\n\t\tconst options = optionsFromArguments(Sequence.getDefaults(), arguments, [\"callback\", \"events\", \"subdivision\"]);\n\n\t\tthis._subdivision = this.toTicks(options.subdivision);\n\n\t\tthis.events = options.events;\n\n\t\t// set all of the values\n\t\tthis.loop = options.loop;\n\t\tthis.loopStart = options.loopStart;\n\t\tthis.loopEnd = options.loopEnd;\n\t\tthis.playbackRate = options.playbackRate;\n\t\tthis.probability = options.probability;\n\t\tthis.humanize = options.humanize;\n\t\tthis.mute = options.mute;\n\t\tthis.playbackRate = options.playbackRate;\n\t}\n\n\tstatic getDefaults(): SequenceOptions<any> {\n\t\treturn Object.assign(omitFromObject(ToneEvent.getDefaults(), [\"value\"]), {\n\t\t\tevents: [],\n\t\t\tloop: true,\n\t\t\tloopEnd: 0,\n\t\t\tloopStart: 0,\n\t\t\tsubdivision: \"8n\",\n\t\t});\n\t}\n\n\t/**\n\t * The internal callback for when an event is invoked\n\t */\n\tprivate _seqCallback(time: Seconds, value: any): void {\n\t\tif (value !== null) {\n\t\t\tthis.callback(time, value);\n\t\t}\n\t}\n\n\t/**\n\t * The sequence\n\t */\n\tget events(): any[] {\n\t\treturn this._events;\n\t}\n\tset events(s) {\n\t\tthis.clear();\n\t\tthis._eventsArray = s;\n\t\tthis._events = this._createSequence(this._eventsArray);\n\t\tthis._eventsUpdated();\n\t}\n\n\t/**\n\t * Start the part at the given time.\n\t * @param  time    When to start the part.\n\t * @param  offset  The offset index to start at\n\t */\n\tstart(time?: TransportTime, offset?: number): this {\n\t\tthis._part.start(time, offset ? this._indexTime(offset) : offset);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Stop the part at the given time.\n\t * @param  time  When to stop the part.\n\t */\n\tstop(time?: TransportTime): this {\n\t\tthis._part.stop(time);\n\t\treturn this;\n\t}\n\n\t/**\n\t * The subdivision of the sequence. This can only be\n\t * set in the constructor. The subdivision is the\n\t * interval between successive steps.\n\t */\n\tget subdivision(): Seconds {\n\t\treturn new TicksClass(this.context, this._subdivision).toSeconds();\n\t}\n\n\t/**\n\t * Create a sequence proxy which can be monitored to create subsequences\n\t */\n\tprivate _createSequence(array: any[]): any[] {\n\t\treturn new Proxy(array, {\n\t\t\tget: (target: any[], property: PropertyKey): any => {\n\t\t\t\t// property is index in this case\n\t\t\t\treturn target[property];\n\t\t\t},\n\t\t\tset: (target: any[], property: PropertyKey, value: any): boolean => {\n\t\t\t\tif (isString(property) && isFinite(parseInt(property, 10))) {\n\t\t\t\t\tif (isArray(value)) {\n\t\t\t\t\t\ttarget[property] = this._createSequence(value);\n\t\t\t\t\t} else {\n\t\t\t\t\t\ttarget[property] = value;\n\t\t\t\t\t}\n\t\t\t\t} else {\n\t\t\t\t\ttarget[property] = value;\n\t\t\t\t}\n\t\t\t\tthis._eventsUpdated();\n\t\t\t\t// return true to accept the changes\n\t\t\t\treturn true;\n\t\t\t},\n\t\t});\n\t}\n\n\t/**\n\t * When the sequence has changed, all of the events need to be recreated\n\t */\n\tprivate _eventsUpdated(): void {\n\t\tthis._part.clear();\n\t\tthis._rescheduleSequence(this._eventsArray, this._subdivision, this.startOffset);\n\t\t// update the loopEnd\n\t\tthis.loopEnd = this.loopEnd;\n\t}\n\n\t/**\n\t * reschedule all of the events that need to be rescheduled\n\t */\n\tprivate _rescheduleSequence(sequence: any[], subdivision: Ticks, startOffset: Ticks): void {\n\t\tsequence.forEach((value, index) => {\n\t\t\tconst eventOffset = index * (subdivision) + startOffset;\n\t\t\tif (isArray(value)) {\n\t\t\t\tthis._rescheduleSequence(value, subdivision / value.length, eventOffset);\n\t\t\t} else {\n\t\t\t\tconst startTime = new TicksClass(this.context, eventOffset, \"i\").toSeconds();\n\t\t\t\tthis._part.add(startTime, value);\n\t\t\t}\n\t\t});\n\t}\n\n\t/**\n\t * Get the time of the index given the Sequence's subdivision\n\t * @param  index\n\t * @return The time of that index\n\t */\n\tprivate _indexTime(index: number): Seconds {\n\t\treturn new TicksClass(this.context, index * (this._subdivision) + this.startOffset).toSeconds();\n\t}\n\n\t/**\n\t * Clear all of the events\n\t */\n\tclear(): this {\n\t\tthis._part.clear();\n\t\treturn this;\n\t}\n\n\tdispose(): this {\n\t\tsuper.dispose();\n\t\tthis._part.dispose();\n\t\treturn this;\n\t}\n\n\t//-------------------------------------\n\t// PROXY CALLS\n\t//-------------------------------------\n\n\tget loop(): boolean | number {\n\t\treturn this._part.loop;\n\t}\n\tset loop(l) {\n\t\tthis._part.loop = l;\n\t}\n\n\t/**\n\t * The index at which the sequence should start looping\n\t */\n\tget loopStart(): number {\n\t\treturn this._loopStart;\n\t}\n\tset loopStart(index) {\n\t\tthis._loopStart = index;\n\t\tthis._part.loopStart = this._indexTime(index);\n\t}\n\n\t/**\n\t * The index at which the sequence should end looping\n\t */\n\tget loopEnd(): number {\n\t\treturn this._loopEnd;\n\t}\n\tset loopEnd(index) {\n\t\tthis._loopEnd = index;\n\t\tif (index === 0) {\n\t\t\tthis._part.loopEnd = this._indexTime(this._eventsArray.length);\n\t\t} else {\n\t\t\tthis._part.loopEnd = this._indexTime(index);\n\t\t}\n\t}\n\n\tget startOffset(): Ticks {\n\t\treturn this._part.startOffset;\n\t}\n\tset startOffset(start) {\n\t\tthis._part.startOffset = start;\n\t}\n\n\tget playbackRate(): Positive {\n\t\treturn this._part.playbackRate;\n\t}\n\tset playbackRate(rate) {\n\t\tthis._part.playbackRate = rate;\n\t}\n\n\tget probability(): NormalRange {\n\t\treturn this._part.probability;\n\t}\n\tset probability(prob) {\n\t\tthis._part.probability = prob;\n\t}\n\n\tget progress(): NormalRange {\n\t\treturn this._part.progress;\n\t}\n\n\tget humanize(): boolean | Time {\n\t\treturn this._part.humanize;\n\t}\n\tset humanize(variation) {\n\t\tthis._part.humanize = variation;\n\t}\n\n\t/**\n\t * The number of scheduled events\n\t */\n\tget length(): number {\n\t\treturn this._part.length;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}
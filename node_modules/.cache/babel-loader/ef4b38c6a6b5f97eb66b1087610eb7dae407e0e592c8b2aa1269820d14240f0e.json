{"ast":null,"code":"import _classCallCheck from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/classCallCheck.js\";\nimport _createClass from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createClass.js\";\nimport _inherits from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/inherits.js\";\nimport _createSuper from \"C:/Users/Ntekeli/Desktop/drum-machine/drum-machine/node_modules/@babel/runtime/helpers/esm/createSuper.js\";\nimport { __decorate } from \"tslib\";\nimport { FrequencyClass } from \"../core/type/Frequency\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument } from \"../instrument/Instrument\";\nimport { timeRange } from \"../core/util/Decorator\";\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport var Monophonic = /*#__PURE__*/function (_Instrument) {\n  _inherits(Monophonic, _Instrument);\n  var _super = _createSuper(Monophonic);\n  function Monophonic() {\n    var _this;\n    _classCallCheck(this, Monophonic);\n    _this = _super.call(this, optionsFromArguments(Monophonic.getDefaults(), arguments));\n    var options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n    _this.portamento = options.portamento;\n    _this.onsilence = options.onsilence;\n    return _this;\n  }\n  _createClass(Monophonic, [{\n    key: \"triggerAttack\",\n    value:\n    /**\n     * Trigger the attack of the note optionally with a given velocity.\n     * @param  note The note to trigger.\n     * @param  time When the note should start.\n     * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * // trigger the note a half second from now at half velocity\n     * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n     */\n    function triggerAttack(note, time) {\n      var velocity = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1;\n      this.log(\"triggerAttack\", note, time, velocity);\n      var seconds = this.toSeconds(time);\n      this._triggerEnvelopeAttack(seconds, velocity);\n      this.setNote(note, seconds);\n      return this;\n    }\n    /**\n     * Trigger the release portion of the envelope\n     * @param  time If no time is given, the release happens immediatly\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // trigger the release a second from now\n     * synth.triggerRelease(\"+1\");\n     */\n  }, {\n    key: \"triggerRelease\",\n    value: function triggerRelease(time) {\n      this.log(\"triggerRelease\", time);\n      var seconds = this.toSeconds(time);\n      this._triggerEnvelopeRelease(seconds);\n      return this;\n    }\n    /**\n     * Set the note at the given time. If no time is given, the note\n     * will set immediately.\n     * @param note The note to change to.\n     * @param  time The time when the note should be set.\n     * @example\n     * const synth = new Tone.Synth().toDestination();\n     * synth.triggerAttack(\"C4\");\n     * // change to F#6 in one quarter note from now.\n     * synth.setNote(\"F#6\", \"+4n\");\n     */\n  }, {\n    key: \"setNote\",\n    value: function setNote(note, time) {\n      var computedTime = this.toSeconds(time);\n      var computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n      if (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n        var portTime = this.toSeconds(this.portamento);\n        this.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n      } else {\n        this.frequency.setValueAtTime(computedFrequency, computedTime);\n      }\n      return this;\n    }\n  }], [{\n    key: \"getDefaults\",\n    value: function getDefaults() {\n      return Object.assign(Instrument.getDefaults(), {\n        detune: 0,\n        onsilence: noOp,\n        portamento: 0\n      });\n    }\n  }]);\n  return Monophonic;\n}(Instrument);\n__decorate([timeRange(0)], Monophonic.prototype, \"portamento\", void 0);","map":{"version":3,"mappings":";;;;;AAAA,SAASA,cAAc,QAAQ,wBAAwB;AAEvD,SAASC,oBAAoB,QAAQ,uBAAuB;AAC5D,SAASC,IAAI,QAAQ,wBAAwB;AAC7C,SAASC,UAAU,QAA2B,0BAA0B;AAExE,SAASC,SAAS,QAAQ,wBAAwB;AAUlD;;;AAGA,WAAsBC,UAA8C;EAAA;EAAA;EAwBnE;IAAA;IAAA;IAEC,0BAAMJ,oBAAoB,CAACI,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,CAAC;IAC/D,IAAMC,OAAO,GAAGP,oBAAoB,CAACI,UAAU,CAACC,WAAW,EAAE,EAAEC,SAAS,CAAC;IAEzE,MAAKE,UAAU,GAAGD,OAAO,CAACC,UAAU;IACpC,MAAKC,SAAS,GAAGF,OAAO,CAACE,SAAS;IAAC;EACpC;EAAC;IAAA;IAAA;IAUD;;;;;;;;;;IAUA,uBAAcC,IAAgC,EAAEC,IAAW,EAA2B;MAAA,IAAzBC,+EAAwB,CAAC;MACrF,IAAI,CAACC,GAAG,CAAC,eAAe,EAAEH,IAAI,EAAEC,IAAI,EAAEC,QAAQ,CAAC;MAC/C,IAAME,OAAO,GAAG,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;MACpC,IAAI,CAACK,sBAAsB,CAACF,OAAO,EAAEF,QAAQ,CAAC;MAC9C,IAAI,CAACK,OAAO,CAACP,IAAI,EAAEI,OAAO,CAAC;MAC3B,OAAO,IAAI;IACZ;IAEA;;;;;;;;;EAAA;IAAA;IAAA,OASA,wBAAeH,IAAW;MACzB,IAAI,CAACE,GAAG,CAAC,gBAAgB,EAAEF,IAAI,CAAC;MAChC,IAAMG,OAAO,GAAG,IAAI,CAACC,SAAS,CAACJ,IAAI,CAAC;MACpC,IAAI,CAACO,uBAAuB,CAACJ,OAAO,CAAC;MACrC,OAAO,IAAI;IACZ;IAoBA;;;;;;;;;;;EAAA;IAAA;IAAA,OAWA,iBAAQJ,IAAgC,EAAEC,IAAW;MACpD,IAAMQ,YAAY,GAAG,IAAI,CAACJ,SAAS,CAACJ,IAAI,CAAC;MACzC,IAAMS,iBAAiB,GAAGV,IAAI,YAAYX,cAAc,GAAGW,IAAI,CAACW,WAAW,EAAE,GAAGX,IAAI;MACpF,IAAI,IAAI,CAACF,UAAU,GAAG,CAAC,IAAI,IAAI,CAACc,cAAc,CAACH,YAAY,CAAC,GAAG,IAAI,EAAE;QACpE,IAAMI,QAAQ,GAAG,IAAI,CAACR,SAAS,CAAC,IAAI,CAACP,UAAU,CAAC;QAChD,IAAI,CAACgB,SAAS,CAACC,iBAAiB,CAACL,iBAAiB,EAAEG,QAAQ,EAAEJ,YAAY,CAAC;OAC3E,MAAM;QACN,IAAI,CAACK,SAAS,CAACE,cAAc,CAACN,iBAAiB,EAAED,YAAY,CAAC;;MAE/D,OAAO,IAAI;IACZ;EAAC;IAAA;IAAA,OAjFD,uBAAkB;MACjB,OAAOQ,MAAM,CAACC,MAAM,CAAC1B,UAAU,CAACG,WAAW,EAAE,EAAE;QAC9CwB,MAAM,EAAE,CAAC;QACTpB,SAAS,EAAER,IAAI;QACfO,UAAU,EAAE;OACZ,CAAC;IACH;EAAC;EAAA;AAAA,EAvC0EN,UAAmB;AAM9F4B,YADC3B,SAAS,CAAC,CAAC,CAAC,8CACO","names":["FrequencyClass","optionsFromArguments","noOp","Instrument","timeRange","Monophonic","getDefaults","arguments","options","portamento","onsilence","note","time","velocity","log","seconds","toSeconds","_triggerEnvelopeAttack","setNote","_triggerEnvelopeRelease","computedTime","computedFrequency","toFrequency","getLevelAtTime","portTime","frequency","exponentialRampTo","setValueAtTime","Object","assign","detune","__decorate"],"sources":["C:\\Users\\Ntekeli\\Desktop\\drum-machine\\drum-machine\\node_modules\\tone\\Tone\\instrument\\Monophonic.ts"],"sourcesContent":["import { FrequencyClass } from \"../core/type/Frequency\";\nimport { Cents, Frequency, NormalRange, Seconds, Time } from \"../core/type/Units\";\nimport { optionsFromArguments } from \"../core/util/Defaults\";\nimport { noOp } from \"../core/util/Interface\";\nimport { Instrument, InstrumentOptions } from \"../instrument/Instrument\";\nimport { Signal } from \"../signal/Signal\";\nimport { timeRange } from \"../core/util/Decorator\";\n\ntype onSilenceCallback = (instrument: Monophonic<any>) => void;\n\nexport interface MonophonicOptions extends InstrumentOptions {\n\tportamento: Seconds;\n\tonsilence: onSilenceCallback;\n\tdetune: Cents;\n}\n\n/**\n * Abstract base class for other monophonic instruments to extend.\n */\nexport abstract class Monophonic<Options extends MonophonicOptions> extends Instrument<Options> {\n\n\t/**\n\t * The glide time between notes.\n\t */\n\t@timeRange(0)\n\tportamento: Seconds;\n\n\t/**\n\t * Invoked when the release has finished and the output is silent.\n\t */\n\tonsilence: onSilenceCallback;\n\n\t/**\n\t * The instrument's frequency signal.\n\t */\n\tabstract readonly frequency: Signal<\"frequency\">;\n\n\t/**\n\t * The instrument's detune control signal.\n\t */\n\tabstract readonly detune: Signal<\"cents\">;\n\n\tconstructor(options?: Partial<MonophonicOptions>);\n\tconstructor() {\n\n\t\tsuper(optionsFromArguments(Monophonic.getDefaults(), arguments));\n\t\tconst options = optionsFromArguments(Monophonic.getDefaults(), arguments);\n\n\t\tthis.portamento = options.portamento;\n\t\tthis.onsilence = options.onsilence;\n\t}\n\n\tstatic getDefaults(): MonophonicOptions {\n\t\treturn Object.assign(Instrument.getDefaults(), {\n\t\t\tdetune: 0,\n\t\t\tonsilence: noOp,\n\t\t\tportamento: 0,\n\t\t});\n\t}\n\n\t/**\n\t * Trigger the attack of the note optionally with a given velocity.\n\t * @param  note The note to trigger.\n\t * @param  time When the note should start.\n\t * @param  velocity The velocity scaler determines how \"loud\" the note will be triggered.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * // trigger the note a half second from now at half velocity\n\t * synth.triggerAttack(\"C4\", \"+0.5\", 0.5);\n\t */\n\ttriggerAttack(note: Frequency | FrequencyClass, time?: Time, velocity: NormalRange = 1): this {\n\t\tthis.log(\"triggerAttack\", note, time, velocity);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeAttack(seconds, velocity);\n\t\tthis.setNote(note, seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Trigger the release portion of the envelope\n\t * @param  time If no time is given, the release happens immediatly\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // trigger the release a second from now\n\t * synth.triggerRelease(\"+1\");\n\t */\n\ttriggerRelease(time?: Time): this {\n\t\tthis.log(\"triggerRelease\", time);\n\t\tconst seconds = this.toSeconds(time);\n\t\tthis._triggerEnvelopeRelease(seconds);\n\t\treturn this;\n\t}\n\n\t/**\n\t * Internal method which starts the envelope attack\n\t */\n\tprotected abstract _triggerEnvelopeAttack(time: Seconds, velocity: NormalRange): void;\n\n\t/**\n\t * Internal method which starts the envelope release\n\t */\n\tprotected abstract _triggerEnvelopeRelease(time: Seconds): void;\n\n\t/**\n\t * Get the level of the output at the given time. Measures\n\t * the envelope(s) value at the time.\n\t * @param time The time to query the envelope value\n\t * @return The output level between 0-1\n\t */\n\tabstract getLevelAtTime(time: Time): NormalRange;\n\n\t/**\n\t * Set the note at the given time. If no time is given, the note\n\t * will set immediately.\n\t * @param note The note to change to.\n\t * @param  time The time when the note should be set.\n\t * @example\n\t * const synth = new Tone.Synth().toDestination();\n\t * synth.triggerAttack(\"C4\");\n\t * // change to F#6 in one quarter note from now.\n\t * synth.setNote(\"F#6\", \"+4n\");\n\t */\n\tsetNote(note: Frequency | FrequencyClass, time?: Time): this {\n\t\tconst computedTime = this.toSeconds(time);\n\t\tconst computedFrequency = note instanceof FrequencyClass ? note.toFrequency() : note;\n\t\tif (this.portamento > 0 && this.getLevelAtTime(computedTime) > 0.05) {\n\t\t\tconst portTime = this.toSeconds(this.portamento);\n\t\t\tthis.frequency.exponentialRampTo(computedFrequency, portTime, computedTime);\n\t\t} else {\n\t\t\tthis.frequency.setValueAtTime(computedFrequency, computedTime);\n\t\t}\n\t\treturn this;\n\t}\n}\n"]},"metadata":{},"sourceType":"module","externalDependencies":[]}